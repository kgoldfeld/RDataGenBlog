---
title: Estimating a Bayesian proportional hazards model
author: Package Build
date: '2025-02-11'
slug: []
categories: []
tags:
  - R
  - survival analysis
type: ''
subtitle: ''
image: ''
draft: TRUE
---

Like most of my posts, this one stems from a conversation with a colleague about a large cluster randomized trial that he's innovated with, which uses a [stepped-wedge design](https://www.rdatagen.net/post/2022-12-13-modeling-the-secular-trend-in-a-stepped-wedge-design/){target="_blank"} (SW-CRT) he is involved with. The challenge here is that the primary outcome of interest is a time-to-event. I was intrigued by how to analyze this kind of data to estimate a hazard ratio while accounting for clustering and potential secular trends that might influence the time to the event. A quick dive into the literature suggested that time-to-event outcomes aren't all that common in SW-CRTs-and that the best analytic approach isn't entirely clear.

My first thought, naturally, was: *How would I simulate data to explore different modeling approaches?* My second thought: *Could a Bayesian approach be useful here?*

I'm getting a little ahead of myself. Generating the complex data (with clustering and secular time trend) turned out to be fairly straightforward (I'll share that in a future post). But here I'm focusing on the early stages of developing a Bayesian model that might eventually accommodate flexible secular trends using splines, something I explored a bit [before](https://www.rdatagen.net/post/2024-10-08-can-chatgpt-help-construct-non-trivial-bayesian-models-with-cluster-specific-splines/){target="_blank"}. I started by generating a simple data set of time-to-event outcomes (without any clustering or time trends) and fitting a proportional hazards model using `Stan`code drawn from the [online guide](https://mc-stan.org/docs/stan-users-guide/survival.html#proportional-hazards-model){target="_blank"}. That model works fine, but it has a serious limitation, which I addressed in subsequent iterations. Getting to the final model turned out to be a bit more challenging than I initially envisioned. In this post, I'll walk through the steps I took along the way, but if you're just here for the final model, feel free to jump to the end.

My hope is that the final model will be flexible enough to handle the extensions I need for the data structure that sparked this whole exploration.

### Simulating an RCT with time-to-event outcomes

Before we get to the code, here are the `R` packages that are used in this post:

```{r, message=FALSE}
library(simstudy)
library(data.table)
library(survival)
library(cmdstanr)
```

Here are the data definitions for a two-arm randomized controlled trial that is stratified by a variable $M$. Both the treatment $A$ and covariate $M$ are associated with the time-to-event outcome, as defined in `defS`. On average, the treatment speeds up the time-to-event, and $M$ slows things down. (In `simstudy` survival times are [generated](https://www.rdatagen.net/post/2022-02-08-simulating-survival-outcomes-setting-the-parameters-for-the-desired-distribution/){target="_blank"} using a Weibull data generation process.)

```{r}
defI <-
  defData(varname = "M", formula = 0.3, dist = "binary") |>
  defData(varname = "A", formula = "1;1", variance = "M", dist = "trtAssign")

defS <- 
  defSurv(
    varname = "timeEvent", 
    formula = "-11.6 + ..delta_f * A + ..beta_m * M",
    shape = 0.30)  |>
  defSurv(varname = "censorTime", formula = -11.3, shape = .35)

## Parameters

delta_f <- 1.5
beta_m <- -1.0
```

We are generating 1000 independent observations:

```{r}
set.seed(123)

dd <- genData(1000, defI)
dd <- genSurv(dd, defS, timeName = "tte", censorName = "censorTime", eventName = "event")
dd
```

Here is a Kaplan-Meier plot showing the "survival" times for each level of $M$ and each treatment arm:

```{r plot1, echo=FALSE, message=FALSE, fig.width=7, fig.height=4}
library(ggplot2)
library(survminer)

dd_surv <- survfit(Surv(tte, event) ~ A + M, data = dd)
dd_surv_tidy <- data.table(surv_summary(dd_surv, data = dd))
dd_censor <- dd_surv_tidy[n.censor > 0, ]

ggplot(dd_surv_tidy, aes(time, surv, color = factor(A))) +
  geom_step() +  # Kaplan-Meier curves
  geom_point(data = dd_censor, aes(time, surv), shape = 3, size = 1, color = "black")  +
  labs(x = "Time to event", y = "Probability of no event") +
  scale_color_manual(
    values = c("0" = "orange", "1" = "darkgreen"),  
    labels = c("0" = "control", "1" = "treatment")) + 
  theme(
    panel.grid = element_blank(), 
    legend.title = element_blank(),
    strip.text = element_text(face = "bold")) +
  facet_grid(. ~ M, labeller = labeller(M = label_both))
```

Fitting a traditional Cox proportional hazards model, we can see that the log hazard ratio for treatment $A$ is greater than 0, suggesting that on average the time-to-event is shorter for those in the treatment arm. Likewise, those with $M=1$ have longer times-to-events and the log hazard ratio is less than zero:

```{r}
cox_model <- coxph(Surv(tte, event) ~ A + M, data = dd)
summary(cox_model)
```

### First Bayes model

As I mentioned before, I turned to `Stan` [documentation](https://mc-stan.org/docs/stan-users-guide/survival.html#proportional-hazards-model){target="_blank"} for the code that follows. I won't go into the detailed derivation of the partial likelihood here since that is covered very nicely in the document. However, it is useful to see the final likelihood that is then reflected in the code. 

The likelihood is written as follow - and note that the $n$'s represent only the cases with observed times:

$$
L(\beta)= \prod_{n=1}^{N^{obs}} \left( \frac{\text{exp}(x_n \cdot\beta)}{\sum_{n'=n}^{N} \text{exp}(x_{n'} \cdot \beta)}\right)
$$

where:

  * $N^{obs}$ is the number of observed times,
  * $x_n$ is the covariate for the $n$-th observed time,
  * $\beta$ is the coefficient (and is interpreted as the log hazard ratio)


We want the log likelihood, this gets transformed to sums of logs as

$$
\begin{aligned}
\text{log } Pr[\text{obs. fails ordered } 1, \dots N^{obs}|x, \beta] &= \sum_{n=1}^{N^{obs}} \text{log} \left( \frac{\text{exp}(x_n \cdot\beta)}{\sum_{n'=n}^{N} \text{exp}(x_{n'} \cdot \beta)}\right) \\
\\
&= \sum_{n=1}^{N^{obs}} \left( \text{exp}(x_n \cdot\beta) - \text{log}\sum_{n'=n}^{N} \text{exp}(x_{n'} \cdot \beta)\right)
\end{aligned}
$$
In `Stan`, the function `logSumExp` can be used to efficiently calculate

$$
\text{log}\sum_{n'=n}^{N} \text{exp}(x_{n'} \cdot \beta).
$$

This partial likelihood is implemented below in `Stan`. One confusing aspect (at least to me) is the way censoring is handled. Essentially, all event times for censored cases are assumed to occur *after* the last observed time. In this case, all censored cases are part of the risk set for observed events, which is not an approach I had seen before. This is a pretty big assumption and has implications for data where the actual censoring times are before the last observed event time.

The code is a little confusing, because the data are delivered to `Stan` in reverse order. It is done this way to make calculation of the log likelihood more efficient. But if you are trying to follow along with the code to see how it lines up with the equations above, it is good to keep in mind.

```{r}
stan_code <-
"
data {
  int<lower=0> K;          // num covariates

  int<lower=0> N;          // num uncensored obs
  vector[N] t;             // event time (non-strict decreasing)
  matrix[N, K] x;          // covariates for uncensored obs

  int N_c;                 // num censored obs
  real <lower=t[N]> t_c;   // censoring time
  matrix[N_c, K] x_c;      // covariates for censored obs
}

parameters {
  vector[K] beta;          // slopes (no intercept)
}

transformed parameters {
  vector[N] log_theta = x * beta;
  vector[N_c] log_theta_c = x_c * beta;
}

model {
  beta ~ normal(0, 4);
  
  real log_denom = log_sum_exp(log_theta_c);
  
  for (n in 1:N) {
    log_denom = log_sum_exp(log_denom, log_theta[n]);
    target += log_theta[n] - log_denom;   // log likelihood
  }
  
}
"
```

This code prepares the `R` data for `Stan`:

```{r}
dd.o <- dd[event == 1]
setorder(dd.o, -tte)
x.o <- data.frame(dd.o[, .(A, M)])
N.o <- dd.o[, .N]
t.o <- dd.o[, tte]

dd.c <- dd[event == 0]
setorder(dd.c, -tte)
x.c <- data.frame(dd.c[, .(A, M)])
N.c <- dd.c[, .N]
t.c <- dd.c[, tte]

K <- ncol(x.o)          # num covariates

stan_data <- list(
  K = K,
  N = N.o,
  t = t.o,
  x = x.o,
  N_c = N.c,
  t_c = max(t.c),
  x_c = x.c
)
```

I'm using `cmdstanr` to interface with `Stan`. First we compile the `Stan` code.

```{r}
stan_model <- cmdstan_model(write_stan_file(stan_code))
```

And then we fit the model. Even with 1,000 observations, the model estimates in just a couple of seconds on my laptop.

```{r}
fit <- stan_model$sample(
  data = stan_data, 
  iter_warmup = 1000,
  iter_sampling = 4000,
  chains = 4,
  parallel_chains = 4,
  refresh = 0
)
```

Looking at the log hazard ratios, though, something seems awry. The Bayesian estimates are attenuated relative to the original Cox PH estimates, and this is not due to the prior distribution assumption. Rather, it is the result of assuming that all censored times are longer than the longest observed time-to-event. I'm not showing this here, but the attenuation does largely go away if there is no censoring.

```{r}
fit$summary(variables = "beta")
```

Given this limitation, I decided to try to implement an algorithm that accommodates dynamic risk sets, effectively taking censored cases out of the analysis as soon as they are censored. This is what the model estimated using `coxph` above does.

### Second Bayes model

The partial likelihood for the Cox proportional hazards model is given by:

$$
L(\beta) = \prod_{i=1}^{n} \left( \frac{\exp x_i \beta}{\sum_{j \in R(t_i)} \exp(x_j\beta)} \right)^{\delta_i}
$$

where:

  * $n$ is the number of observations (censored or not),
  * $x_i$ is the covariates for the $i$-th observation,
  * $\beta$ is the coefficient of interest,
  * $t_i$ is the observed time for the $i$-th observation,
  * $R(t_i)$ is the risk set at time $t_i$ (the set of individuals still at risk just before time $t_i$) - which only includes censored cases censored *after* $t_i$,
  * $\delta_i$ is the event indicator ($\delta_i = 1$ if the event occurred, $\delta_i = 0$ if censored).
  
The `Stan` code below codes the log likelihood that follows from this. In contrast to the first version, the data is passed to `Stan` in ascending order. The one major complication is that I needed to create a search function in order to define the "risk" set. Actually, I asked DeepSeek to do this for me, and it obliged. The fundamental difference between this approach and the first approach is calculation of the denominator in the log likelihood.

```{r}
stan_code <-
"
functions {
  int binary_search(vector v, real tar_val) {
    int low = 1;
    int high = num_elements(v);
    int result = -1;

    while (low <= high) {
      int mid = (low + high) %/% 2;
      if (v[mid] == tar_val) {
        result = mid; // Store the index
        high = mid - 1; // Look for earlier occurrences
      } else if (v[mid] < tar_val) {
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    }
    return result;
  }
}

data {
  int<lower=0> K;          // Number of covariates

  int<lower=0> N_o;        // Number of uncensored observations
  vector[N_o] t_o;         // Event times (sorted in decreasing order)
  matrix[N_o, K] x_o;      // Covariates for uncensored observations

  int<lower=0> N;          // Number of total observations
  vector[N] t;             // Individual times
  matrix[N, K] x;          // Covariates for all observations
}

parameters {
  vector[K] beta;          // Fixed effects for covariates
}

model {
  
  // Prior

  beta ~ normal(0, 4);
  
  // Model

  vector[N] log_theta = x * beta;

  for (n_o in 1:N_o) {
    int start_risk = binary_search(t, t_o[n_o]); // Use binary search
    real log_denom = log_sum_exp(log_theta[start_risk:N]);
    target += log_theta[start_risk] - log_denom;
  }

}
"
```

Preparing the data is a little different. This time, I am passing the observed data and the full data, both in ascending order:

```{r}
dx <- copy(dd)
setorder(dx, tte)

dx.o <- dx[event == 1]
x_o <- data.frame(dx.o[, .(A, M)])
N_o <- dx.o[, .N]
t_o <- dx.o[, tte]

x_all <- data.frame(dx[, .(A, M)])
N_all <- dx[, .N]
t_all <- dx[, tte]

K <- ncol(x_o)          # num covariates

stan_data <- list(
  K = K,
  N_o = N_o,
  t_o = t_o,
  x_o = x_o,
  N = N_all,
  t = t_all,
  x = x_all
)

stan_model <- cmdstan_model(write_stan_file(stan_code))

fit <- stan_model$sample(
  data = stan_data,
  iter_warmup = 1000,
  iter_sampling = 4000,
  chains = 4,
  parallel_chains = 4,
  refresh = 0
)

fit$summary(variables = "beta")
```

Two things to note about this model. First, it appears that it worked! The estimates mirror the estimates from the `coxph` model using the `survival` package. Second, the implementation is very inefficient, taking more than a minute to run! This does not bode well for a more complex model that incorporates random effects and splines.

### Final Bayes model

I asked ChatGPT this time to see if it could make my code more efficient. (I've been comparing ChatGPT and DeepSeek - both have been pretty impressive.)  It recognized that my initial brute force approach was calculating each denominator anew for each observed evaluation. This is highly inefficient (on the order of $O(N^2)$). The algorithm is reconfigured so that the denominators are pre-calculated - starting with the last time point (censored or observed), similar to the first approach. It turns out this is much more efficient, $O(N)$.

```{r, eval=FALSE}
stan_code <-
"
...

model {
  
  // Prior
  
  beta ~ normal(0, 4);
  
    // Likelihood
  
  vector[N] theta = x * beta;
  vector[N] log_sum_exp_theta;
  
  // Compute cumulative sum of exp(theta) in log space
  
  log_sum_exp_theta[N] = theta[N]; // Initialize the last element
  
  for (i in tail(sort_indices_desc(t), N-1)) {
    log_sum_exp_theta[i] = log_sum_exp(theta[i], log_sum_exp_theta[i + 1]);
  }

  for (n_o in 1:N_o) {
    int start_risk = binary_search(t, t_o[n_o]); // Use binary search
    real log_denom = log_sum_exp_theta[start_risk];
    target += theta[start_risk] - log_denom;
  }
}
"
```

```{r, echo = FALSE}
stan_code <-
"
functions {
  int binary_search(vector v, real tar_val) {
    int low = 1;
    int high = num_elements(v);
    int result = -1;

    while (low <= high) {
      int mid = (low + high) %/% 2;
      if (v[mid] == tar_val) {
        result = mid; // Store the index
        high = mid - 1; // Look for earlier occurrences
      } else if (v[mid] < tar_val) {
        low = mid + 1;
      } else {
        high = mid - 1;
      }
    }
    return result;
  }
}

data {
  int<lower=0> K;          // Number of covariates

  int<lower=0> N_o;        // Number of uncensored observations
  vector[N_o] t_o;         // Event times (sorted in decreasing order)
  matrix[N_o, K] x_o;      // Covariates for uncensored observations

  int<lower=0> N;          // Number of total observations
  vector[N] t;             // Individual times (sorted in decreasing order)
  matrix[N, K] x;          // Covariates for all observations
}

parameters {
  vector[K] beta;          // Fixed effects for covariates
}

model {
  
  // Prior
  
  beta ~ normal(0, 4);
  
    // Likelihood
  
  vector[N] theta = x * beta;
  vector[N] log_sum_exp_theta;
  
  // Compute cumulative sum of exp(theta) in log space
  
  log_sum_exp_theta[N] = theta[N]; // Initialize the last element
  
  for (i in tail(sort_indices_desc(t), N-1)) {
    log_sum_exp_theta[i] = log_sum_exp(theta[i], log_sum_exp_theta[i + 1]);
  }

  for (n_o in 1:N_o) {
    int start_risk = binary_search(t, t_o[n_o]); // Use binary search
    real log_denom = log_sum_exp_theta[start_risk];
    target += theta[start_risk] - log_denom;
  }
}
"
```

The data requirements for this are the as the second model, so no changes are needed.

```{r}
stan_model <- cmdstan_model(write_stan_file(stan_code))

fit <- stan_model$sample(
  data = stan_data,
  iter_warmup = 1000,
  iter_sampling = 4000,
  chains = 4,
  parallel_chains = 4,
  refresh = 0
)

fit$summary(variables = "beta")
```

The model still works, as the estimate is the same as the previous (correct) model. And the computation time is reduced considerably, to about 3 seconds. This gives me hope for a future, more complex model.