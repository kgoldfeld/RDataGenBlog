---
title: 'simstudy enhancement: specifying idiosyncratic follow-up times for longitudinal
  data'
author: Package Build
date: '2024-04-16'
slug: []
categories: []
tags:
  - R
  - Longitudinal data
type: ''
subtitle: ''
image: ''
draft: true
---

A researcher reached out to me a few weeks ago. They were trying to generate longitudinal data that included irregularly spaced follow-up periods. The default periods generated by the function `addPeriods` in the `simstudy` package are $\{0, 1, 2, ..., n - 1\}$, where there are $n$ total periods. However, when follow-up periods required more specificity, such as $\{0, 90, 180, 365\}$ days from baseline, users had to manually add them. Originally, I had intended to incorporate this feature into the function, but unfortunately it slipped through the cracks. Thanks to the clear motivation provided by the researcher, I've implemented this enhancement. Users can now replace the default vector with their desired set of follow-up periods using the new argument *periodVec*. This addition is available in the development version of `simstudy` on GitHub.

The first example simply creates an outcome $Y$ that is a function of the day of follow-up:

```{r}
library(simstudy)
set.seed(123)

def <- defDataAdd(varname = "Y", formula = "100 + 0.25 * day", variance = 400)

dd <- genData(3)
dp <- addPeriods(dd, nPeriods = 4, perName = "day", periodVec = c(0, 90, 180, 365))
dp <- addColumns(def, dp)
```

Here is the resulting data set:

```{r, echo=FALSE}
dp
```

```{r, echo=FALSE, fig.width = 7, fig.height = 4}
library(ggplot2)
ggplot(data = dp, aes(x=day, y = Y, group = id)) +
  geom_line(aes(color = factor(id))) +
  geom_point(size = 1.25, aes(color = factor(id))) +
  theme(panel.grid = element_blank(),
        legend.position = "none") +
  scale_x_continuous(breaks = c(0, 90, 180, 365))
```

The second example transforms data in "wide" format to "long" format. Here is the wide data generation:

```{r}
tdef <- 
  defData(varname = "Y0", dist = "normal", formula = 10, variance = 1) |>
  defData(varname = "Y1", dist = "normal", formula = "Y0 + 5", variance = 1) |>
  defData(varname = "Y2", dist = "normal", formula = "Y0 + 10", variance = 1)

dd <- genData(3, tdef)
```

```{r, echo = FALSE}
dd
```

And here is the transformation, with the time periods:

```{r}
dp <- addPeriods(
  dd, 
  perName = "day", 
  timevars = paste0("Y", 0:2),
  timevarName = "Y",
  periodVec = c(0, 180, 365)
)
```

```{r, echo=FALSE}
dp
```

As a little bonus, here is some simple code to introduce a little more reality into the data generation process. In this case, not all the follow-up measurements would be collected on the exact follow-up (although all the baseline measurements would be made on day zero). About 60\% of the cases would be collected *after* the scheduled time (never before). I've implemented this logic (without any outcome data) in the `defl` data definition.

```{r}
defl <- 
  defDataAdd(varname = "lagdays", formula = 10, dist = "noZeroPoisson") |>
  defDataAdd(varname = "lag", formula = "0 | .4 + lagdays | .6", dist = "mixture") |>
  defDataAdd(varname = "obs_day", formula = "(day > 0) * (day + lag)")

dd <- genData(3)
dp <- addPeriods(dd, 3, perName = "day", periodVec = c(0, 180, 365))
dp <- addColumns(defl, dp)
```

```{r, echo=FALSE}
dp
```

And if anyone has other suggestions, feel free to reach out to me directly or start a conversation by creating an issue in GitHub.

