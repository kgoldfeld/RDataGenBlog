---
title: 'simstudy enhancement: specifying idiosyncratic follow-up times for longitudinal
  data'
author: Package Build
date: '2024-04-16'
slug: []
categories: []
tags:
  - R
  - Longitudinal data
type: ''
subtitle: ''
image: ''
draft: true
---

A researcher reached out to me a few weeks ago. They were trying to generate longitudinal data that included irregularly spaced follow-up periods. The default periods generated by the function `addPeriods` in the `simstudy` package are $\{0, 1, 2, ..., n - 1\}$, where there are $n$ total periods. However, when follow-up periods required more specificity, such as $\{0, 90, 180, 365\}$ days from baseline, users had to manually add them. Originally, I had intended to incorporate this feature into the function, but unfortunately it slipped through the cracks. Thanks to the clear motivation provided by the researcher, I've implemented this enhancement. Users can now replace the default vector with their desired set of follow-up periods using the new argument *periodVec*. This addition is available in the development version of `simstudy` on GitHub.

Just as a quick introduction, here is a simple example that shows the default settings of `addPeriods`. We are generating three individuals that will have measurements at four different periods, generically identified as $\{0, 1, 2, 3\}$:

```{r}
library(simstudy)
set.seed(123)

dd <- genData(3)
dp <- addPeriods(dd, nPeriods = 4)
```

```{r, echo = FALSE}
dp
```

In this next example, we still assume four measurement periods, but they will be at baseline, 90 days, 180 days, and 1 year. The outcome $Y$ that is a function of the day of follow-up:

```{r}
def <- defDataAdd(varname = "Y", formula = "100 + 0.25 * day", variance = 400)

dd <- genData(3)
dp <- addPeriods(dd, nPeriods = 4, perName = "day", periodVec = c(0, 90, 180, 365))
dp <- addColumns(def, dp)
```

Here is the resulting data set:

```{r, echo=FALSE}
dp
```

```{r, echo=FALSE, fig.width = 7, fig.height = 4}
library(ggplot2)
ggplot(data = dp, aes(x=day, y = Y, group = id)) +
  geom_line(aes(color = factor(id))) +
  geom_point(size = 1.25, aes(color = factor(id))) +
  theme(panel.grid = element_blank(),
        legend.position = "none") +
  scale_x_continuous(breaks = c(0, 90, 180, 365))
```

The second example transforms data in "wide" format to "long" format. Here is the wide data generation:

```{r}
tdef <- 
  defData(varname = "Y0", dist = "normal", formula = 10, variance = 1) |>
  defData(varname = "Y1", dist = "normal", formula = "Y0 + 5", variance = 1) |>
  defData(varname = "Y2", dist = "normal", formula = "Y0 + 10", variance = 1)

dd <- genData(3, tdef)
```

```{r, echo = FALSE}
dd
```

And here is the transformation, with the time periods:

```{r}
dp <- addPeriods(
  dd, 
  perName = "day", 
  timevars = paste0("Y", 0:2),
  timevarName = "Y",
  periodVec = c(0, 180, 365)
)
```

```{r, echo=FALSE}
dp
```

As a little bonus, here is additional code to introduce a little more reality into the data generation process. In this case, not all the follow-up measurements would be collected precisely on the exact follow-up date (although all the baseline measurements would be made on day zero). In particular, we are assuming that about 60\% of the cases would be collected *after* the scheduled time (never before). I've implemented this logic by creating a *lag* variable in the data definition:

```{r}
deflag <- 
  defDataAdd(varname = "lagdays", formula = 10, dist = "noZeroPoisson") |>
  defDataAdd(varname = "lag", formula = "0 | .4 + lagdays | .6", dist = "mixture") |>
  defDataAdd(varname = "obs_day", formula = "(day > 0) * (day + lag)")

dd <- genData(3)
dp <- addPeriods(dd, 3, perName = "day", periodVec = c(0, 180, 365))
dp <- addColumns(deflag, dp)
```

```{r, echo=FALSE}
dp
```

Since `addPeriods` is a work in progress, feel free to reach out to me with suggestions, either directly or by creating an issue in GitHub.

