---
title: Sample size requirements for a Bayesian factorial study design
author: Package Build
date: '2021-10-26'
slug: []
categories: []
tags:
  - R
  - Bayesian model
  - Stan
type: ''
subtitle: ''
image: ''
---

<script src="{{< blogdown/postref >}}index.en_files/header-attrs/header-attrs.js"></script>


<p>How do you determine sample size when the goal of a study is not to conduct a null hypothesis test but to provide an estimate of multiple effect sizes? I needed to get a handle on this for a recent grant submission, which I’ve been writing about over the past month, <a href="https://www.rdatagen.net/post/2021-09-28-analyzing-a-factorial-trial-with-a-bayesian-model/" target="_blank">here</a> and <a href="https://www.rdatagen.net/post/2021-10-12-analyzing-a-factorial-design-with-a-bayesian-shrinkage-model/" target="_blank">here</a>. (I provide a little more context for all of this in those earlier posts.) The statistical inference in the study will be based on the estimated posterior distributions from a Bayesian model, so it seems like we’d like those distributions to be as informative as possible. We need to set the sample size large enough to reduce the dispersion of those distributions to a helpful level.</p>
<p>Once I determined that I wanted to target the variance of the posterior distributions, it was just a matter of figuring out what that target should be and then simulate data to see what sample sizes could give us that target. I used the expected standard deviation (<span class="math inline">\(\sigma\)</span>) as the criterion for sample size selection.</p>
<div id="setting-the-target" class="section level3">
<h3>Setting the target</h3>
<p>To determine the target level of precision, I assessed the width of the posterior distributions under different standard deviations. In particular, I identified the posterior probabilities with a mean OR = 1.25 <span class="math inline">\((log(OR) = 0.22)\)</span> where <span class="math inline">\(P(log(OR) &gt; 0) \ge 0.95\)</span>. The target OR is somewhat arbitrary, but seemed like a meaningful effect size based on discussions with my collaborators.</p>
<p>I did a quick search for the standard deviation that would yield a 95% threshold at or very close to 0. That is, 95% of the distribution should lie to the right of 0. Assuming that the target posterior distribution will be approximately <em>normal</em> with a mean of 0.22, I used the <code>qnorm</code> function to find the 95% thresholds for range of standard deviations between 0.10 and 0.15.</p>
<pre class="r"><code>sd &lt;- seq(.15, .10, by = -0.005)
cbind(sd, threshold = round(qnorm(.05, .22 , sd = sd), 3))</code></pre>
<pre><code>##          sd threshold
##  [1,] 0.150    -0.027
##  [2,] 0.145    -0.019
##  [3,] 0.140    -0.010
##  [4,] 0.135    -0.002
##  [5,] 0.130     0.006
##  [6,] 0.125     0.014
##  [7,] 0.120     0.023
##  [8,] 0.115     0.031
##  [9,] 0.110     0.039
## [10,] 0.105     0.047
## [11,] 0.100     0.056</code></pre>
<p>It looks like the target standard deviation should be close to 0.135, which is also apparent from the plot of the 95% intervals centered at 0.22:</p>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-3-1.png" width="432" /></p>
</div>
<div id="using-simulation-to-establish-sample-size" class="section level3">
<h3>Using simulation to establish sample size</h3>
<p>The final step was to repeatedly simulate data sets using different sample size assumptions, fitting models, and estimating the posterior distribution standard deviations for associated with each data set (and sample size). I evaluated sample sizes ranging from 400 to 650 individuals, increasing in increments of 50. For each sample size, I generated 250 data sets, for a total of 1,500 data sets and model estimates. Given that each model estimation is quite resource intensive, I generated all the data and estimated the models using a high performance computing environment that provided me with 90 nodes and 4 processors on each node so that the Bayesian MCMC process could all run in parallel - so parallelization of parallel processes. In total, this took about 2 hours to run.</p>
<p>(I am including the code in the <a href="#addendum">addendum</a> below. The structure is similar to what I have <a href="https://www.rdatagen.net/post/a-frequentist-bayesian-exploring-frequentist-properties-of-bayesian-models/" target="_blank">described</a> in the past on how one might do these types of explorations with simulated data and Bayesian modelling.)</p>
<p>Below is the output for a single data set to provide an example of the data being generated by the simulations. We have estimated seven log-odds ratios (see <a href="" target="_blank">here</a> for an explanation of why there are seven), and the simulation returns a summary of the posterior distribution for each: selected quantiles and the standard deviation.</p>
<pre><code>##      n    var p0.025 p0.25  p0.5 p0.75 p0.975    sd
## 1: 650 lOR[1]  0.113 0.269 0.354 0.441  0.603 0.126
## 2: 650 lOR[2]  0.410 0.569 0.652 0.735  0.892 0.123
## 3: 650 lOR[3]  0.427 0.585 0.667 0.752  0.906 0.123
## 4: 650 lOR[4]  0.367 0.526 0.608 0.691  0.851 0.122
## 5: 650 lOR[5]  0.436 0.592 0.675 0.757  0.913 0.122
## 6: 650 lOR[6]  0.703 0.861 0.945 1.028  1.180 0.122
## 7: 650 lOR[7]  0.722 0.886 0.969 1.054  1.214 0.125</code></pre>
<p>The plot below shows the estimated standard deviations for a single log-odds ratio (in this case <span class="math inline">\(\lambda_4\)</span>), with a point for each of the 1,500 simulate data sets. At 550 subjects, the mean standard deviation (represented by the curve) is starting to get close to 0.135, but there is still quite a bit of uncertainty. To be safe, we might want to set the upper limit for the study to be 600 patients, because we are quite confident that the standard deviation will be low enough to meet our criteria (almost 90% of the standard deviations from the simulations were below 0.135, though at 650 patients that proportion was over 98%).</p>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-5-1.png" width="480" /></p>
<p><a name="addendum"></a></p>
</div>
<div id="addendum" class="section level3">
<h3>Addendum</h3>
<p>This code generates repeated data sets under different sample size assumptions and draws samples from the posterior distribution for each of those data sets. The simulations are set up to run on a high performance computing (HPC) environment, so multiple data sets can be generated and analyzed simultaneously. If you do not have access to and HPC, you can run locally using <code>lapply</code> or <code>mclapply</code> rather than <code>Slurm_lapply</code>, but unless you have an extremely powerful desktop or laptop, expect these kinds of simulations to take days rather than hours.</p>
<p>One particularly interesting feature of the data generation process used in these simulations is that the effect size parameters are not considered to be fixed, but are themselves drawn from a distribution of parameters. Given that we are never certain about what the parameters should be in the data generation process, this adds an appropriate level of uncertainty that gets reflected in our target estimates. If we are slightly conservative in our sample size selection, this will take into account this additional uncertainty. Of course, how much uncertainty will depend on the situation.</p>
<pre class="r"><code>library(cmdstanr)
library(simstudy)
library(data.table)
library(posterior)
library(slurmR)
library(glue)

s_define &lt;- function() {
  
  f &lt;- &quot;..t_0 + ..t_a*a + ..t_b*b + ..t_c*c + 
      ..t_ab*a*b + ..t_ac*a*c + ..t_bc*b*c + ..t_abc*a*b*c&quot;
  
  defY &lt;- defDataAdd(varname = &quot;y&quot;, formula = f, dist = &quot;binary&quot;, link=&quot;logit&quot;)
  
  return(list(defY = defY)) 
  
}

s_generate &lt;- function(list_of_defs, argsvec) {
  
  list2env(list_of_defs, envir = environment())
  list2env(as.list(argsvec), envir = environment())
  
  # introducing uncertainty into the data generation process
  
  t_0 &lt;- mu_int
  t_a &lt;- rnorm(1, mu_a, .10)
  t_b &lt;- rnorm(1, mu_b, .10)
  t_c &lt;- rnorm(1, mu_c, .10)
  t_ab &lt;- rnorm(1, mu_ab, .10)
  t_ac &lt;- rnorm(1, mu_ac, .10)
  t_bc &lt;- rnorm(1, mu_bc, .10)
  t_abc &lt;- mu_abc
  
  dd &lt;- genData(8 * n)
  dd &lt;- addMultiFac(dd, nFactors = 3, colNames = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))
  dd &lt;- addColumns(defY, dd)
  
  return(dd)
  
}

s_model &lt;- function(generated_data, mod) {
  
  dt_to_list &lt;- function(dx) {
    
    N &lt;- nrow(dx)                               
    x_abc &lt;- model.matrix(~a*b*c, data = dx)
    y &lt;- dx[, y]
    
    list(N = N, x_abc = x_abc, y = y)
  }
  
  fit &lt;- mod$sample(
    data = dt_to_list(generated_data),
    refresh = 0,
    chains = 4L,
    parallel_chains = 4L,
    iter_warmup = 500,
    iter_sampling = 2500,
    adapt_delta = 0.98,
    max_treedepth = 20,
    show_messages = FALSE
  )
  
  posterior &lt;- data.frame(as_draws_rvars(fit$draws(variables = &quot;lOR&quot;)))
  
  pcts &lt;- c(.025, 0.25, .50, 0.75, .975)
  sumstats &lt;- data.table(t(quantile(posterior$lOR, pcts)))
  setnames(sumstats, glue(&quot;p{pcts}&quot;))
  sumstats$sd &lt;- sd(posterior$lOR)
  sumstats$var &lt;- glue(&quot;lOR[{1:7}]&quot;) 
  
  return(sumstats) # model_results is a data.table
  
}

s_replicate &lt;- function(argsvec, mod) {
  
  set_cmdstan_path(path = &quot;/gpfs/.../cmdstan/2.25.0&quot;)
  
  list_of_defs &lt;- s_define()
  generated_data &lt;- s_generate(list_of_defs, argsvec)
  model_results &lt;- s_model(generated_data, mod)
  
  #--- summary statistics ---#
  
  summary_stats &lt;- data.table(t(argsvec), model_results)
  
  return(summary_stats) # summary_stats is a data.table
}

#--- Set arguments ---#

scenario_list &lt;- function(...) {
  argmat &lt;- expand.grid(...)
  return(asplit(argmat, MARGIN = 1))
}

n &lt;- c(400, 450, 500, 550, 600, 650)

mu_int &lt;- -1.4
mu_m &lt;- 0.5
mu_x &lt;- -0.3
mu_abc &lt;- 0.3

scenarios &lt;- scenario_list(n = n,
  mu_int = mu_int, mu_a = mu_m, mu_b = mu_m, mu_c = mu_m, 
  mu_ab = mu_x, mu_ac = mu_x, mu_bc = mu_x, mu_abc = mu_abc)

scenarios &lt;- rep(scenarios, each = 250)

#--- run on HPC ---#

set_cmdstan_path(path = &quot;/gpfs/.../cmdstan/2.25.0&quot;)
smodel &lt;- cmdstan_model(&quot;/gpfs/.../model_ind.stan&quot;)

job &lt;- Slurm_lapply(
  X = scenarios, 
  FUN = s_replicate, 
  mod = smodel,
  njobs = min(90L, length(scenarios)), 
  mc.cores = 4L,
  job_name = &quot;i_ss&quot;,
  tmp_path = &quot;/gpfs/.../scratch&quot;,
  plan = &quot;wait&quot;,
  sbatch_opt = list(time = &quot;12:00:00&quot;, partition = &quot;cpu_short&quot;, `mem-per-cpu` = &quot;4G&quot;),
  export = c(&quot;s_define&quot;, &quot;s_generate&quot;, &quot;s_model&quot;),
  overwrite = TRUE
)

res &lt;- Slurm_collect(job)

save(res, file = &quot;/gpfs/.../post_ss.rda&quot;)</code></pre>
</div>
