---
title: Generating clustered data with marginal correlations - highlighting two simstudy updates
author: Package Build
date: '2022-11-29'
slug: []
categories: []
tags:
  - R
type: ''
subtitle: ''
image: ''
draft: TRUE
---



<p>A student is working on a project to derive an analytic solution to the problem of sample size determination in the context of cluster randomized trials and repeated individual-level measurement (something I’ve <a href="https://www.rdatagen.net/post/2021-11-23-design-effects-with-baseline-measurements/" target="_blank">thought</a> a little bit about before). Though the goal is an analytic solution, we do want confirmation with simulation. So, I was a little disheartened to discover that the routines I’d developed for this sort of data generation were not quite up to the task. I’ve had to quickly fix that, and the updates are available in the development version of <code>simstudy</code>, which can be downloaded using <em>devtools::install_github(“kgoldfeld/simstudy”)</em>. While some of the changes are under the hood, I have added a new function, <code>genMatBlock</code>, which I’ll describe here and show some examples.</p>
<div id="correlation-in-cluster-randomized-trials" class="section level3">
<h3>Correlation in cluster randomized trials</h3>
<p>The fundamental issue with cluster randomized trials is that the outcomes for a group of patients in a specific cluster are going to be correlated, which impacts both how much we “learn” from each individual and estimate of uncertainty (i.e., standard errors). The more highly correlated individuals are, the less we learn from each individual. (In the extreme case, if there is perfect correlation, we really only have a sample of one from each group.) That correlation structure can depend on whether outcomes generally vary over time (so that patient outcomes within a cluster close to time might be more correlated than outcomes collect from patients far apart in time) and whether measurements are collected for the same individuals over time (you might expect the measurements of the same individual to be more highly correlated than measurements of two different individuals). The assumed correlation structure needs to reflect all of these design issues.</p>
<p>In simulating data from a cluster randomized trial, have at least two options. The first is to use random effects to induce correlation. A simple data generating process for a binary outcome with a treatment indicator and one covariate that would result in within-cluster correlation would start with a formulation like this:</p>
<p><span class="math display">\[ P(Y_{ij} = 1) = \pi_{ij}, \ \ \ Y_{ij} \in \{0,1\}\]</span>
<span class="math display">\[
log \left( \frac{\pi_{ij}}{1-p{ij}} \right) = \beta_0 + \beta_1 A_j + \beta_2X_i + b_j
\]</span></p>
<p>where <span class="math inline">\(Y_{ij}\)</span> is the outcome for individual <span class="math inline">\(i\)</span> in cluster <span class="math inline">\(j\)</span>. (<span class="math inline">\(A\)</span> is a treatment indicator and <span class="math inline">\(X\)</span> is a covariate.) The key here is <span class="math inline">\(b_j\)</span>, which is a cluster level effect that is typically assumed to have a normal distribution N(0, <span class="math inline">\(\sigma_b^2)\)</span>. In the simulation, we would use use values to generate a probability <span class="math inline">\(\pi_{ij}\)</span> for each, and each of those <span class="math inline">\(\pi_{ij}\)</span>’s within a cluster would be correlated by the presence of the cluster effect <span class="math inline">\(b_j\)</span>. It would follow that the <span class="math inline">\(Y_{ij}\)</span>’s would also be correlated within cluster <span class="math inline">\(j\)</span>. We can call this the <em>conditional</em> data generation process, and we could use a mixed-effects regression model to recover the parameters.</p>
<p>Alternatively, we can dispose of <span class="math inline">\(b_j\)</span>, like this:</p>
<p><span class="math display">\[
log \left( \frac{\pi_{ij}}{1-p{ij}} \right) = \beta_0 + \beta_1 A_j + \beta_2X_i
\]</span></p>
<p>As before, we would generate the <span class="math inline">\(\pi_{ij}\)</span>’s, but those probabilities would be uncorrelated now (except of course the correlation due to randomization assignment, but this would be across cluster boundaries). We would introduce within-cluster correlation directly into the <span class="math inline">\(Y_{ij}\)</span>’s by using using multivariate data generation process. If we were in the realm of normally distributed outcomes, we would use a multivariate normal data generating process <span class="math inline">\(MVN(\mathbf{\mu}, \Sigma)\)</span>, where <span class="math inline">\(\Sigma\)</span> is a covariance matrix. (This could be done in <code>simstudy</code> using <code>genCorData</code> or <code>addCorData</code>.) In this case, with a binary outcome, we need an analogous approach. This is what is implemented in the <code>simstudy</code> functions <code>genCorGen</code> and <code>addCorGen</code>.</p>
</div>
<div id="the-correlation-structure" class="section level3">
<h3>The correlation structure</h3>
<p>OK - that is a bit more background than I intended (though probably not enough). Now onto the functions and simulations.</p>
<p>Ultimately, we might be interested in using <code>addCorGen</code> to generate data with a somewhat complex correlation structure. In the first example, we have a scenario with multiple measurement periods though an individual is measured only once.</p>
<pre class="r"><code>library(simstudy)
library(data.table)</code></pre>
<div id="multiple-time-periods-single-individual-measurement" class="section level4">
<h4>Multiple time periods, single individual measurement</h4>
<pre class="r"><code>b0 &lt;- -1.0; delta &lt;- 1; number_inds = 3;

###

defC &lt;- defData(varname = &quot;A&quot;, formula = &quot;1;1&quot;, dist = &quot;trtAssign&quot;)

defI &lt;- defDataAdd(varname = &quot;z&quot;, formula = 0, variance = 0.10)
defI &lt;- defDataAdd(defI, varname = &quot;p&quot;,
                   formula = &quot;..b0 + ..delta * A + .5*z&quot;,
                   dist = &quot;nonrandom&quot;, link = &quot;logit&quot;)

###

target_cor &lt;- genBlockMat(rho = c(0.3, 0.2, 0.1), nInds = number_inds, nPeriods = 3)
target_cor</code></pre>
<pre><code>##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]
##  [1,]  1.0  0.3  0.3  0.2  0.2  0.2  0.1  0.1  0.1
##  [2,]  0.3  1.0  0.3  0.2  0.2  0.2  0.1  0.1  0.1
##  [3,]  0.3  0.3  1.0  0.2  0.2  0.2  0.1  0.1  0.1
##  [4,]  0.2  0.2  0.2  1.0  0.3  0.3  0.2  0.2  0.2
##  [5,]  0.2  0.2  0.2  0.3  1.0  0.3  0.2  0.2  0.2
##  [6,]  0.2  0.2  0.2  0.3  0.3  1.0  0.2  0.2  0.2
##  [7,]  0.1  0.1  0.1  0.2  0.2  0.2  1.0  0.3  0.3
##  [8,]  0.1  0.1  0.1  0.2  0.2  0.2  0.3  1.0  0.3
##  [9,]  0.1  0.1  0.1  0.2  0.2  0.2  0.3  0.3  1.0</code></pre>
<pre class="r"><code>###

set.seed(1234)

dc &lt;- genData(n = 10, dtDefs = defC, id = &quot;site&quot;)
dc &lt;- addPeriods(dtName = dc, nPeriods = number_inds, 
        idvars = &quot;site&quot;, perName = &quot;period&quot;)
dd &lt;- genCluster(dtClust = dc, cLevelVar = &quot;timeID&quot;, 
        numIndsVar = 3, level1ID = &quot;idnum&quot;)
dd &lt;- addColumns(defI, dd)

setkey(dd, &quot;site&quot;, &quot;period&quot;,&quot;idnum&quot;)

genCorDT &lt;- function(dx) {
  
  addCorGen(dx, idvar = &quot;site&quot;, corMatrix = target_cor,
      dist = &quot;binary&quot;, param1 = &quot;p&quot;, cnames = &quot;y&quot;, method = &quot;ep&quot;)
}

dres &lt;- genCorDT(dd)
head(dres, n = 9)</code></pre>
<pre><code>##    site period A timeID idnum          z         p y
## 1:    1      0 1      1     1  0.3109796 0.5387943 0
## 2:    1      0 1      1     2 -0.1968381 0.4754151 1
## 3:    1      0 1      1     3 -0.2313320 0.4711157 0
## 4:    1      1 1      2     4 -0.1633853 0.4795882 1
## 5:    1      1 1      2     5 -0.5536305 0.4312347 1
## 6:    1      1 1      2     6  0.2783134 0.5347331 1
## 7:    1      2 1      3     7  0.4332353 0.5539436 1
## 8:    1      2 1      3     8 -0.5335796 0.4336954 0
## 9:    1      2 1      3     9 -0.1984128 0.4752187 1</code></pre>
<pre class="r"><code>reps &lt;- lapply(1:2500, function(x) genCorDT(dd))

empir &lt;- function(s) {
  drep &lt;- data.table::rbindlist(reps, idcol = &quot;rep&quot;)
  drep &lt;- drep[site == s, ]
  drep[, seq := 1:.N, keyby = rep]
  dmat &lt;- as.matrix(dcast(drep, rep ~ seq, value.var = &quot;y&quot;)[, -1])
  
  mu &lt;- cbind(round(apply(dmat, 2, mean), 2), round(dd[site == s, p], 2))
  S &lt;- round(cor(dmat), 1) 
  
  return(list(mu = mu, S = S))
}

empir(s=7)</code></pre>
<pre><code>## $mu
##   [,1] [,2]
## 1 0.33 0.32
## 2 0.25 0.25
## 3 0.28 0.27
## 4 0.26 0.25
## 5 0.27 0.28
## 6 0.26 0.26
## 7 0.26 0.27
## 8 0.28 0.28
## 9 0.31 0.31
## 
## $S
##     1   2   3   4   5   6   7   8   9
## 1 1.0 0.3 0.3 0.2 0.2 0.2 0.1 0.1 0.1
## 2 0.3 1.0 0.3 0.2 0.2 0.2 0.1 0.1 0.1
## 3 0.3 0.3 1.0 0.2 0.2 0.2 0.1 0.1 0.1
## 4 0.2 0.2 0.2 1.0 0.3 0.3 0.2 0.2 0.2
## 5 0.2 0.2 0.2 0.3 1.0 0.3 0.2 0.2 0.2
## 6 0.2 0.2 0.2 0.3 0.3 1.0 0.2 0.2 0.2
## 7 0.1 0.1 0.1 0.2 0.2 0.2 1.0 0.3 0.3
## 8 0.1 0.1 0.1 0.2 0.2 0.2 0.3 1.0 0.3
## 9 0.1 0.1 0.1 0.2 0.2 0.2 0.3 0.3 1.0</code></pre>
</div>
</div>
<div id="multiple-time-periods-repeated-individual-measurements" class="section level3">
<h3>Multiple time periods, repeated individual measurements</h3>
<pre class="r"><code>b0 &lt;- -1.0; b1 &lt;- .5; delta &lt;- -0.3; number_inds = 3;

###

defC &lt;- defData(varname = &quot;A&quot;, formula = &quot;1;1&quot;, dist = &quot;trtAssign&quot;)

defI &lt;- defDataAdd(varname = &quot;z&quot;, formula = 0, variance = 0.10)
defI &lt;- defDataAdd(defI, varname = &quot;p&quot;,
                   formula = &quot;..b0 + ..b1* measure + ..delta * A * measure + z&quot;,
                   dist = &quot;nonrandom&quot;, link = &quot;logit&quot;)
###

target_cor &lt;- genBlockMat(rho = c(0.3, .1), nInds = number_inds, nPeriods = 2, iRho = 0.5)
target_cor</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6]
## [1,]  1.0  0.3  0.3  0.5  0.1  0.1
## [2,]  0.3  1.0  0.3  0.1  0.5  0.1
## [3,]  0.3  0.3  1.0  0.1  0.1  0.5
## [4,]  0.5  0.1  0.1  1.0  0.3  0.3
## [5,]  0.1  0.5  0.1  0.3  1.0  0.3
## [6,]  0.1  0.1  0.5  0.3  0.3  1.0</code></pre>
<pre class="r"><code>###

set.seed(1234)

dc &lt;- genData(n = 10, dtDefs = defC, id = &quot;site&quot;)
dc &lt;- genCluster(dtClust = dc, cLevelVar = &quot;site&quot;, 
        numIndsVar = number_inds, level1ID = &quot;idnum&quot;)
dd &lt;- addPeriods(dtName = dc, nPeriods = 2, idvars = &quot;idnum&quot;, perName = &quot;measure&quot;)
dd &lt;- addColumns(defI, dd)

setkey(dd, &quot;site&quot;, &quot;measure&quot;, &quot;idnum&quot;)

dres &lt;- genCorDT(dd)

head(dres, n = 6)</code></pre>
<pre><code>##    idnum measure site A timeID          z         p y
## 1:     1       0    1 1      1  0.3109796 0.3342510 0
## 2:     2       0    1 1      3 -0.2313320 0.2259484 0
## 3:     3       0    1 1      5 -0.5536305 0.1745625 1
## 4:     1       1    1 1      2 -0.1968381 0.2695635 0
## 5:     2       1    1 1      4 -0.1633853 0.2762009 0
## 6:     3       1    1 1      6  0.2783134 0.3724579 0</code></pre>
<pre class="r"><code>###

reps &lt;- lapply(1:2500, function(x) genCorDT(dd))

empir(s = 2)</code></pre>
<pre><code>## $mu
##   [,1] [,2]
## 1 0.36 0.36
## 2 0.23 0.23
## 3 0.30 0.31
## 4 0.21 0.21
## 5 0.31 0.31
## 6 0.27 0.27
## 
## $S
##     1   2   3   4   5   6
## 1 1.0 0.3 0.3 0.5 0.1 0.1
## 2 0.3 1.0 0.3 0.1 0.5 0.1
## 3 0.3 0.3 1.0 0.1 0.1 0.5
## 4 0.5 0.1 0.1 1.0 0.3 0.3
## 5 0.1 0.5 0.1 0.3 1.0 0.3
## 6 0.1 0.1 0.5 0.3 0.3 1.0</code></pre>
</div>
