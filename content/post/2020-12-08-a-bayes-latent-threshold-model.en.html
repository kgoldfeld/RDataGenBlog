---
title: A Bayesian adaptation of a latent threshold model
author: Keith Goldfeld
date: '2020-12-08'
slug: a-latent-threshold-model-to-estimate-treatment-effects
categories: []
tags:
  - R
  - Bayesian model
  - Stan
type: ''
subtitle: ''
image: ''
output:
  blogdown::html_page:
    anchor_sections: no
draft: yes
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<pre class="r"><code>library(simstudy)
library(rstan)
library(bayesplot)
library(Rmpfr)

# Generate simulated data

s_define &lt;- function() {
  
  d0 &lt;- defData(varname = &quot;a&quot;, formula = 0, variance = 2.2^2, id = &quot;study&quot;)
  d0 &lt;- defData(d0, varname = &quot;bio&quot;, formula = &quot;.3;.4;.3&quot;, dist = &quot;categorical&quot;)
  
  dg &lt;- defDataAdd(varname = &quot;V1&quot;, formula = 5, variance = 1, dist = &quot;gamma&quot;)
  dg &lt;- defDataAdd(dg, varname = &quot;V2&quot;, formula = 6, variance = 2, dist = &quot;gamma&quot;)
  dg &lt;- defDataAdd(dg, varname = &quot;V3&quot;, formula = 4, variance = 2, dist = &quot;gamma&quot;)
  
  dc1 &lt;- defCondition(condition = &quot;bio == 1&quot;, formula = &quot;rx * (V1 + 5)&quot;, 
    dist = &quot;nonrandom&quot;)
  dc1 &lt;- defCondition(dc1, condition = &quot;bio == 2&quot;, formula = &quot;rx * (V2 + 5)&quot;, 
    dist = &quot;nonrandom&quot;)
  dc1 &lt;- defCondition(dc1, condition = &quot;bio == 3&quot;, formula = &quot;rx * (V3 + 5)&quot;, 
    dist = &quot;nonrandom&quot;)
  
  dc2 &lt;- defCondition(condition = &quot;bio == 1&quot;, 
    formula = &quot;rx*( -3 + 6 * (obs_V &gt; 10)) + (1-rx)*(-9999)&quot;, 
    dist = &quot;binary&quot;, link = &quot;logit&quot;)
  dc2 &lt;- defCondition(dc2, condition = &quot;bio == 2&quot;, 
    formula = &quot;rx*( -2.5 + 5 * (obs_V &gt; 15)) + (1-rx)*(-9999)&quot;, 
    dist = &quot;binary&quot;, link = &quot;logit&quot;)
  dc2 &lt;- defCondition(dc2, condition = &quot;bio == 3&quot;, 
    formula = &quot;rx*( -4 + 8 * (obs_V &gt; 12)) + (1-rx)*(-9999)&quot;, 
    dist = &quot;binary&quot;, link = &quot;logit&quot;)
  
  d2 &lt;- defDataAdd(varname = &quot;g&quot;, formula = 0, variance = 1)
  d2 &lt;- defDataAdd(d2, varname = &quot;y&quot;, formula = &quot;a + 1.0*g + 3 + rx*(2 + 4*L1)&quot;, 
    variance = 2.5^2, dist = &quot;normal&quot;)
  
  list(d0 = d0, dg = dg, dc1 = dc1, dc2 = dc2, d2 = d2)
  
}

s_generate &lt;- function(deflist, nsites, npatients) {
  
  list2env(x = deflist, envir = environment())
  
  ds &lt;- genData(nsites, d0)
  dd &lt;- genCluster(ds, &quot;study&quot;, npatients, &quot;id&quot;)
  dd &lt;- trtAssign(dd, strata = &quot;study&quot;, grpName = &quot;rx&quot;)
  dd &lt;- addCorFlex(dd, dg, rho = .6, corstr = &quot;cs&quot;)
  dd &lt;- addCondition(dc1, dd, newvar = &quot;obs_V&quot;)
  dd &lt;- addCondition(dc2, dd, newvar = &quot;L1&quot;)
  dd &lt;- addColumns(d2, dd)
  
  dd[]
}

s_estimate &lt;- function(dd, s_model) {
  
  N &lt;- nrow(dd)
  rx &lt;- dd[, rx]
  x &lt;- dd[, obs_V] 
  g &lt;- dd[, g]
  y &lt;- dd[, y]
  
  S &lt;- length(dd[, unique(study)])
  study &lt;- dd[, study]
  
  B &lt;- length(dd[, unique(bio)])
  bio &lt;- dd[, bio]
  
  drange &lt;- dd[rx==1, .(min = round(min(obs_V),1) + 1, 
                        max = round(max(obs_V),1)), keyby = bio]
  drange &lt;- drange[, seq(min, max, length.out = 50), keyby = bio]
  drange[, id := 1:.N, keyby = bio]
  drange &lt;- dcast(drange, id ~ bio, value.var = &quot;V1&quot;)
  
  M &lt;- nrow(drange)
  cuts &lt;- as.matrix(drange[, -1])
  
  studydata &lt;- list(N=N, rx = rx, x=x, g=g, y=y, S=S, 
    study=study,  B=B, bio=bio, M=M, cuts=cuts)
  
  fit &lt;-  sampling(s_model, data = studydata, iter = 3000, warmup = 500, 
    cores = 4L, chains = 4, refresh = 0)
  
  fit
}</code></pre>
<pre class="r"><code>rt &lt;- stanc(&quot;/.../latent_threshold.stan&quot;)
sm &lt;- stan_model(stanc_ret = rt, verbose=FALSE)

s_defs &lt;- s_define()
s_dd &lt;- s_generate(s_defs, 9, 80)
s_est &lt;- s_estimate(s_dd, sm)</code></pre>
<pre class="stan"><code>data {
  
    int&lt;lower=1&gt; N;                // number of observations
    int&lt;lower=0,upper=1&gt; rx[N];
    real x[N];
    real g[N];
    real y[N];   
    
    int&lt;lower=1&gt; S;                // number of studies/sites
    int&lt;lower=0,upper=S&gt; study[N];
    
    int&lt;lower=1&gt; B;                // number of biomarkers
    int&lt;lower=1,upper=B&gt; bio[N];
    
    int&lt;lower=1&gt; M;                // # of eligible thresholds
    real cuts[M, B];
    
}

transformed data {
  real log_unif;
  log_unif = -log(M);
}

parameters {
  real none;
  real low;
  real not_low;
  real geffect;
  real a[S];
  
  real&lt;lower=0&gt; sigma_a;
  real&lt;lower=0&gt; sigma_y;

}

transformed parameters {
  
  vector[N] r;
  vector[N] l;
  vector[N] q;
  
  real lp[M, B];
  
  for (n in 1:N) {
      q[n] = a[study[n]] + none + geffect * g[n];
      r[n] = a[study[n]] + low + geffect * g[n];
      l[n] = a[study[n]] + not_low + geffect * g[n];
  }
  
  lp = rep_array(log_unif, M, B);
    
  for (n in 1:N)
   for (m in 1:M)
    if (rx[n] == 0) 
     lp[m, bio[n]] = lp[m, bio[n]] + 
        normal_lpdf(y[n] | q[n], sigma_y);
    else
     lp[m, bio[n]] = lp[m, bio[n]] + 
        normal_lpdf(y[n] | x[n] &lt; cuts[m, bio[n]] ? r[n] : l[n], sigma_y);
      
}

model {
  
  none ~ student_t(3, 0, 2.5);
  low ~ student_t(3, 0, 2.5);
  not_low ~ student_t(3, 0, 2.5);
  geffect ~ student_t(3, 0, 2.5);
  
  a ~ normal(0, sigma_a);
  
  sigma_a ~ cauchy(0, 5);
  sigma_y ~ cauchy(0, 5);
  
  for (b in 1:B)
    target += log_sum_exp(lp[,b]);

}

generated quantities {
  
  real eff_low;
  real eff_not_low;
  real eff_low_notlow;
  
  eff_low = low - none;
  eff_not_low = not_low - none;
  eff_low_notlow = not_low - low;

}</code></pre>
<pre class="r"><code>x &lt;- summary(
  s_est, 
  pars = c(&quot;none&quot;, &quot;low&quot;, &quot;not_low&quot;,
           &quot;eff_low&quot;, &quot;eff_not_low&quot;, &quot;eff_low_notlow&quot;),
  probs = c(0.025, 0.5, 0.975)
)

x$summary</code></pre>
<pre><code>##                mean se_mean    sd  2.5%  50% 97.5% n_eff Rhat
## none           1.99 0.01774 0.659 0.504 2.07  3.10  1379    1
## low            4.32 0.01797 0.666 2.835 4.39  5.44  1374    1
## not_low        7.79 0.01838 0.703 6.221 7.85  9.01  1463    1
## eff_low        2.33 0.00185 0.207 1.914 2.33  2.74 12467    1
## eff_not_low    5.79 0.00266 0.307 5.185 5.79  6.39 13319    1
## eff_low_notlow 3.46 0.00267 0.313 2.853 3.46  4.08 13675    1</code></pre>
<pre class="r"><code>posterior &lt;- as.array(s_est) 
lp &lt;- log_posterior(s_est)
np &lt;- nuts_params(s_est)

pars = c(&quot;none&quot;,&quot;low&quot;,&quot;not_low&quot;,
         &quot;geffect&quot;, &quot;sigma_a&quot;, &quot;sigma_y&quot;)

color_scheme_set(&quot;mix-brightblue-gray&quot;)

mcmc_trace(posterior, pars = pars, 
  facet_args = list(nrow = 2), np = np) + xlab(&quot;Post-warmup iteration&quot;)</code></pre>
<pre><code>## No divergences to plot.</code></pre>
<p><img src="/post/2020-12-08-a-bayes-latent-threshold-model.en_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<pre class="r"><code>mcmc_intervals(posterior, pars = pars, prob_outer = 0.95)</code></pre>
<p><img src="/post/2020-12-08-a-bayes-latent-threshold-model.en_files/figure-html/unnamed-chunk-5-2.png" width="672" /></p>
<pre class="r"><code>color_scheme_set(&quot;blue&quot;)
mcmc_hist(posterior, pars = pars)</code></pre>
<pre><code>## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.</code></pre>
<p><img src="/post/2020-12-08-a-bayes-latent-threshold-model.en_files/figure-html/unnamed-chunk-5-3.png" width="672" /></p>
<p><img src="/post/2020-12-08-a-bayes-latent-threshold-model.en_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
