<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on ouR data generation</title>
    <link>/post/</link>
    <description>Recent content in Posts on ouR data generation</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>keith.goldfeld@nyumc.org (Keith Goldfeld)</managingEditor>
    <webMaster>keith.goldfeld@nyumc.org (Keith Goldfeld)</webMaster>
    <lastBuildDate>Thu, 05 Oct 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="/post/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>A minor update to simstudy provides an excuse to talk a bit about the negative binomial and Poisson distributions</title>
      <link>/post/a-small-update-to-simstudy-neg-bin/</link>
      <pubDate>Thu, 05 Oct 2017 00:00:00 +0000</pubDate>
      <author>keith.goldfeld@nyumc.org (Keith Goldfeld)</author>
      <guid>/post/a-small-update-to-simstudy-neg-bin/</guid>
      <description>&lt;p&gt;I just updated &lt;code&gt;simstudy&lt;/code&gt; to version 0.1.5 (available on &lt;a href=&#34;https://cran.r-project.org/web/packages/simstudy/index.html&#34;&gt;CRAN&lt;/a&gt;) so that it now includes several new distributions - &lt;em&gt;exponential&lt;/em&gt;, &lt;em&gt;discrete uniform&lt;/em&gt;, and &lt;em&gt;negative binomial&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;As part of the release, I thought I’d explore the negative binomial just a bit, particularly as it relates to the Poisson distribution. The Poisson distribution is a discrete (integer) distribution of outcomes of non-negative values that is often used to describe count outcomes. It is characterized by a mean (or rate) and its variance equals its mean.&lt;/p&gt;
&lt;div id=&#34;added-variation&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Added variation&lt;/h3&gt;
&lt;p&gt;In many situations, when count data are modeled, it turns out that the variance of the data exceeds the mean (a situation called &lt;em&gt;over-dispersion&lt;/em&gt;). In this case an alternative model is used that allows for the greater variance, which is based on the negative binomial distribution. It turns out that if the negative binomial distribution has mean &lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt;, it has a variance of &lt;span class=&#34;math inline&#34;&gt;\(\mu + \theta \mu^2\)&lt;/span&gt;, where &lt;span class=&#34;math inline&#34;&gt;\(\theta\)&lt;/span&gt; is called a &lt;em&gt;dispersion&lt;/em&gt; parameter. If &lt;span class=&#34;math inline&#34;&gt;\(\theta = 0\)&lt;/span&gt;, we have the Poisson distribution, but otherwise the variance of a negative binomial random variable will exceed the variance of a Poisson random variable as long as they share the same mean, because &lt;span class=&#34;math inline&#34;&gt;\(\mu &amp;gt; 0\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\theta \ge 0\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;We can see this by generating data from each distribution with mean 15, and a dispersion parameter of 0.2 for the negative binomial. We expect a variance around 15 for the Poisson distribution, and 60 for the negative binomial distribution.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(simstudy)
library(ggplot2)

# for a less cluttered look

theme_no_minor &amp;lt;- function(color = &amp;quot;grey90&amp;quot;) {    
  theme(panel.grid.minor = element_blank(),
        panel.background = element_rect(fill=&amp;quot;grey95&amp;quot;)
  )
}

options(digits = 2)

# define data

defC &amp;lt;- defCondition(condition = &amp;quot;dist == 0&amp;quot;, formula = 15, 
                     dist = &amp;quot;poisson&amp;quot;, link = &amp;quot;identity&amp;quot;)

defC &amp;lt;- defCondition(defC, condition = &amp;quot;dist == 1&amp;quot;, formula = 15, 
                     variance = 0.2, dist = &amp;quot;negBinomial&amp;quot;, 
                     link = &amp;quot;identity&amp;quot;)

# generate data

set.seed(50)
dt &amp;lt;- genData(500)
dt &amp;lt;- trtAssign(dt, 2, grpName = &amp;quot;dist&amp;quot;)
dt &amp;lt;- addCondition(defC, dt, &amp;quot;y&amp;quot;)
genFactor(dt, &amp;quot;dist&amp;quot;, c(&amp;quot;Poisson&amp;quot;, &amp;quot;Negative binomial&amp;quot;))

# compare distributions

dt[, .(mean = mean(y), var = var(y)), keyby = fdist]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                fdist mean var
## 1:           Poisson   15  15
## 2: Negative binomial   15  54&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(data = dt, aes(x = y, group = fdist)) +
  geom_density(aes(fill=fdist), alpha = .4) +
  scale_fill_manual(values = c(&amp;quot;#808000&amp;quot;, &amp;quot;#000080&amp;quot;)) +
  scale_x_continuous(limits = c(0,60), 
                     breaks = seq(0, 60, by = 20)) +
  theme_no_minor() +
  theme(legend.title = element_blank(),
        legend.position = c(0.80, 0.83))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-10-05-a-small-update-to-simstudy-provides-an-excuse-to-compare-the-negative-binomial-and-poisson-distributions_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;underestimating-standard-errors&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Underestimating standard errors&lt;/h3&gt;
&lt;p&gt;In the context of a regression, misspecifying a model as Poisson rather than negative binomial, can lead to an underestimation of standard errors, even though the point estimates may be quite reasonable (or may not). The Poisson model will force the variance estimate to be equal to the mean at any particular point on the regression curve. The Poisson model will effectively ignore the true extent of the variation, which can lead to problems of interpretation. We might conclude that there is an association when in fact there is none.&lt;/p&gt;
&lt;p&gt;In this simple simulation, we generate two predictors (&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt;) and an outcome (&lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;). The outcome is a function of &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; only:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(broom)
library(MASS)

# Generating data from negative binomial dist

def &amp;lt;- defData(varname = &amp;quot;x&amp;quot;, formula = 0, variance = 1, 
               dist = &amp;quot;normal&amp;quot;)
def &amp;lt;- defData(def, varname = &amp;quot;b&amp;quot;, formula = 0, variance = 1, 
               dist = &amp;quot;normal&amp;quot;)
def &amp;lt;- defData(def, varname = &amp;quot;y&amp;quot;, formula = &amp;quot;0.9 + 0.6*x&amp;quot;, 
               variance = 0.3, dist = &amp;quot;negBinomial&amp;quot;, link = &amp;quot;log&amp;quot;)

set.seed(35)
dt &amp;lt;- genData(500, def)

ggplot(data = dt, aes(x=x, y = y)) +
  geom_jitter(width = .1) +
  ggtitle(&amp;quot;Outcome as function of 1st predictor&amp;quot;) +
  theme_no_minor()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-10-05-a-small-update-to-simstudy-provides-an-excuse-to-compare-the-negative-binomial-and-poisson-distributions_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(data = dt, aes(x=b, y = y)) +
  geom_jitter(width = 0) +
  ggtitle(&amp;quot;Outcome as function of 2nd predictor&amp;quot;) +
  theme_no_minor()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-10-05-a-small-update-to-simstudy-provides-an-excuse-to-compare-the-negative-binomial-and-poisson-distributions_files/figure-html/unnamed-chunk-2-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;I fit two models using both predictors. The first assumes (incorrectly) a Poisson distribution, and the second assumes (correctly) a negative binomial distribution. We can see that although the point estimates are quite close, the standard error estimates for the predictors in the Poisson model are considerably greater (about 50% higher) than the negative binomial model. And if we were basing any conclusion on the p-value (which is not always the obvious way to do &lt;a href=&#34;http://www.stat.columbia.edu/~gelman/research/unpublished/abandon.pdf&#34;&gt;things&lt;/a&gt;), we might make the wrong call since the p-value for the slope of &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; is estimated to be 0.029. Under the correct model model, the p-value is 0.29.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;glmfit &amp;lt;- glm(y ~ x + b, data = dt, family = poisson (link = &amp;quot;log&amp;quot;) )
tidy(glmfit)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          term estimate std.error statistic  p.value
## 1 (Intercept)    0.956     0.030      32.3 1.1e-228
## 2           x    0.516     0.024      21.9 1.9e-106
## 3           b   -0.052     0.024      -2.2  2.9e-02&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;nbfit &amp;lt;- glm.nb(y ~ x + b, data = dt)
tidy(nbfit)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          term estimate std.error statistic  p.value
## 1 (Intercept)    0.954     0.039      24.2 1.1e-129
## 2           x    0.519     0.037      14.2  7.9e-46
## 3           b   -0.037     0.036      -1.1  2.9e-01&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A plot of the fitted regression curve and confidence bands of &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; estimated by each model reinforces the difference. The lighter shaded region is the wider confidence band of the negative binomial model, and the darker shaded region the based on the Poisson model.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;newb &amp;lt;- data.table(b=seq(-3,3,length = 100), x = 0)

poispred &amp;lt;- predict(glmfit, newdata = newb, se.fit = TRUE, 
                    type = &amp;quot;response&amp;quot;)
nbpred &amp;lt;-predict(nbfit, newdata = newb, se.fit = TRUE, 
                 type = &amp;quot;response&amp;quot;)

poisdf &amp;lt;- data.table(b = newb$b, y = poispred$fit, 
                     lwr = poispred$fit - 1.96*poispred$se.fit,
                     upr = poispred$fit + 1.96*poispred$se.fit)

nbdf &amp;lt;- data.table(b = newb$b,  y = nbpred$fit, 
                     lwr = nbpred$fit - 1.96*nbpred$se.fit,
                     upr = nbpred$fit + 1.96*nbpred$se.fit)

ggplot(data = poisdf, aes(x=b, y = y)) +
  geom_line() +
  geom_ribbon(data=nbdf, aes(ymin = lwr, ymax=upr), alpha = .3, 
              fill = &amp;quot;red&amp;quot;) +
  geom_ribbon(aes(ymin = lwr, ymax=upr), alpha = .5, 
              fill = &amp;quot;red&amp;quot;) +
  theme_no_minor()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-10-05-a-small-update-to-simstudy-provides-an-excuse-to-compare-the-negative-binomial-and-poisson-distributions_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;And finally, if we take 500 samples of size 500, and estimate slope for &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; each time and calculate the standard deviation of those estimates, it is quite close to the standard error estimate we saw in the model of the original simulated data set using the negative binomial assumption (0.036). And the mean of those estimates is quite close to zero, the true value.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;result &amp;lt;- data.table()

for (i in 1:500) {
  
  dt &amp;lt;- genData(500, def)
  glmfit &amp;lt;- glm(y ~ x + b, data = dt, family = poisson)
  nbfit &amp;lt;- glm.nb(y ~ x + b, data = dt)

  result &amp;lt;- rbind(result, data.table(bPois = coef(glmfit)[&amp;quot;b&amp;quot;],
                                     bNB = coef(nbfit)[&amp;quot;b&amp;quot;])
  )
  
}

result[,.(sd(bPois), sd(bNB))]   # observed standard error&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       V1    V2
## 1: 0.037 0.036&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;result[,.(mean(bPois), mean(bNB))] # observed mean&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        V1     V2
## 1: 0.0025 0.0033&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;negative-binomial-as-mixture-of-poissons&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Negative binomial as mixture of Poissons&lt;/h3&gt;
&lt;p&gt;An interesting relationship between the two distributions is that a negative binomial distribution can be generated from a mixture of individuals whose outcomes come from a Poisson distribution, but each individual has her own rate or mean. Furthermore, those rates must have a specific distribution - a Gamma. (For much more on this, you can take a look &lt;a href=&#34;https://probabilityandstats.wordpress.com/tag/poisson-gamma-mixture/&#34;&gt;here&lt;/a&gt;.) Here is a little simulation:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mu = 15
disp = 0.2

# Gamma distributed means

def &amp;lt;- defData(varname = &amp;quot;gmu&amp;quot;, formula = mu, variance = disp, 
               dist = &amp;quot;gamma&amp;quot;)

# generate data from each distribution

defC &amp;lt;- defCondition(condition = &amp;quot;nb == 0&amp;quot;, formula = &amp;quot;gmu&amp;quot;, 
                     dist = &amp;quot;poisson&amp;quot;)

defC &amp;lt;- defCondition(defC, condition = &amp;quot;nb == 1&amp;quot;, formula = mu,
                     variance = disp, dist = &amp;quot;negBinomial&amp;quot;)

dt &amp;lt;- genData(5000, def)
dt &amp;lt;- trtAssign(dt, 2, grpName = &amp;quot;nb&amp;quot;)
genFactor(dt, &amp;quot;nb&amp;quot;, labels = c(&amp;quot;Poisson-Gamma&amp;quot;, &amp;quot;Negative binomial&amp;quot;))

dt &amp;lt;- addCondition(defC, dt, &amp;quot;y&amp;quot;)

# means and variances should be very close

dt[, .(Mean = mean(y), Var = var(y)), keyby = fnb]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                  fnb Mean Var
## 1:     Poisson-Gamma   15  62
## 2: Negative binomial   15  57&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# plot

ggplot(data = dt, aes(x = y, group = fnb)) +
  geom_density(aes(fill=fnb), alpha = .4) +
  scale_fill_manual(values = c(&amp;quot;#808000&amp;quot;, &amp;quot;#000080&amp;quot;)) +
  scale_x_continuous(limits = c(0,60), 
                     breaks = seq(0, 60, by = 20)) +
  theme_no_minor() +
  theme(legend.title = element_blank(),
        legend.position = c(0.80, 0.83))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-10-05-a-small-update-to-simstudy-provides-an-excuse-to-compare-the-negative-binomial-and-poisson-distributions_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>CACE closed: EM opens up exclusion restriction (among other things)</title>
      <link>/post/em-estimation-of-cace/</link>
      <pubDate>Thu, 28 Sep 2017 00:00:00 +0000</pubDate>
      <author>keith.goldfeld@nyumc.org (Keith Goldfeld)</author>
      <guid>/post/em-estimation-of-cace/</guid>
      <description>&lt;p&gt;This is the third, and probably last, of a series of posts touching on the estimation of &lt;a href=&#34;https://www.rdatagen.net/post/cace-explored/&#34;&gt;complier average causal effects&lt;/a&gt; (CACE) and &lt;a href=&#34;https://www.rdatagen.net/post/simstudy-update-provides-an-excuse-to-talk-a-little-bit-about-the-em-algorithm-and-latent-class/&#34;&gt;latent variable modeling techniques&lt;/a&gt; using an expectation-maximization (EM) algorithm . What follows is a simplistic way to implement an EM algorithm in &lt;code&gt;R&lt;/code&gt; to do principal strata estimation of CACE.&lt;/p&gt;
&lt;div id=&#34;the-em-algorithm&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;The EM algorithm&lt;/h3&gt;
&lt;p&gt;In this approach, we assume that individuals fall into one of three possible groups - &lt;em&gt;never-takers&lt;/em&gt;, &lt;em&gt;always-takers&lt;/em&gt;, and &lt;em&gt;compliers&lt;/em&gt; - but we cannot see who is who (except in a couple of cases). For each group, we are interested in estimating the unobserved potential outcomes &lt;span class=&#34;math inline&#34;&gt;\(Y_0\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(Y_1\)&lt;/span&gt; using observed outcome measures of &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt;. The EM algorithm does this in two steps. The &lt;em&gt;E-step&lt;/em&gt; estimates the missing class membership for each individual, and the &lt;em&gt;M-step&lt;/em&gt; provides maximum likelihood estimates of the group-specific potential outcomes and variation.&lt;/p&gt;
&lt;p&gt;An estimate group membership was presented in this &lt;a href=&#34;https://projecteuclid.org/euclid.aos/1034276631&#34;&gt;Imbens &amp;amp; Rubin 1997 paper&lt;/a&gt;. The probability that an individual is a member of a particular group is a function of how close the individual’s observed outcome is to the mean of the group and the overall probability of group membership:&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/img/post-em-cace/table.png&#34; /&gt;

&lt;/div&gt;
&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(Z\)&lt;/span&gt; is treatment assignment and &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; is treatment received. In addition, &lt;span class=&#34;math inline&#34;&gt;\(g_{c0}^i = \phi\left( \frac{Y_{obs,i} - \mu_{c0}}{\sigma_{c0}} \right)/\sigma_{c0}\)&lt;/span&gt;, where &lt;span class=&#34;math inline&#34;&gt;\(\phi(.)\)&lt;/span&gt; is the standard normal density. (And the same goes for the other &lt;span class=&#34;math inline&#34;&gt;\(g^i\)&lt;/span&gt;’s.) &lt;span class=&#34;math inline&#34;&gt;\(\pi_a\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(\pi_n\)&lt;/span&gt;, and &lt;span class=&#34;math inline&#34;&gt;\(\pi_c\)&lt;/span&gt; are estimated in the prior stage (or with starting values). &lt;span class=&#34;math inline&#34;&gt;\(\mu_{c0}\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(\mu_{c1}\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(\sigma_{c0}\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(\sigma_{c1}\)&lt;/span&gt;, etc. are also estimated in the prior &lt;em&gt;M-step&lt;/em&gt; or with starting values in the case of the first &lt;em&gt;E-step&lt;/em&gt;. Note that because we &lt;em&gt;are&lt;/em&gt; assuming monotonicity (no &lt;em&gt;deniers&lt;/em&gt; - which is not a necessary assumption for the EM approach, but used here to simplify things a bit), the probability of group membership is 1 for those randomized to control but who receive treatment (&lt;em&gt;always-takers&lt;/em&gt;) and for those randomized to intervention but refuse (&lt;em&gt;never-takers&lt;/em&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;em-steps&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;EM steps&lt;/h3&gt;
&lt;p&gt;I’ve created a separate function for each step in the algorithm. The &lt;em&gt;E-step&lt;/em&gt; follows the Imbens &amp;amp; Rubin specification just described. The &lt;em&gt;M-step&lt;/em&gt; just calculates the weighted averages and variances of the outcomes within each &lt;span class=&#34;math inline&#34;&gt;\(Z\)&lt;/span&gt;/&lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; pair, with the weights coming from the probabilities estimated in the &lt;em&gt;E-step&lt;/em&gt;. (These are, in fact, maximum likelihood estimates of the means and variances.) There are a pair of functions to estimate the log likelihood after each iteration. We stop iterating once the log likelihood has reached a stable state. And finally, there is a function to initialize the 15 parameters.&lt;/p&gt;
&lt;p&gt;One thing to highlight here is that a strong motivation for using the EM algorithm is that we do &lt;em&gt;not&lt;/em&gt; need to assume the exclusion restriction. That is, it is possible that randomizing someone to the intervention may have an effect on the outcome even if there is no effect on whether or not the intervention is used. Or in other words, we are saying it is possible that randomization has an effect on &lt;em&gt;always-takers&lt;/em&gt; and &lt;em&gt;never-takers&lt;/em&gt;, an assumption we &lt;em&gt;cannot&lt;/em&gt; make using an instrumental variable (IV) approach. I mention that here, because the &lt;em&gt;M-step&lt;/em&gt; function as written here explicitly drops the exclusion restriction assumption. However, I will first illustrate the model estimates in a case where data are indeed based on that assumption; while my point is to show that the EM estimates are unbiased as are the IV estimates in this scenario, I may actually be introducing a small amount of bias into the EM estimate by not re-writing the function to create a single mean for &lt;em&gt;always-takers&lt;/em&gt; and &lt;em&gt;never-takers&lt;/em&gt;. But, for brevity’s sake, this seems adequate.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;estep &amp;lt;- function(params, y, z, m) {
  
  piC &amp;lt;- 0
  piN &amp;lt;- 0
  piA &amp;lt;- 0
  
  if (z == 0 &amp;amp; m == 0) {
    
    gC0 &amp;lt;- dnorm((y - params$mC0)/params$sC0) / params$sC0
    gN0 &amp;lt;- dnorm((y - params$mN0)/params$sN0) / params$sN0
    
    piC &amp;lt;- params$pC * gC0 / ( params$pC * gC0 + params$pN * gN0)
    piN &amp;lt;- 1- piC
    
  }
  
  if (z == 0 &amp;amp; m == 1) {
    piA &amp;lt;- 1
  }
  
  if (z == 1 &amp;amp; m == 0) {
    piN &amp;lt;- 1
  }
  
  if (z == 1 &amp;amp; m == 1) {
    
    gC1 &amp;lt;- dnorm((y - params$mC1)/params$sC1) / params$sC1
    gA1 &amp;lt;- dnorm((y - params$mA1)/params$sA1) / params$sA1
    
    piC &amp;lt;- params$pC * gC1 / ( params$pC * gC1 + params$pA * gA1)
    piA &amp;lt;- 1 - piC
  }
  
  return(list(piC = piC, piN = piN, piA = piA))
  
}

library(Weighted.Desc.Stat)

mstep &amp;lt;- function(params, dx) {
  
  params$mN0 &amp;lt;- dx[z == 0 &amp;amp; m == 0, w.mean(y, piN)] # never-taker
  params$sN0 &amp;lt;- dx[z == 0 &amp;amp; m == 0, sqrt(w.var(y, piN))] # never-taker
  
  params$mN1 &amp;lt;- dx[z == 1 &amp;amp; m == 0, w.mean(y, piN)] # never-taker
  params$sN1 &amp;lt;- dx[z == 1 &amp;amp; m == 0, sqrt(w.var(y, piN))] # never-taker
  
  params$mA0 &amp;lt;- dx[z == 0 &amp;amp; m == 1, w.mean(y, piA)]# always-taker
  params$sA0 &amp;lt;- dx[z == 0 &amp;amp; m == 1, sqrt(w.var(y, piA))] # always-taker
  
  params$mA1 &amp;lt;- dx[z == 1 &amp;amp; m == 1, w.mean(y, piA)]# always-taker
  params$sA1 &amp;lt;- dx[z == 1 &amp;amp; m == 1, sqrt(w.var(y, piA))] # always-taker
  
  params$mC0 &amp;lt;- dx[z == 0 &amp;amp; m == 0, w.mean(y, piC)] # complier, z=0
  params$sC0 &amp;lt;- dx[z == 0 &amp;amp; m == 0, sqrt(w.var(y, piC))] # complier, z=0
  
  params$mC1 &amp;lt;- dx[z == 1 &amp;amp; m == 1, w.mean(y, piC)] # complier, z=1
  params$sC1 &amp;lt;- dx[z == 1 &amp;amp; m == 1, sqrt(w.var(y, piC))] # complier, z=1
  
  nC &amp;lt;- dx[, sum(piC)]
  nN &amp;lt;- dx[, sum(piN)]
  nA &amp;lt;- dx[, sum(piA)]
  
  params$pC &amp;lt;- (nC / sum(nC, nN, nA))
  params$pN &amp;lt;- (nN / sum(nC, nN, nA))
  params$pA &amp;lt;- (nA / sum(nC, nN, nA))
  
  return(params)
}

like.i &amp;lt;- function(params, y, z, m) {
  
  if (z == 0 &amp;amp; m == 0) {
    l &amp;lt;- params$pC * dnorm(x = y, mean = params$mC0, sd = params$sC0) +
      params$pN * dnorm(x = y, mean = params$mN0, sd = params$sN0)
  }
  
  if (z == 0 &amp;amp; m == 1) {
    l &amp;lt;- params$pA * dnorm(x = y, mean = params$mA0, sd = params$sA0)
  }
  
  if (z == 1 &amp;amp; m == 0) {
    l &amp;lt;- params$pN * dnorm(x = y, mean = params$mN1, sd = params$sN1)
  }
  
  if (z == 1 &amp;amp; m == 1) {
    l &amp;lt;- params$pC * dnorm(x = y, mean = params$mC1, sd = params$sC1) +
      params$pA * dnorm(x = y, mean = params$mA1, sd = params$sA1)
  }
  
  return(l)
}

loglike &amp;lt;- function(dt, params){
  
  dl &amp;lt;- dt[, .(l.i = like.i(params, y, z, m)), keyby = id]
  return(dl[, sum(log(l.i))])
  
}

initparams &amp;lt;- function() {
  
  params = list(pC = 1/3, pN = 1/3, pA = 1/3, 
                mC0 = rnorm(1,0,.1), sC0 = 0.2,
                mC1 = rnorm(1,0,.1), sC1 = 0.2, 
                mN0 = rnorm(1,0,.1), sN0 = 0.2,
                mN1 = rnorm(1,0,.1), sN1 = 0.2,
                mA0 = rnorm(1,0,.1), sA0 = 0.2,
                mA1 = rnorm(1,0,.1), sA1 = 0.2)
  
  return(params)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;data-defintions&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Data defintions&lt;/h3&gt;
&lt;p&gt;These next set of statements define the data that will be generated. I define the distribution of group assignment as well as potential outcomes for the intervention and the outcome &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt;. We also define how the observed data will be generated, which is a function of treatment randomization …&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(simstudy)

### Define data distributions

# Status :

# 1 = A(lways taker)
# 2 = N(ever taker)
# 3 = C(omplier)

def &amp;lt;- defDataAdd(varname = &amp;quot;Status&amp;quot;, 
                  formula = &amp;quot;0.25; 0.40; 0.35&amp;quot;, dist = &amp;quot;categorical&amp;quot;)

# potential outcomes (PO) for intervention depends on group status

def &amp;lt;- defDataAdd(def, varname = &amp;quot;M0&amp;quot;, 
                  formula = &amp;quot;(Status == 1) * 1&amp;quot;, dist = &amp;quot;nonrandom&amp;quot;)
def &amp;lt;- defDataAdd(def, varname = &amp;quot;M1&amp;quot;, 
                  formula = &amp;quot;(Status != 2) * 1&amp;quot;, dist = &amp;quot;nonrandom&amp;quot;)

# observed intervention status based on randomization and PO

def &amp;lt;- defDataAdd(def, varname = &amp;quot;m&amp;quot;, 
                  formula = &amp;quot;(z==0) * M0 + (z==1) * M1&amp;quot;, 
                  dist = &amp;quot;nonrandom&amp;quot;)

# potential outcome for Y (depends group status - A, N, or C)
# under assumption of exclusion restriction

defY0 &amp;lt;- defCondition(condition = &amp;quot;Status == 1&amp;quot;,
                      formula = 0.3, variance = .25, dist = &amp;quot;normal&amp;quot;)
defY0 &amp;lt;- defCondition(defY0, condition = &amp;quot;Status == 2&amp;quot;,
                      formula = 0.0, variance = .36, dist = &amp;quot;normal&amp;quot;)
defY0 &amp;lt;- defCondition(defY0, condition = &amp;quot;Status == 3&amp;quot;,
                      formula = 0.1, variance = .16, dist = &amp;quot;normal&amp;quot;)

defY1 &amp;lt;- defCondition(condition = &amp;quot;Status == 1&amp;quot;,
                      formula = 0.3, variance = .25, dist = &amp;quot;normal&amp;quot;)
defY1 &amp;lt;- defCondition(defY1, condition = &amp;quot;Status == 2&amp;quot;,
                      formula = 0.0, variance = .36, dist = &amp;quot;normal&amp;quot;)
defY1 &amp;lt;- defCondition(defY1, condition = &amp;quot;Status == 3&amp;quot;,
                      formula = 0.9, variance = .49, dist = &amp;quot;normal&amp;quot;)

# observed outcome function of actual treatment

defy &amp;lt;- defDataAdd(varname = &amp;quot;y&amp;quot;, 
                   formula = &amp;quot;(z == 0) * Y0 + (z == 1) * Y1&amp;quot;, 
                   dist = &amp;quot;nonrandom&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;data-generation&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Data generation&lt;/h3&gt;
&lt;p&gt;I am generating multiple data sets and estimating the causal effects for each using the EM and IV approaches. This gives better picture of the bias and variation under the two different scenarios (exclusion restriction &amp;amp; no exclusion restriction) and different methods (EM &amp;amp; IV). To simplify the code a bit, I’ve written a function to consolidate the data generating process:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;createDT &amp;lt;- function(n, def, defY0, defY1, defy) {
  
  dt &amp;lt;- genData(n)
  dt &amp;lt;- trtAssign(dt, n=2, grpName = &amp;quot;z&amp;quot;)
  dt &amp;lt;- addColumns(def, dt)
  
  genFactor(dt, &amp;quot;Status&amp;quot;, 
            labels = c(&amp;quot;Always-taker&amp;quot;,&amp;quot;Never-taker&amp;quot;, &amp;quot;Complier&amp;quot;), 
            prefix = &amp;quot;A&amp;quot;)
  
  dt &amp;lt;- addCondition(defY0, dt, &amp;quot;Y0&amp;quot;)
  dt &amp;lt;- addCondition(defY1, dt, &amp;quot;Y1&amp;quot;)
  dt &amp;lt;- addColumns(defy, dt)
  
}

set.seed(16)
dt &amp;lt;- createDT(2500, def, defY0, defY1, defy)

options(digits = 3)

dt&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         id       Y1        Y0 z Status M0 M1 m      AStatus       y
##    1:    1  0.12143 -0.400007 0      2  0  0 0  Never-taker -0.4000
##    2:    2  0.13114  0.713202 1      1  1  1 1 Always-taker  0.1311
##    3:    3  0.73766 -0.212530 1      3  0  1 1     Complier  0.7377
##    4:    4 -0.07531  0.209330 1      1  1  1 1 Always-taker -0.0753
##    5:    5 -0.25214 -0.696207 0      2  0  0 0  Never-taker -0.6962
##   ---                                                              
## 2496: 2496 -0.00882  0.206581 0      2  0  0 0  Never-taker  0.2066
## 2497: 2497  0.39226  0.749465 1      2  0  0 0  Never-taker  0.3923
## 2498: 2498 -0.81486  0.000605 1      2  0  0 0  Never-taker -0.8149
## 2499: 2499  0.10359 -0.417344 0      2  0  0 0  Never-taker -0.4173
## 2500: 2500 -0.68397  0.304398 1      2  0  0 0  Never-taker -0.6840&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;cace-estimation&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;CACE estimation&lt;/h3&gt;
&lt;p&gt;Finally, we are ready to put all of this together and estimate the CACE using the EM algorithm. After initializing the parameters (here we just use random values except for the probabilities of group membership, which we assume to be 1/3 to start), we loop through the E and M steps, checking the change in log likelihood each time. For this single data set, we provide a point estimate of the CACE using EM and IV. (We could provide an estimate of standard error using a bootstrap approach.) We see that both do a reasonable job, getting fairly close to the truth.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;params &amp;lt;- initparams()
prev.loglike &amp;lt;- -Inf
continue &amp;lt;- TRUE
  
while (continue) {
    
  dtPIs &amp;lt;- dt[, estep(params, y, z, m), keyby = id]
  dx &amp;lt;- dt[dtPIs]
    
  params &amp;lt;- mstep(params, dx)
    
  EM.CACE &amp;lt;- params$mC1 - params$mC0
  
  current.loglike &amp;lt;- loglike(dt, params)
  diff &amp;lt;- current.loglike - prev.loglike
  prev.loglike &amp;lt;- current.loglike
  if ( diff &amp;lt; 1.00e-07 ) continue = FALSE
    
}
  
library(ivpack)
ivmodel &amp;lt;- ivreg(formula = y ~ m | z, data = dt, x = TRUE)
  
data.table(truthC = dt[AStatus == &amp;quot;Complier&amp;quot;, mean(Y1 - Y0)],
           IV.CACE = coef(ivmodel)[2],
           EM.CACE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    truthC IV.CACE EM.CACE
## 1:  0.806   0.823   0.861&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;more-general-performance&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;More general performance&lt;/h3&gt;
&lt;p&gt;I am not providing the code here (it is just a slight modification of what has come before), but I want to show the results of generating 1000 data sets of 500 observations in each. The first plot assumes all data sets were generated using an exclusion restriction - just as we did with the single data set. The IV approach, as expected is unbiased (estimated bias 0.01), while the EM approach is slightly biased (-0.13). We can also see that the EM approach (standard deviation 0.30) has more variation than IV (standard deviation 0.15), while the actual sample CACE (calculated based on the actual group membership and potential outcomes) had a standard deviation of 0.05, which we can see from the narrow vertical band in the plot:&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/img/post-em-cace/Exclusion_restriction.png&#34; /&gt;

&lt;/div&gt;
&lt;p&gt;In the second set of simulations, I change the potential outcomes definition so that the exclusion restriction is no longer relevant.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;defY0 &amp;lt;- defCondition(condition = &amp;quot;Status == 1&amp;quot;,
                      formula = 0.3, variance = .20, dist = &amp;quot;normal&amp;quot;)
defY0 &amp;lt;- defCondition(defY0, condition = &amp;quot;Status == 2&amp;quot;,
                      formula = 0.0, variance = .36, dist = &amp;quot;normal&amp;quot;)
defY0 &amp;lt;- defCondition(defY0, condition = &amp;quot;Status == 3&amp;quot;,
                      formula = 0.1, variance = .16, dist = &amp;quot;normal&amp;quot;)

defY1 &amp;lt;- defCondition(condition = &amp;quot;Status == 1&amp;quot;,
                      formula = 0.7, variance = .25, dist = &amp;quot;normal&amp;quot;)
defY1 &amp;lt;- defCondition(defY1, condition = &amp;quot;Status == 2&amp;quot;,
                      formula = 0.2, variance = .40, dist = &amp;quot;normal&amp;quot;)
defY1 &amp;lt;- defCondition(defY1, condition = &amp;quot;Status == 3&amp;quot;,
                      formula = 0.9, variance = .49, dist = &amp;quot;normal&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this second case, the IV estimate is biased (0.53), while the EM estimated does quite well (-.03). (I suspect EM did worse in the first example above, because estimates were made without the assumption of the exclusion restriction, even though that was the case.) However, EM estimates still have more variation than IV: standard deviation 0.26 vs 0.17, consistent with the estimates under the exclusion restriction assumption. This variation arises from the fact that we don’t know what the true group membership is, and we need to estimate it. Here is what the estimates look like:&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/img/post-em-cace/No_exclusion_restriction.png&#34; /&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;can-we-expand-on-this&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Can we expand on this?&lt;/h3&gt;
&lt;p&gt;The whole point of this was to illustrate that there might be a way around some rather restrictive assumptions, which in some cases might not seem so reasonable. EM methods provide an alternative way to approach things - more of which you can see in the &lt;a href=&#34;https://courseplus.jhu.edu/core/index.cfm/go/course.home/coid/8155/&#34;&gt;free online course&lt;/a&gt; that inspired these last few posts. Unfortunately, there is no obvious way to tackle these problems in &lt;code&gt;R&lt;/code&gt; using existing packages, and I am not suggesting that what I have done here is the best way to go about it. The course suggests using &lt;code&gt;Mplus&lt;/code&gt;. While that is certainly a great software package, maybe it would be worthwhile to build an R package to implement these methods more completely in R? Or maybe someone has already done this, and I just haven’t come across it yet?&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>A simstudy update provides an excuse to talk a little bit about latent class regression and the EM algorithm</title>
      <link>/post/simstudy-update-provides-an-excuse-to-talk-a-little-bit-about-the-em-algorithm-and-latent-class/</link>
      <pubDate>Wed, 20 Sep 2017 00:00:00 +0000</pubDate>
      <author>keith.goldfeld@nyumc.org (Keith Goldfeld)</author>
      <guid>/post/simstudy-update-provides-an-excuse-to-talk-a-little-bit-about-the-em-algorithm-and-latent-class/</guid>
      <description>&lt;p&gt;I was just going to make a quick announcement to let folks know that I’ve updated the &lt;code&gt;simstudy&lt;/code&gt; package to version 0.1.4 (now available on CRAN) to include functions that allow conversion of columns to factors, creation of dummy variables, and most importantly, specification of outcomes that are more flexibly conditional on previously defined variables. But, as I was coming up with an example that might illustrate the added conditional functionality, I found myself playing with package &lt;code&gt;flexmix&lt;/code&gt;, which uses an Expectation-Maximization (EM) algorithm to estimate latent classes and fit regression models. So, in the end, this turned into a bit more than a brief service announcement.&lt;/p&gt;
&lt;div id=&#34;defining-data-conditionally&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Defining data conditionally&lt;/h3&gt;
&lt;p&gt;Of course, simstudy has always enabled conditional distributions based on sequentially defined variables. That is really the whole point of simstudy. But, what if I wanted to specify completely different families of distributions or very different regression curves based on different individual characteristics? With the previous version of simstudy, it was not really easy to do. Now, with the addition of two key functions, &lt;code&gt;defCondition&lt;/code&gt; and &lt;code&gt;addCondition&lt;/code&gt; the process is much improved. &lt;code&gt;defCondition&lt;/code&gt; is analogous to the function &lt;code&gt;defData&lt;/code&gt;, in that this new function provides an easy way to specify conditional definitions (as does &lt;code&gt;defReadCond&lt;/code&gt;, which is analogous to &lt;code&gt;defRead&lt;/code&gt;). &lt;code&gt;addCondition&lt;/code&gt; is used to actually add the data column, just as &lt;code&gt;addColumns&lt;/code&gt; adds columns.&lt;/p&gt;
&lt;p&gt;It is probably easiest to see in action:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(simstudy)

# Define baseline data set

def &amp;lt;- defData(varname=&amp;quot;x&amp;quot;, dist=&amp;quot;normal&amp;quot;, formula=0, variance=9)
def &amp;lt;- defData(def, varname = &amp;quot;group&amp;quot;, formula = &amp;quot;0.2;0.5;0.3&amp;quot;, 
               dist = &amp;quot;categorical&amp;quot;)

# Generate data

set.seed(111)

dt &amp;lt;- genData(1000, def)

# Convert group to factor - new function

dt &amp;lt;- genFactor(dt, &amp;quot;group&amp;quot;, replace = TRUE)   
dt&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;defCondition&lt;/code&gt; is the same as &lt;code&gt;defData&lt;/code&gt;, except that instead of specifying a variable name, we need to specify a condition that is based on a pre-defined field:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;defC &amp;lt;- defCondition(condition = &amp;quot;fgroup == 1&amp;quot;, formula = &amp;quot;5 + 2*x&amp;quot;,
                     variance = 4, dist = &amp;quot;normal&amp;quot;)
defC &amp;lt;- defCondition(defC, condition = &amp;quot;fgroup == 2&amp;quot;, formula = 4,
                     variance = 3, dist=&amp;quot;normal&amp;quot;)
defC &amp;lt;- defCondition(defC, condition = &amp;quot;fgroup == 3&amp;quot;, formula = &amp;quot;3 - 2*x&amp;quot;,
                     variance = 2, dist=&amp;quot;normal&amp;quot;)

defC&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      condition formula variance   dist     link
## 1: fgroup == 1 5 + 2*x        4 normal identity
## 2: fgroup == 2       4        3 normal identity
## 3: fgroup == 3 3 - 2*x        2 normal identity&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A subsequent call to &lt;code&gt;addCondition&lt;/code&gt; generates a data table with the new variable, in this case &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dt &amp;lt;- addCondition(defC, dt, &amp;quot;y&amp;quot;)

dt&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         id          y          x fgroup
##    1:    1  5.3036869  0.7056621      2
##    2:    2  2.1521853 -0.9922076      2
##    3:    3  4.7422359 -0.9348715      3
##    4:    4 16.1814232 -6.9070370      3
##    5:    5  4.3958893 -0.5126281      3
##   ---                                  
##  996:  996 -0.8115245 -2.7092396      1
##  997:  997  1.9946074  0.7126094      2
##  998:  998 11.8384871  2.3895135      1
##  999:  999  3.3569664  0.8123200      1
## 1000: 1000  3.4662074 -0.4653198      3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, I’ve partitioned the data into three subsets, each of which has a very different linear relationship between variables &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;, and different variation. In this particular case, all relationships are linear with normally distributed noise, but this is absolutely not required.&lt;/p&gt;
&lt;p&gt;Here is what the data look like:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggplot2)

mycolors &amp;lt;- c(&amp;quot;#555bd4&amp;quot;,&amp;quot;#d4555b&amp;quot;,&amp;quot;#d4ce55&amp;quot;)

ggplot(data = dt, aes(x = x, y = y, group = fgroup)) +
  geom_point(aes(color = fgroup), size = 1, alpha = .4) +
  geom_smooth(aes(color = fgroup), se = FALSE, method = &amp;quot;lm&amp;quot;) +
  scale_color_manual(name = &amp;quot;Cluster&amp;quot;, values = mycolors)  +
  scale_x_continuous(limits = c(-10,10), breaks = c(-10, -5, 0, 5, 10)) +
  theme(panel.grid = element_blank(),
        panel.background = element_rect(fill = &amp;quot;grey96&amp;quot;, color = &amp;quot;grey80&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-09-20-simstudy-update-provides-an-excuse-to-talk-a-little-bit-about-the-em-algorithm-and-latent-class_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;latent-class-regression-models&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Latent class regression models&lt;/h3&gt;
&lt;p&gt;Suppose we come across the same data set, but are not privy to the group classification, and we are still interested in the relationship between &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;. This is what the data set would look like - not as user-friendly:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rawp &amp;lt;- ggplot(data = dt, aes(x = x, y = y, group = fgroup)) +
  geom_point(color = &amp;quot;grey75&amp;quot;, size = .5) +
  scale_x_continuous(limits = c(-10,10), breaks = c(-10, -5, 0, 5, 10)) +
  theme(panel.grid = element_blank(),
        panel.background = element_rect(fill = &amp;quot;grey96&amp;quot;, color = &amp;quot;grey80&amp;quot;))

rawp&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-09-20-simstudy-update-provides-an-excuse-to-talk-a-little-bit-about-the-em-algorithm-and-latent-class_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;504&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We might see from the plot, or we might have some subject-matter knowledge that suggests there are are several sub-clusters within the data, each of which appears to have a different relationship between &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;. (Obviously, we know this is the case, since we generated the data.) The question is, how can we estimate the regression lines if we don’t know the class membership? That is where the EM algorithm comes into play.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-em-algorithm-very-very-briefly&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;The EM algorithm, very, very briefly&lt;/h3&gt;
&lt;p&gt;The EM algorithm handles model parameter estimation in the context of incomplete or missing data. In the example I’ve been discussing here, the subgroups or cluster membership are the missing data. There is an extensive literature on EM methods (starting with &lt;a href=&#34;http://www.jstor.org/stable/2984875&#34;&gt;this article&lt;/a&gt; by Dempster, Laird &amp;amp; Rubin), and I am barely even touching the surface, let alone scratching it.&lt;/p&gt;
&lt;p&gt;The missing data (cluster memberships) are estimated in the &lt;em&gt;Expectation-&lt;/em&gt; or &lt;em&gt;E-step&lt;/em&gt;. These are replaced with their expected values as given by the posterior probabilities. The mixture model assumes that each observation is exactly from one cluster, but this information has not been observed. The unknown model parameters (intercept, slope, and variance) for each of the clusters is estimated in the &lt;em&gt;Maximization-&lt;/em&gt; or &lt;em&gt;M-step&lt;/em&gt;, which in this case assumes the data come from a linear process with normally distributed noise - both the linear coefficients and variation around the line are conditional on cluster membership. The process is iterative. First, the &lt;em&gt;E-step&lt;/em&gt;, which is based on some starting model parameters at first and then updated with the most recent parameter estimates from the prior &lt;em&gt;M-step&lt;/em&gt;. Second, the &lt;em&gt;M-step&lt;/em&gt; is based on estimates of the maximum likelihood of all the data (including the ‘missing’ data estimated in the prior &lt;em&gt;E-step&lt;/em&gt;). We iterate back and forth until the parameter estimates in the &lt;em&gt;M-step&lt;/em&gt; reach a steady state, or the overal likelihood estimate becomes stable.&lt;/p&gt;
&lt;p&gt;The strength or usefulness of the EM method is that the likelihood of the full data (both observed data - &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;’s and &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;’s - and unobserved data - cluster probabilities) is much easier to write down and estimate than the likelihood of the observed data only (&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;’s and &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;’s). Think of the first plot above with the structure given by the colors compared to the second plot in grey without the structure. The first seems so much more manageable than the second - if only we knew the underlying structure defined by the clusters. The EM algorithm builds the underlying structure so that the maximum likelihood estimation problem becomes much easier.&lt;/p&gt;
&lt;p&gt;Here is a little more detail on what the EM algorithm is estimating in our application. (See &lt;a href=&#34;https://cran.r-project.org/web/packages/flexmix/vignettes/flexmix-intro.pdf&#34;&gt;this&lt;/a&gt; for the much more detail.) First, we estimate the probability of membership in cluster &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; for our linear regression model with three clusters:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[P_i(j|x_i, y_i, \mathbf{\pi}, \mathbf{\alpha_0}, \mathbf{\alpha_1}, \mathbf{\sigma}) = p_{ij}= \frac{\pi_jf(y_i|x_i,  \mathbf{\alpha_0}, \mathbf{\alpha_1}, \mathbf{\sigma})}{\sum_{k=1}^3 \pi_k f(y_i|x_i,  \mathbf{\alpha_0}, \mathbf{\alpha_1}, \mathbf{\sigma})},\]&lt;/span&gt; where &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{\alpha_0}\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{\alpha_1}\)&lt;/span&gt;, and &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{\sigma}\)&lt;/span&gt; are the vectors of intercepts, slopes, and standard deviations for the three clusters. &lt;span class=&#34;math inline&#34;&gt;\(\pi\)&lt;/span&gt; is the vector of probabilities that any individual is in the respective clusters, and each &lt;span class=&#34;math inline&#34;&gt;\(\pi_j\)&lt;/span&gt; is estimated by averaging the &lt;span class=&#34;math inline&#34;&gt;\(p_{ij}\)&lt;/span&gt;’s across all individuals. Finally, &lt;span class=&#34;math inline&#34;&gt;\(f(.|.)\)&lt;/span&gt; is the density from the normal distribution &lt;span class=&#34;math inline&#34;&gt;\(N(\alpha_{j0} + \alpha_{j1}x, \sigma_j^2)\)&lt;/span&gt;, with cluster-specific parameters.&lt;/p&gt;
&lt;p&gt;Second, we maximize each of the three cluster-specific log-likelihoods, where each individual is weighted by its probability of cluster membership (which is &lt;span class=&#34;math inline&#34;&gt;\(P_i(j)\)&lt;/span&gt;, estimated in the &lt;em&gt;E-step&lt;/em&gt;). In particular, we are maximizing the cluster-specific likelihood with respect to the three unknown parameters &lt;span class=&#34;math inline&#34;&gt;\(\alpha_{j0}\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(\alpha_{j1}\)&lt;/span&gt;, and &lt;span class=&#34;math inline&#34;&gt;\(\sigma_j\)&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\sum_{n=1}^N \hat{p}_{nk} \text{log} (f(y_n|x_n,\alpha_{j0},\alpha_{j1},\sigma_j)\]&lt;/span&gt; In &lt;code&gt;R&lt;/code&gt;, the &lt;code&gt;flexmix&lt;/code&gt; package has implemented an EM algorithm to estimate latent class regression models. The package documentation provides a really nice, accessible &lt;a href=&#34;https://cran.r-project.org/web/packages/flexmix/vignettes/flexmix-intro.pdf&#34;&gt;description&lt;/a&gt; of the two-step procedure, with much more detail than I have provided here. I encourage you to check it out.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;iterating-slowly-through-the-em-algorithm&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Iterating slowly through the EM algorithm&lt;/h3&gt;
&lt;p&gt;Here is a slow-motion version of the EM estimation process. I show the parameter estimates (visually) at the early stages of estimation, checking in after every three steps. In addition, I highlight two individuals and show the estimated probabilities of cluster membership. At the beginning, there is little differentiation between the regression lines for each cluster. However, by the 10th iteration the parameter estimates for the regression lines are looking pretty similar to the original plot.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(flexmix)

selectIDs &amp;lt;- c(508, 775) # select two individuals

ps &amp;lt;- list()
count &amp;lt;- 0
p.ij &amp;lt;- data.table()  # keep track of estimated probs
pi.j &amp;lt;- data.table()  # keep track of average probs

for (i in seq(1,10, by=3)) {
  
  count &amp;lt;- count + 1
  set.seed(5)
  
  # fit model up to &amp;quot;i&amp;quot; iterations - either 1, 4, 7, or 10
  
  exMax &amp;lt;- flexmix(y ~ x,
                   data = dt, k = 3,
                   control = list(iter.max = i)
  )
          
  p.ij &amp;lt;- rbind(p.ij,
                data.table(i, selectIDs, posterior(exMax)[selectIDs,]))
  pi.j &amp;lt;- rbind(pi.j,
                data.table(i, t(apply(posterior(exMax), 2, mean))))
  
  dp &amp;lt;- as.data.table(t(parameters(exMax)))
  setnames(dp, c(&amp;quot;int&amp;quot;,&amp;quot;slope&amp;quot;, &amp;quot;sigma&amp;quot;))
  
  # flexmix rearranges columns/clusters
  
  dp[, grp := c(3, 1, 2)]
  setkey(dp, grp)
  
  # create plot for each iteration
  
  ps[[count]] &amp;lt;- rawp + 
    geom_abline(data = dp, aes(intercept = int, slope = slope,  
                               color=factor(grp)), size = 1) +
    geom_point(data = dt[id %in% selectIDs], color = &amp;quot;black&amp;quot;) +
    scale_color_manual(values = mycolors)  +
    ggtitle(paste(&amp;quot;Iteration&amp;quot;, i)) +
    theme(legend.position = &amp;quot;none&amp;quot;,
          plot.title = element_text(size = 9))

  
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(gridExtra)

grid.arrange(ps[[1]], ps[[2]], ps[[3]], ps[[4]], nrow = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-09-20-simstudy-update-provides-an-excuse-to-talk-a-little-bit-about-the-em-algorithm-and-latent-class_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;864&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;For the two individuals, we can see the probabilities converging to a level of certainty/uncertainty. The individual with ID #775 lies right on the regression line for cluster 3, far from the other lines, and the algorithm quickly assigns a probability of 100% to cluster 3 (its actual cluster). The cluster assignment is less certain for ID #508, which lies between the two regression lines for clusters 1 and 2.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# actual cluster membership

dt[id %in% selectIDs, .(id, fgroup)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     id fgroup
## 1: 508      2
## 2: 775      3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;setkey(p.ij, selectIDs, i)
p.ij[, .(selectIDs, i, C1 = round(V2, 2), C2 = round(V3,2), C3 = round(V1,2))]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    selectIDs  i   C1   C2   C3
## 1:       508  1 0.32 0.36 0.32
## 2:       508  4 0.29 0.44 0.27
## 3:       508  7 0.25 0.65 0.10
## 4:       508 10 0.24 0.76 0.00
## 5:       775  1 0.35 0.28 0.37
## 6:       775  4 0.33 0.14 0.53
## 7:       775  7 0.11 0.01 0.88
## 8:       775 10 0.00 0.00 1.00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In addition, we can see how the estimate of overall group membership (for all individuals) changes through the iterations. The algorithm starts by assigning equal probability to each cluster (1/3) and slowly moves towards the actual distribution used to generate the data (20%, 50%, and 30%).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pi.j[, .(i, C1 = round(V2, 2), C2 = round(V3,2), C3 = round(V1,2))]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     i   C1   C2   C3
## 1:  1 0.33 0.34 0.33
## 2:  4 0.31 0.34 0.35
## 3:  7 0.25 0.39 0.36
## 4: 10 0.23 0.44 0.33&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;final-estimation-of-linear-models&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Final estimation of linear models&lt;/h3&gt;
&lt;p&gt;The final estimation is shown below, and we can see that the parameters have largely converged to the values used to generate the data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Estimation until convergence

set.seed(5)
ex1 &amp;lt;- flexmix(y ~ x, data = dt, k = 3)

# paramter estimates

data.table(parameters(ex1))[, .(param = c(&amp;quot;int&amp;quot;, &amp;quot;slope&amp;quot;, &amp;quot;sd&amp;quot;), 
                                C1 = round(Comp.2, 2), 
                                C2 = round(Comp.3, 2),
                                C3 = round(Comp.1, 2))]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    param   C1    C2    C3
## 1:   int 5.18  3.94  3.00
## 2: slope 1.97 -0.03 -1.99
## 3:    sd 2.07  1.83  1.55&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# estimates of cluster probabilities

round(apply(posterior(ex1), 2, mean), 2)[c(2,3,1)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.19 0.51 0.30&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# estimates of individual probabilities

data.table(posterior(exMax)[selectIDs,])[,.(selectIDs,
                                            C1 = round(V2, 2), 
                                            C2 = round(V3, 2), 
                                            C3 = round(V1, 2))]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    selectIDs   C1   C2 C3
## 1:       508 0.24 0.76  0
## 2:       775 0.00 0.00  1&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;how-do-we-know-the-relationship-is-linear&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;How do we know the relationship is linear?&lt;/h3&gt;
&lt;p&gt;In reality, there is no reason to assume that the relationship between &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; is simply linear. We might want to look at other possibilities, such as a quadratic relationship. So, we use flexmix to estimate an expanded model, and then we plot the fitted lines on the original data:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ex2 &amp;lt;- flexmix(y ~ x + I(x^2), data = dt, k = 3)
dp &amp;lt;- as.data.table(t(parameters(ex2)))
setnames(dp, c(&amp;quot;int&amp;quot;,&amp;quot;slope&amp;quot;, &amp;quot;slope2&amp;quot;, &amp;quot;sigma&amp;quot;))

dp[, grp := c(1,2,3)]

x &amp;lt;- c(seq(-10,10, by =.1))

dp1 &amp;lt;- data.table(grp = 1, x, dp[1, int + slope*x + slope2*(x^2)])
dp2 &amp;lt;- data.table(grp = 2, x, dp[2, int + slope*x + slope2*(x^2)])
dp3 &amp;lt;- data.table(grp = 3, x, dp[3, int + slope*x + slope2*(x^2)])

dp &amp;lt;- rbind(dp1, dp2, dp3)

rawp + 
  geom_line(data=dp, aes(x=x, y=V3, group = grp, color = factor(grp)), 
            size = 1) +
  scale_color_manual(values = mycolors)  +
  theme(legend.position = &amp;quot;none&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-09-20-simstudy-update-provides-an-excuse-to-talk-a-little-bit-about-the-em-algorithm-and-latent-class_files/figure-html/unnamed-chunk-11-1.png&#34; width=&#34;576&#34; /&gt;&lt;/p&gt;
&lt;p&gt;And even though the parameter estimates appear to be reasonable, we would want to compare the simple linear model with the quadratic model, which we can use with something like the BIC. We see that the linear model is a better fit (lower BIC value) - not surprising since this is how we generated the data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(refit(ex2))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $Comp.1
##              Estimate Std. Error  z value  Pr(&amp;gt;|z|)    
## (Intercept)  1.440736   0.309576   4.6539 3.257e-06 ***
## x           -0.405118   0.048808  -8.3003 &amp;lt; 2.2e-16 ***
## I(x^2)      -0.246075   0.012162 -20.2337 &amp;lt; 2.2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## $Comp.2
##             Estimate Std. Error z value  Pr(&amp;gt;|z|)    
## (Intercept) 6.955542   0.289914 23.9918 &amp;lt; 2.2e-16 ***
## x           0.305995   0.049584  6.1712 6.777e-10 ***
## I(x^2)      0.263160   0.014150 18.5983 &amp;lt; 2.2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## $Comp.3
##               Estimate Std. Error z value Pr(&amp;gt;|z|)    
## (Intercept)  3.9061090  0.1489738 26.2201  &amp;lt; 2e-16 ***
## x           -0.0681887  0.0277366 -2.4584  0.01395 *  
## I(x^2)       0.0113305  0.0060884  1.8610  0.06274 .  
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Comparison of the two models

BIC(ex1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5187.862&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;BIC(ex2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 5316.034&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Complier average causal effect? Exploring what we learn from an RCT with participants who don&#39;t do what they are told</title>
      <link>/post/cace-explored/</link>
      <pubDate>Tue, 12 Sep 2017 00:00:00 +0000</pubDate>
      <author>keith.goldfeld@nyumc.org (Keith Goldfeld)</author>
      <guid>/post/cace-explored/</guid>
      <description>&lt;p&gt;Inspired by a free online &lt;a href=&#34;https://courseplus.jhu.edu/core/index.cfm/go/course.home/coid/8155/&#34;&gt;course&lt;/a&gt; titled &lt;em&gt;Complier Average Causal Effects (CACE) Analysis&lt;/em&gt; and taught by Booil Jo and Elizabeth Stuart (through Johns Hopkins University), I’ve decided to explore the topic a little bit. My goal here isn’t to explain CACE analysis in extensive detail (you should definitely go take the course for that), but to describe the problem generally and then (of course) simulate some data. A plot of the simulated data gives a sense of what we are estimating and assuming. And I end by describing two simple methods to estimate the CACE, which we can compare to the truth (since this is a simulation); next time, I will describe a third way.&lt;/p&gt;
&lt;div id=&#34;non-compliance-in-randomized-trials&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Non-compliance in randomized trials&lt;/h3&gt;
&lt;p&gt;Here’s the problem. In a randomized trial, investigators control the randomization process; they determine if an individual is assigned to the treatment group or control group (I am talking about randomized trials here, but many of these issues can apply in the context of observed or quasi-experimental settings, but require more data and assumptions). However, those investigators may not have as much control over the actual treatments that study participants receive. For example, an individual randomized to some type of behavioral intervention may opt not to take advantage of the intervention. Likewise, someone assigned to control may, under some circumstances, figure out a way to get services that are quite similar to the intervention. In all cases, the investigator is able to collect outcome data on all of these patients, regardless of whether or not they followed directions. (This is different from drop-out or loss-to-followup, where outcome data may be missing.)&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;cace&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;CACE&lt;/h3&gt;
&lt;p&gt;Typically, studies analyze data based on treatment &lt;em&gt;assignment&lt;/em&gt; rather than treatment &lt;em&gt;received&lt;/em&gt;. This focus on assignment is called an intention-to-treat (ITT) analysis. In a policy environment, the ITT may make a lot of sense; we are answering this specific question: “What is the overall effect in the real world where the intervention is made available yet some people take advantage of it while others do not?” Alternatively, researchers may be interested in different question: “What is the causal effect of actually receiving the treatment?”&lt;/p&gt;
&lt;p&gt;Now, to answer the second question, there are numerous subtle issues that you need to wrestle with (again, go take the &lt;a href=&#34;https://courseplus.jhu.edu/core/index.cfm/go/course.home/coid/8155/&#34;&gt;course&lt;/a&gt;). But, long story short, we need to (1) identify the folks in the &lt;em&gt;intervention&lt;/em&gt; group who actually do what they have been encouraged to do (receive the intervention) but only because they were encouraged, and not because they would have received the intervention anyways had they not been randomized, and compare their outcomes with (2) the folks in the control group who did not seek out the intervention on their own initiative but would have received the intervention had they been encouraged. These two groups are considered to be &lt;em&gt;compliers&lt;/em&gt; - they would always do what they are told in the context of the study. And the effect of the intervention that is based on outcomes from this type of patient is called the &lt;em&gt;complier average causal effect&lt;/em&gt; (CACE).&lt;/p&gt;
&lt;p&gt;The biggest challenge in estimating the CACE is that we cannot actually identify if people are compliers or not. Some of those receiving the treatment in the intervention group are &lt;em&gt;compliers&lt;/em&gt;, but the rest are &lt;em&gt;always-takers&lt;/em&gt;. Some of those not receiving the treatment in the control arm are also &lt;em&gt;compliers&lt;/em&gt;, but the others are &lt;em&gt;never-takers&lt;/em&gt;. There are several methods available to overcome this challenge, two of which I will briefly mention here: method of moments and instrumental variables.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;using-potential-outcomes-to-define-cace&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Using potential outcomes to define CACE&lt;/h3&gt;
&lt;p&gt;In an earlier &lt;a href=&#34;https://www.rdatagen.net/post/be-careful/&#34;&gt;post&lt;/a&gt;, I briefly introduced the idea of potential outcomes. Since we are talking about causal relationships, they are useful here. If &lt;span class=&#34;math inline&#34;&gt;\(Z\)&lt;/span&gt; is the randomization indicator, &lt;span class=&#34;math inline&#34;&gt;\(Z=1\)&lt;/span&gt; for those randomized to the intervention, &lt;span class=&#34;math inline&#34;&gt;\(Z=0\)&lt;/span&gt; for those in control. &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; is the indicator of whether or not the individual received the intervention. Since &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; is an outcome, we can imagine the potential outcomes &lt;span class=&#34;math inline&#34;&gt;\(M_{0i}\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(M_{1i}\)&lt;/span&gt;, or what the value of &lt;span class=&#34;math inline&#34;&gt;\(M_i\)&lt;/span&gt; would be for an individual if &lt;span class=&#34;math inline&#34;&gt;\(Z_i=0\)&lt;/span&gt; or &lt;span class=&#34;math inline&#34;&gt;\(Z_i=1\)&lt;/span&gt;, respectively. And let us say &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; is the outcome, so we have potential outcomes that can be written as &lt;span class=&#34;math inline&#34;&gt;\(Y_{0,M_0}\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(Y_{1,M_1}\)&lt;/span&gt;. Think about that for a bit.&lt;/p&gt;
&lt;p&gt;Using these potential outcomes, we can define the compliers and the CACE. Compliers are people for whom &lt;span class=&#34;math inline&#34;&gt;\(M_0 = 0\)&lt;/span&gt; &lt;em&gt;and&lt;/em&gt; &lt;span class=&#34;math inline&#34;&gt;\(M_1 = 1\)&lt;/span&gt;. (Never-takers look like this: &lt;span class=&#34;math inline&#34;&gt;\(M_0 = 0\)&lt;/span&gt; &lt;em&gt;and&lt;/em&gt; &lt;span class=&#34;math inline&#34;&gt;\(M_1 = 0\)&lt;/span&gt;. Always-takers: &lt;span class=&#34;math inline&#34;&gt;\(M_0 = 1\)&lt;/span&gt; &lt;em&gt;and&lt;/em&gt; &lt;span class=&#34;math inline&#34;&gt;\(M_1 = 1\)&lt;/span&gt;). Now, the average causal effect is the average difference between potential outcomes. In this case, the CACE is &lt;span class=&#34;math inline&#34;&gt;\(E[Y_{1,M_1} - Y_{0,M_0}|M_0 = 0 \ \&amp;amp; \ M_1 = 1]\)&lt;/span&gt;. The patients for whom &lt;span class=&#34;math inline&#34;&gt;\(M_0 = 0\)&lt;/span&gt; &lt;em&gt;and&lt;/em&gt; &lt;span class=&#34;math inline&#34;&gt;\(M_1 = 1\)&lt;/span&gt; are the compliers.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;simulating-data&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Simulating data&lt;/h3&gt;
&lt;p&gt;The data simulation will be based on generating potential outcomes. Observed outcomes will be a function of randomization group and complier status.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;options(digits = 3)

library(data.table)
library(simstudy)
library(ggplot2)

# Status :

# 1 = A(lways taker)
# 2 = N(ever taker)
# 3 = C(omplier)

def &amp;lt;- defDataAdd(varname = &amp;quot;Status&amp;quot;, 
               formula = &amp;quot;0.20; 0.40; 0.40&amp;quot;, dist = &amp;quot;categorical&amp;quot;)

# potential outcomes (PO) for intervention 

def &amp;lt;- defDataAdd(def, varname = &amp;quot;M0&amp;quot;, 
               formula = &amp;quot;(Status == 1) * 1&amp;quot;, dist = &amp;quot;nonrandom&amp;quot;)
def &amp;lt;- defDataAdd(def, varname = &amp;quot;M1&amp;quot;, 
               formula = &amp;quot;(Status != 2) * 1&amp;quot;, dist = &amp;quot;nonrandom&amp;quot;)

# observed intervention status based on randomization and PO

def &amp;lt;- defDataAdd(def, varname = &amp;quot;m&amp;quot;, 
               formula = &amp;quot;(z==0) * M0 + (z==1) * M1&amp;quot;, dist = &amp;quot;nonrandom&amp;quot;)

# potential outcome for Y (depends on potential outcome for M)

set.seed(888)

dt &amp;lt;- genData(2000)
dt &amp;lt;- trtAssign(dt, n=2, grpName = &amp;quot;z&amp;quot;)

dt &amp;lt;- addColumns(def, dt)

# using data functions here, not simstudy - I need add
# this functionality to simstudy

dt[, AStatus := factor(Status, 
          labels = c(&amp;quot;Always-taker&amp;quot;,&amp;quot;Never-taker&amp;quot;, &amp;quot;Complier&amp;quot;))]

# potential outcomes depend on group status - A, N, or C

dt[Status == 1, Y0 := rnorm(.N, 1.0, sqrt(0.25))]
dt[Status == 2, Y0 := rnorm(.N, 0.0, sqrt(0.36))]
dt[Status == 3, Y0 := rnorm(.N, 0.1, sqrt(0.16))]
  
dt[Status == 1, Y1 := rnorm(.N, 1.0, sqrt(0.25))]
dt[Status == 2, Y1 := rnorm(.N, 0.0, sqrt(0.36))]
dt[Status == 3, Y1 := rnorm(.N, 0.9, sqrt(0.49))]

# observed outcome function of actual treatment

dt[, y := (m == 0) * Y0 + (m == 1) * Y1]

dt&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         id z Status M0 M1 m      AStatus      Y0    Y1       y
##    1:    1 1      3  0  1 1     Complier  0.5088 0.650  0.6500
##    2:    2 1      3  0  1 1     Complier  0.1503 0.729  0.7292
##    3:    3 1      2  0  0 0  Never-taker  1.4277 0.454  1.4277
##    4:    4 0      3  0  1 0     Complier  0.6393 0.998  0.6393
##    5:    5 0      1  1  1 1 Always-taker  0.6506 1.927  1.9267
##   ---                                                         
## 1996: 1996 0      3  0  1 0     Complier -0.9554 0.114 -0.9554
## 1997: 1997 0      3  0  1 0     Complier  0.0366 0.903  0.0366
## 1998: 1998 1      3  0  1 1     Complier  0.3606 1.098  1.0982
## 1999: 1999 1      3  0  1 1     Complier  0.6651 1.708  1.7082
## 2000: 2000 0      3  0  1 0     Complier  0.2207 0.531  0.2207&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The plot shows outcomes &lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt; for the two randomization groups. The ITT estimate would be based on an average of all the points in group, regardless of color or shape. The difference between the average of the black circles in the two groups represents the CACE.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(data=dt, aes(y=y, x = factor(z, labels = c(&amp;quot;Assigned to control&amp;quot;,
                                                  &amp;quot;Assigned to treatment&amp;quot;)))) +
  geom_jitter(aes(shape=factor(m, labels = c(&amp;quot;No treatment&amp;quot;, &amp;quot;Treatment&amp;quot;)),
                  color=AStatus),
              width = 0.35) +
  scale_shape_manual(values = c(1,19)) +
  scale_color_manual(values = c(&amp;quot;#e1d07d&amp;quot;, &amp;quot;#7d8ee1&amp;quot;,  &amp;quot;grey25&amp;quot;)) +
  scale_y_continuous(breaks = seq(-3, 3, 1), labels = seq(-3, 3, 1)) +
  theme(legend.title = element_blank(),
        axis.title.x = element_blank(),
        panel.grid.minor.y = element_blank(),
        panel.grid.major.x = element_blank())&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-09-08-iv-em-two-important-ideas-explored_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;In the real world, we cannot see the colors, yet we need to estimate as if we do, or at least use a method to bypasses that need:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-09-08-iv-em-two-important-ideas-explored_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;estimating-cace-using-observed-data&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Estimating CACE using observed data&lt;/h3&gt;
&lt;p&gt;The challenge is to estimate the CACE using &lt;em&gt;observed&lt;/em&gt; data only, since that is all we have (along with a couple of key assumptions). We start of by claiming that the average causal effect of treatment &lt;strong&gt;assignment&lt;/strong&gt; (&lt;span class=&#34;math inline&#34;&gt;\(ACE\)&lt;/span&gt;) is a weighted average of the three sub-populations of &lt;em&gt;compliers&lt;/em&gt;, &lt;em&gt;never-takers&lt;/em&gt;, and &lt;em&gt;always-takers&lt;/em&gt;:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ ACE = \pi_C \times CACE + \pi_N \times NACE + \pi_A \times AACE, \]&lt;/span&gt; where &lt;span class=&#34;math inline&#34;&gt;\(CACE\)&lt;/span&gt; is the average causal effect of treatment assignment for the subset of those in the sample who are &lt;em&gt;compliers&lt;/em&gt;, &lt;span class=&#34;math inline&#34;&gt;\(NACE\)&lt;/span&gt; is the average causal effect of treatment assignment for the subset who are &lt;em&gt;never-takers&lt;/em&gt;, and &lt;span class=&#34;math inline&#34;&gt;\(AACE\)&lt;/span&gt; is the average causal effect for those who are &lt;em&gt;always-takers&lt;/em&gt;. &lt;span class=&#34;math inline&#34;&gt;\(\pi_C\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(\pi_N\)&lt;/span&gt;, and &lt;span class=&#34;math inline&#34;&gt;\(\pi_A\)&lt;/span&gt; represent the sample proportions of compliers, never-takers, and always-takers, respectively.&lt;/p&gt;
&lt;p&gt;A key assumption often made to estimate &lt;span class=&#34;math inline&#34;&gt;\(CACE\)&lt;/span&gt; is known as the &lt;em&gt;exclusion restriction&lt;/em&gt;: treatment assignment has an effect on the outcome &lt;em&gt;only&lt;/em&gt; if it changes the actual treatment taken. (A second key assumption is that there are no &lt;em&gt;deniers&lt;/em&gt;, or folks who do the opposite of what they are told. This is called the monotonicity assumption.) This &lt;em&gt;exclusion restriction&lt;/em&gt; implies that both &lt;span class=&#34;math inline&#34;&gt;\(NACE=0\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(AACE=0\)&lt;/span&gt;, since in both cases the treatment &lt;em&gt;received&lt;/em&gt; is the same regardless of treatment assignment. In that case, we can re-write the equality as&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ ACE = \pi_C \times CACE,\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;and finally with a little re-arranging,&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ CACE = \frac{ACE}{\pi_C}. \]&lt;/span&gt; So, in order estimate &lt;span class=&#34;math inline&#34;&gt;\(CACE\)&lt;/span&gt;, we need to be able to estimate &lt;span class=&#34;math inline&#34;&gt;\(ACE\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\pi_C\)&lt;/span&gt;. Fortunately, we are in a position to do this. Since this is a randomized trial, the average causal effect of treatment assignment is just the difference in observed outcomes for the two treatment assignment groups:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ ACE = E[Y | Z = 1] - E[Y | Z = 0] \]&lt;/span&gt; This also happens to be the &lt;em&gt;intention-to-treat&lt;/em&gt; ) (&lt;span class=&#34;math inline&#34;&gt;\(ITT\)&lt;/span&gt;) estimate.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(\pi_C\)&lt;/span&gt; is a little harder, but in this simplified scenario, not that hard. We just need to follow a little logic: for the control group, we can identify the &lt;em&gt;always-takers&lt;/em&gt; (they’re the ones who actually receive the treatment), so we know &lt;span class=&#34;math inline&#34;&gt;\(\pi_A\)&lt;/span&gt; for the the control group. This can be estimated as &lt;span class=&#34;math inline&#34;&gt;\(P(M=1|Z=0)\)&lt;/span&gt;. And, since the study was randomized, the distribution of &lt;em&gt;always-takers&lt;/em&gt; in the treatment group must be the same. So, we can use &lt;span class=&#34;math inline&#34;&gt;\(\pi_A\)&lt;/span&gt; estimated from the control group as an estimate for the treatment group.&lt;/p&gt;
&lt;p&gt;For the treatment group, we know that &lt;span class=&#34;math inline&#34;&gt;\(\pi_C + \pi_A = P(M = 1 | Z = 1)\)&lt;/span&gt;. That is everyone who receives treatment in the treatment group is either a complier or always-taker. With this, we can say&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\pi_C  = P(M=1 | Z = 1) - \pi_A.\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;But, of course, we argued above that we can estimate &lt;span class=&#34;math inline&#34;&gt;\(\pi_A\)&lt;/span&gt; as &lt;span class=&#34;math inline&#34;&gt;\(P(M=1|Z=0)\)&lt;/span&gt;. So, finally, we have&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\pi_C  = P(M=1 | Z = 1) - P(M=1|Z=0).\]&lt;/span&gt; This gives us a method of moments estimator for &lt;span class=&#34;math inline&#34;&gt;\(CACE\)&lt;/span&gt; from observed data:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ CACE = \frac{ACE}{\pi_C} = \frac{E[Y | Z = 1] - E[Y | Z = 0]}{P(M=1 | Z = 1) - P(M=1|Z=0)}. \]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-simulated-estimate&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The simulated estimate&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ACE &amp;lt;- dt[z==1, mean(y)] - dt[z==0, mean(y)]   # Also ITT
ACE&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.307&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pi_C &amp;lt;- dt[z==1, mean(m)] - dt[z==0, mean(m)]  # strength of instrument
pi_C&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.372&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;truth &amp;lt;- dt[AStatus == &amp;quot;Complier&amp;quot;, mean(Y1 - Y0)]
truth&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.81&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ACE/pi_C&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.826&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A method quite commonly used to analyze non-compliance is the instrumental variable model estimated with two-staged least squares regression. The R package &lt;code&gt;ivpack&lt;/code&gt; is one of several that facilitates this type of analysis. A discussio of this methodology far exceeds the scope of this post. In any case, we can see that in this simple example, the IV estimate is the same as the method of moments estimator (by looking at the coefficient estimate of &lt;code&gt;m&lt;/code&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ivpack)

ivmodel &amp;lt;- ivreg(formula = y ~ m | z, data = dt, x = TRUE)
summary(ivmodel)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## ivreg(formula = y ~ m | z, data = dt, x = TRUE)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -2.19539 -0.36249  0.00248  0.35859  2.27902 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&amp;gt;|t|)    
## (Intercept)   0.0932     0.0302    3.09    0.002 ** 
## m             0.8262     0.0684   12.08   &amp;lt;2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Residual standard error: 0.569 on 1998 degrees of freedom
## Multiple R-Squared: 0.383,   Adjusted R-squared: 0.383 
## Wald test:  146 on 1 and 1998 DF,  p-value: &amp;lt;2e-16&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, again, if I have piqued your interest of this very rich and interesting topic, or if I have totally confused you, go check out the &lt;a href=&#34;https://courseplus.jhu.edu/core/index.cfm/go/course.home/coid/8155/&#34;&gt;course&lt;/a&gt;. In my next post, I will describe a simple latent variable model using a maximum likelihood EM (expectation-maximization) algorithm that arrives at an estimate by predicting complier status.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Further considerations of a hidden process underlying categorical responses</title>
      <link>/post/a-hidden-process-part-2-of-2/</link>
      <pubDate>Tue, 05 Sep 2017 00:00:00 +0000</pubDate>
      <author>keith.goldfeld@nyumc.org (Keith Goldfeld)</author>
      <guid>/post/a-hidden-process-part-2-of-2/</guid>
      <description>&lt;p&gt;In my &lt;a href=&#34;https://www.rdatagen.net/post/ordinal-regression/&#34;&gt;previous post&lt;/a&gt;, I described a continuous data generating process that can be used to generate discrete, categorical outcomes. In that post, I focused largely on binary outcomes and simple logistic regression just because things are always easier to follow when there are fewer moving parts. Here, I am going to focus on a situation where we have &lt;em&gt;multiple&lt;/em&gt; outcomes, but with a slight twist - these groups of interest can be interpreted in an ordered way. This conceptual latent process can provide another perspective on the models that are typically applied to analyze these types of outcomes.&lt;/p&gt;
&lt;div id=&#34;categorical-outcomes-generally&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Categorical outcomes, generally&lt;/h3&gt;
&lt;p&gt;Certainly, group membership is not necessarily intrinsically ordered. In a general categorical or multinomial outcome, a group does not necessarily have any quantitative relationship vis a vis the other groups. For example, if we were interested in primary type of meat consumption, individuals might be grouped into those favoring (1) chicken, (2) beef, (3) pork, or (4) no meat. We might be interested in estimating the different distributions across the four groups for males and females. However, since there is no natural ranking or ordering of these meat groups (though maybe I am just not creative enough), we are limited to comparing the odds of being in one group relative to another for two exposure groups A and B, such as&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\small{\frac{P(Beef|Group = A)}{P(Chicken|Group = A)} \ vs. \frac{P(Beef|Group = B)}{P(Chicken|Group = B)}}\]&lt;/span&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;ordinal-outcomes&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Ordinal outcomes&lt;/h3&gt;
&lt;p&gt;Order becomes relevant when the categories take on meanings related strength of opinion or agreement (as in a Likert-type response) or frequency. In the motivating example I described in the initial post, the response of interest was the frequency meat consumption in a month, so the response categories could be (1) none, (2) 1-3 times per month, (3) once per week, (4) 2-6 times per week, (5) 1 or more times per day. Individuals in group 2 consume meat more frequently than group 1, individuals in group 3 consume meat more frequently than those both groups 1 &amp;amp; 2, and so on. There is a natural quantitative relationship between the groups.&lt;/p&gt;
&lt;p&gt;Once we have thrown ordering into the mix, we can expand our possible interpretations of the data. In particular it is quite common to summarize the data by looking at &lt;em&gt;cumulative&lt;/em&gt; probabilities, odds, or log-odds. Comparisons of different exposures or individual characteristics typically look at how these cumulative measures vary across the different exposures or characteristics. So, if we were interested in cumulative odds, we would compare &lt;span class=&#34;math display&#34;&gt;\[\small{\frac{P(Response = 1|Group = A)}{P(Response &amp;gt; 1|Group = A)} \ \ vs. \ \frac{P(Response = 1|Group = B)}{P(Response &amp;gt; 1|Group = B)}},\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\small{\frac{P(Response \leq 2|Group = A)}{P(Response &amp;gt; 2|Group = A)} \ \ vs. \ \frac{P(Response \leq 2|Group = B)}{P(Response &amp;gt; 2|Group = B)}},\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;and continue until the last (in this case, fourth) comparison&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\small{\frac{P(Response \leq 4|Group = A)}{P(Response = 5|Group = A)} \ \  vs. \ \frac{P(Response \leq 4|Group = B)}{P(Response = 5|Group = B)}}.\]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;multiple-responses-multiple-thresholds&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Multiple responses, multiple thresholds&lt;/h3&gt;
&lt;p&gt;The latent process that was described for the binary outcome is extended to the multinomial outcome by the addition of more thresholds. These thresholds define the portions of the density that define the probability of each possible response. If there are &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; possible responses (in the meat example, we have 5), then there will be &lt;span class=&#34;math inline&#34;&gt;\(k-1\)&lt;/span&gt; thresholds. The area under the logistic density curve of each of the regions defined by those thresholds (there will be &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; distinct regions) represents the probability of each possible response tied to that region. In the example here, we define five regions of a logistic density by setting the four thresholds. We can say that this underlying continuous distribution represents the probability distribution of categorical responses for a specific population, which we are calling &lt;em&gt;Group A&lt;/em&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# preliminary libraries and plotting defaults

library(ggplot2)
library(data.table)

my_theme &amp;lt;- function() {
  theme(panel.background = element_rect(fill = &amp;quot;grey90&amp;quot;), 
        panel.grid = element_blank(), 
        axis.ticks = element_line(colour = &amp;quot;black&amp;quot;), 
        panel.spacing = unit(0.25, &amp;quot;lines&amp;quot;), 
        plot.title = element_text(size = 12, vjust = 0.5, hjust = 0), 
        panel.border = element_rect(fill = NA, colour = &amp;quot;gray90&amp;quot;))
}

# create data points density curve 

x &amp;lt;- seq(-6, 6, length = 1000)
pdf &amp;lt;- dlogis(x, location = 0, scale = 1)
dt &amp;lt;- data.table(x, pdf)

# set thresholds for Group A

thresholdA &amp;lt;- c(-2.1, -0.3, 1.4, 3.6)

pdf &amp;lt;- dlogis(thresholdA)
grpA &amp;lt;- data.table(threshold = thresholdA, pdf)
aBreaks &amp;lt;- c(-6, grpA$threshold, 6)

# plot density with cutpoints

dt[, grpA := cut(x, breaks = aBreaks, labels = F, include.lowest = TRUE)]

p1 &amp;lt;- ggplot(data = dt, aes(x = x, y = pdf)) +
  geom_line() +
  geom_area(aes(x = x, y = pdf, group = grpA, fill = factor(grpA))) +
  geom_hline(yintercept = 0, color = &amp;quot;grey50&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, x = -5, y = .28, label = &amp;quot;Group A&amp;quot;, size = 5) +
  scale_fill_manual(values = c(&amp;quot;#d0d7d1&amp;quot;, &amp;quot;#bbc5bc&amp;quot;, &amp;quot;#a6b3a7&amp;quot;, &amp;quot;#91a192&amp;quot;, &amp;quot;#7c8f7d&amp;quot;),
                    labels = c(&amp;quot;None&amp;quot;, &amp;quot;1-3/month&amp;quot;, &amp;quot;1/week&amp;quot;, &amp;quot;2-6/week&amp;quot;, &amp;quot;1+/day&amp;quot;),
                    name = &amp;quot;Frequency&amp;quot;) +
  scale_x_continuous(breaks = thresholdA) +
  scale_y_continuous(limits = c(0, 0.3), name = &amp;quot;Density&amp;quot;) +
  my_theme() +
  theme(legend.position = c(.85, .7),
        legend.background = element_rect(fill = &amp;quot;grey90&amp;quot;),
        legend.key = element_rect(color = &amp;quot;grey90&amp;quot;))

p1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-09-04-a-hidden-process-part-2-of-2_files/figure-html/threshold-1.png&#34; width=&#34;480&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The area for each of the five regions can easily be calculated, where each area represents the probability of each response:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pA= plogis(c(thresholdA, Inf)) - plogis(c(-Inf, thresholdA))
probs &amp;lt;- data.frame(pA)
rownames(probs) &amp;lt;- c(&amp;quot;P(Resp = 1)&amp;quot;, &amp;quot;P(Resp = 2)&amp;quot;, 
                     &amp;quot;P(Resp = 3)&amp;quot;, &amp;quot;P(Resp = 4)&amp;quot;, &amp;quot;P(Resp = 5)&amp;quot;)
probs&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                pA
## P(Resp = 1) 0.109
## P(Resp = 2) 0.316
## P(Resp = 3) 0.377
## P(Resp = 4) 0.171
## P(Resp = 5) 0.027&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As I’ve already mentioned, when we characterize a multinomial response, we typically do so in terms of cumulative probabilities. I’ve calculated several quantities below, and we can see that the logs of the cumulative odds for this particular group are indeed the threshold values that we used to define the sub-regions.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# cumulative probabilities defined by the threshold

probA &amp;lt;- data.frame(
           cprob = plogis(thresholdA), 
           codds = plogis(thresholdA)/(1-plogis(thresholdA)),
           lcodds = log(plogis(thresholdA)/(1-plogis(thresholdA)))
)
rownames(probA) &amp;lt;- c(&amp;quot;P(Grp &amp;lt; 2)&amp;quot;, &amp;quot;P(Grp &amp;lt; 3)&amp;quot;, &amp;quot;P(Grp &amp;lt; 4)&amp;quot;, &amp;quot;P(Grp &amp;lt; 5)&amp;quot;)
probA&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##            cprob codds lcodds
## P(Grp &amp;lt; 2)  0.11  0.12   -2.1
## P(Grp &amp;lt; 3)  0.43  0.74   -0.3
## P(Grp &amp;lt; 4)  0.80  4.06    1.4
## P(Grp &amp;lt; 5)  0.97 36.60    3.6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The last column of the table below matches the thresholds defined in vector &lt;code&gt;thresholdA&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;thresholdA&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -2.1 -0.3  1.4  3.6&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;comparing-response-distributions-of-different-populations&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Comparing response distributions of different populations&lt;/h3&gt;
&lt;p&gt;In the cumulative logit model, the underlying assumption is that the odds ratio of one population relative to another is constant across all the possible responses. This means that all of the cumulative odds ratios are equal:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\small{\frac{codds(P(Resp = 1 | A))}{codds(P(Resp = 1 | B))} = \frac{codds(P(Resp \leq 2 | A))}{codds(P(Resp \leq 2 | B))} = \ ... \ = \frac{codds(P(Resp \leq 4 | A))}{codds(P(Resp \leq 4 | B))}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;In terms of the underlying process, this means that each of the thresholds shifts the same amount, as shown below, where we add 1.1 units to each threshold that was set Group A:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Group B threshold is an additive shift to the right

thresholdB &amp;lt;- thresholdA + 1.1

pdf &amp;lt;- dlogis(thresholdB)
grpB &amp;lt;- data.table(threshold = thresholdB, pdf)
bBreaks &amp;lt;- c(-6, grpB$threshold, 6)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Based on this shift, we can see that the probability distribution for Group B is quite different:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pB = plogis(c(thresholdB, Inf)) - plogis(c(-Inf, thresholdB))
probs &amp;lt;- data.frame(pA, pB)
rownames(probs) &amp;lt;- c(&amp;quot;P(Resp = 1)&amp;quot;, &amp;quot;P(Resp = 2)&amp;quot;, 
                     &amp;quot;P(Resp = 3)&amp;quot;, &amp;quot;P(Resp = 4)&amp;quot;, &amp;quot;P(Resp = 5)&amp;quot;)
probs&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                pA    pB
## P(Resp = 1) 0.109 0.269
## P(Resp = 2) 0.316 0.421
## P(Resp = 3) 0.377 0.234
## P(Resp = 4) 0.171 0.067
## P(Resp = 5) 0.027 0.009&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Plotting Group B along with Group A, we can see visually how that shift affects the sizes of the five regions (I’ve left the thresholds of Group A in the Group B plot so you can see clearly the shift).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Plot density for group B

dt[, grpB := cut(x, breaks = bBreaks, labels = F, include.lowest = TRUE)]

p2 &amp;lt;- ggplot(data = dt, aes(x = x, y = pdf)) +
  geom_line() +
  geom_area(aes(x = x, y = pdf, group = grpB, fill = factor(grpB))) +
  geom_hline(yintercept = 0, color = &amp;quot;grey5&amp;quot;) +
  geom_segment(data=grpA, 
               aes(x=threshold, xend = threshold, y=0, yend=pdf), 
               size = 0.3, lty = 2, color = &amp;quot;#857284&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, x = -5, y = .28, label = &amp;quot;Group B&amp;quot;, size = 5) +
  scale_fill_manual(values = c(&amp;quot;#d0d7d1&amp;quot;, &amp;quot;#bbc5bc&amp;quot;, &amp;quot;#a6b3a7&amp;quot;, &amp;quot;#91a192&amp;quot;, &amp;quot;#7c8f7d&amp;quot;),
                    labels = c(&amp;quot;None&amp;quot;, &amp;quot;1-3/month&amp;quot;, &amp;quot;1/week&amp;quot;, &amp;quot;2-6/week&amp;quot;, &amp;quot;1+/day&amp;quot;),
                    name = &amp;quot;Frequency&amp;quot;) +
  scale_x_continuous(breaks = thresholdB) +
  scale_y_continuous(limits = c(0.0, 0.3), name = &amp;quot;Density&amp;quot;) +
  my_theme() +
  theme(legend.position = &amp;quot;none&amp;quot;)

library(gridExtra)
grid.arrange(p1, p2, nrow = 2 )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-09-04-a-hidden-process-part-2-of-2_files/figure-html/plotB-1.png&#34; width=&#34;480&#34; /&gt;&lt;/p&gt;
&lt;p&gt;When we look at the cumulative odds ratio comparing the odds of Group B to Group A for each response category, we see a constant ratio. And, of course, a constant log odds ratio, which also reflects the size of the shift from Group A to Group B.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# cumulative probabilities defined by the threshold

probB &amp;lt;- data.frame(
           cprob = plogis(thresholdB),
           codds = plogis(thresholdB)/(1-plogis(thresholdB)), 
           lcodds = log(plogis(thresholdB)/(1-plogis(thresholdB)))
)

oddsratio &amp;lt;- data.frame(coddsA = probA$codds, 
                        coddsB = probB$codds,
                        cOR = probB$codds / probA$codds,
                        logcOR = log(probB$codds / probA$codds)
)

rownames(oddsratio) &amp;lt;- c(&amp;quot;P(Grp &amp;lt; 2)&amp;quot;, &amp;quot;P(Grp &amp;lt; 3)&amp;quot;, &amp;quot;P(Grp &amp;lt; 4)&amp;quot;, &amp;quot;P(Grp &amp;lt; 5)&amp;quot;)

oddsratio&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##            coddsA coddsB cOR logcOR
## P(Grp &amp;lt; 2)   0.12   0.37   3    1.1
## P(Grp &amp;lt; 3)   0.74   2.23   3    1.1
## P(Grp &amp;lt; 4)   4.06  12.18   3    1.1
## P(Grp &amp;lt; 5)  36.60 109.95   3    1.1&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;the-cumulative-proportional-odds-model&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;The cumulative proportional odds model&lt;/h3&gt;
&lt;p&gt;In the &lt;code&gt;R&lt;/code&gt; package &lt;code&gt;ordinal&lt;/code&gt;, the model is fit using function &lt;code&gt;clm&lt;/code&gt;. The model that is being estimated has the form&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[log \left( \frac{P(Resp \leq  i)}{P(Resp &amp;gt; i)} | Group \right) = \alpha_i - \beta*I(Group=B) \  \ , \ i \in \{1, 2, 3, 4\}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The model specifies that the cumulative log-odds for a particular category is a function of two parameters, &lt;span class=&#34;math inline&#34;&gt;\(\alpha_i\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;. (Note that in this parameterization and the model fit, &lt;span class=&#34;math inline&#34;&gt;\(-\beta\)&lt;/span&gt; is used.) &lt;span class=&#34;math inline&#34;&gt;\(\alpha_i\)&lt;/span&gt; represents the cumulative log odds of being in category &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; or lower for those in the reference exposure group, which in our example is Group A. &lt;em&gt;&lt;span class=&#34;math inline&#34;&gt;\(\alpha_i\)&lt;/span&gt; also represents the threshold of the latent continuous (logistic) data generating process.&lt;/em&gt; &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt; is the cumulative log-odds ratio for the category &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; comparing Group B to reference Group A. &lt;em&gt;&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt; also represents the shift of the threshold on the latent continuous process for Group B relative to Group A&lt;/em&gt;. The proportionality assumption implies that the shift of the threshold for each of the categories is identical. This is what I illustrated above.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;simulation-and-model-fit&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Simulation and model fit&lt;/h3&gt;
&lt;p&gt;To show how this process might actually work, I am simulating data from the standardized logistic distribution and applying the thresholds defined above based on the group status. In practice, each individual could have her own set of thresholds, depending on her characteristics (gender, age, etc.). In this case, group membership is the only characteristic I am using, so all individuals in a particular group share the same set of thresholds. (We could even have random effects, where subgroups have random shifts that are subgroup specific. In the addendum, following the main part of the post, I provide code to generate data from a mixed effects model with group level random effects plus fixed effects for exposure, gender, and a continuous outcome.)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(123)
n = 1000
x.A &amp;lt;- rlogis(n)
acuts &amp;lt;- c(-Inf, thresholdA, Inf)

catA &amp;lt;- cut(x.A, breaks = acuts, label = F)
dtA &amp;lt;- data.table(id = 1:n, grp = &amp;quot;A&amp;quot;, cat = catA)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Not surprisingly (since we are using a generous sample size of 1000), the simulated proportions are quite close to the hypothetical proportions established by the thresholds:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cumsum(prop.table(table(catA)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    1    2    3    4    5 
## 0.11 0.44 0.81 0.97 1.00&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;probA$cprob&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.11 0.43 0.80 0.97&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we generate a sample from Group B and combine them into a single data set:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x.B &amp;lt;- rlogis(n)
bcuts &amp;lt;- c(-Inf, thresholdA + 1.1, Inf)

catB &amp;lt;- cut(x.B, breaks = bcuts, label = F)
dtB &amp;lt;- data.table(id = (n+1):(2*n), grp = &amp;quot;B&amp;quot;, cat=catB)

dt &amp;lt;- rbind(dtA, dtB)
dt[, cat := factor(cat, labels = c(&amp;quot;None&amp;quot;, &amp;quot;1-3/month&amp;quot;, &amp;quot;1/week&amp;quot;, &amp;quot;2-6/week&amp;quot;, &amp;quot;1+/day&amp;quot;))]

dt&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         id grp       cat
##    1:    1   A 1-3/month
##    2:    2   A    1/week
##    3:    3   A 1-3/month
##    4:    4   A  2-6/week
##    5:    5   A  2-6/week
##   ---                   
## 1996: 1996   B    1/week
## 1997: 1997   B 1-3/month
## 1998: 1998   B    1/week
## 1999: 1999   B 1-3/month
## 2000: 2000   B 1-3/month&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we estimate the parameters of the model using function &lt;code&gt;clm&lt;/code&gt; and we see that we recover the original parameters quite well.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ordinal)
clmFit &amp;lt;- clm(cat ~ grp, data = dt)
summary(clmFit)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## formula: cat ~ grp
## data:    dt
## 
##  link  threshold nobs logLik   AIC     niter max.grad cond.H 
##  logit flexible  2000 -2655.03 5320.05 6(0)  1.19e-11 2.3e+01
## 
## Coefficients:
##      Estimate Std. Error z value Pr(&amp;gt;|z|)    
## grpB  -1.0745     0.0848   -12.7   &amp;lt;2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Threshold coefficients:
##                  Estimate Std. Error z value
## None|1-3/month    -2.0912     0.0784  -26.68
## 1-3/month|1/week  -0.2465     0.0612   -4.02
## 1/week|2-6/week    1.4212     0.0728   19.51
## 2-6/week|1+/day    3.5150     0.1643   21.39&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the model output, the &lt;code&gt;grpB&lt;/code&gt; coefficient of -1.07 is the estimate of &lt;span class=&#34;math inline&#34;&gt;\(-\beta\)&lt;/span&gt;, which was set to 1.1 in the simulation. The threshold coefficients are the estimates of the &lt;span class=&#34;math inline&#34;&gt;\(\alpha_i\)&lt;/span&gt;’s in the model, and we can see the estimates are not too bad by looking at the initial thresholds:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;coeffit &amp;lt;- coef(clmFit)[1:4]
names(coeffit) &amp;lt;- c(1:4)

rbind( thresholdA, coeffit)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##               1     2   3   4
## thresholdA -2.1 -0.30 1.4 3.6
## coeffit    -2.1 -0.25 1.4 3.5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This was a relatively simple simulation. However it highlights how it would be possible to generate more complex scenarios of multinomial response data to more fully explore other types of models. These more flexible models might be able to handle situations where the possibly restrictive assumptions of this model (particularly the proportional odds assumption) do not hold.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;addendum-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Addendum 1&lt;/h2&gt;
&lt;p&gt;Here is code to generate cluster-randomized data with an ordinal outcome that is a function of treatment assignment, gender, and a continuous status measure at the individual level. There is also a group level random effect. Once the data are generated, I fit a mixed cumulative logit model.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(simstudy)

# define data

defSchool &amp;lt;- defData(varname = &amp;quot;reS&amp;quot;, formula = 0, 
                     variance = 0.10, id = &amp;quot;idS&amp;quot;)
defSchool &amp;lt;- defData(defSchool, varname = &amp;quot;n&amp;quot;, 
                     formula = 250, dist = &amp;quot;noZeroPoisson&amp;quot;)

defInd &amp;lt;- defDataAdd(varname = &amp;quot;male&amp;quot;, formula = 0.45, dist = &amp;quot;binary&amp;quot;)
defInd &amp;lt;- defDataAdd(defInd, varname = &amp;quot;status&amp;quot;, 
                     formula = 0, variance = 1, dist = &amp;quot;normal&amp;quot;)
defInd &amp;lt;- defDataAdd(defInd, 
                varname = &amp;quot;z&amp;quot;, 
                formula = &amp;quot;0.8 * grp + 0.3 * male - 0.2 * status + reS&amp;quot;, 
                dist = &amp;quot;nonrandom&amp;quot;)

# generate data

dtS &amp;lt;- genData(100, defSchool)
dtS &amp;lt;- trtAssign(dtS, grpName = &amp;quot;grp&amp;quot;)

dt &amp;lt;- genCluster(dtS, &amp;quot;idS&amp;quot;, &amp;quot;n&amp;quot;, &amp;quot;id&amp;quot;)
dt &amp;lt;- addColumns(defInd, dt)

# set reference probabilities for 4-category outcome

probs &amp;lt;- c(0.35, 0.30, 0.25, 0.10)
cprop &amp;lt;- cumsum(probs)

# map cumulative probs to thresholds for reference group

gamma.c &amp;lt;- qlogis(cprop)
matlp &amp;lt;- matrix(rep(gamma.c, nrow(dt)), 
                ncol = length(cprop), 
                byrow = TRUE
)

head(matlp)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       [,1] [,2] [,3] [,4]
## [1,] -0.62 0.62  2.2  Inf
## [2,] -0.62 0.62  2.2  Inf
## [3,] -0.62 0.62  2.2  Inf
## [4,] -0.62 0.62  2.2  Inf
## [5,] -0.62 0.62  2.2  Inf
## [6,] -0.62 0.62  2.2  Inf&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# set individual thresholds based on covariates,
# which is an additive shift from the reference group
# based on z

matlpInd &amp;lt;- matlp - dt[, z]
head(matlpInd)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       [,1]  [,2] [,3] [,4]
## [1,] -1.52 -0.28  1.3  Inf
## [2,] -1.58 -0.34  1.2  Inf
## [3,] -0.95  0.29  1.9  Inf
## [4,] -1.53 -0.29  1.3  Inf
## [5,] -1.49 -0.25  1.3  Inf
## [6,] -1.13  0.11  1.7  Inf&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# convert log odds to cumulative probabability

matcump &amp;lt;- 1 / (1 + exp(-matlpInd))
matcump &amp;lt;- cbind(0, matcump)
head(matcump)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4] [,5]
## [1,]    0 0.18 0.43 0.78    1
## [2,]    0 0.17 0.42 0.78    1
## [3,]    0 0.28 0.57 0.87    1
## [4,]    0 0.18 0.43 0.78    1
## [5,]    0 0.18 0.44 0.79    1
## [6,]    0 0.24 0.53 0.84    1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# convert cumulative probs to category probs:
# originally, I used a loop to do this, but
# thought it would be better to vectorize.
# see 2nd addendum for time comparison - not
# much difference

p &amp;lt;- t(t(matcump)[-1,] - t(matcump)[-5,])

# show some indvidual level probabilities

head(p)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4]
## [1,] 0.18 0.25 0.36 0.22
## [2,] 0.17 0.24 0.36 0.22
## [3,] 0.28 0.29 0.29 0.13
## [4,] 0.18 0.25 0.36 0.22
## [5,] 0.18 0.25 0.35 0.21
## [6,] 0.24 0.28 0.32 0.16&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;apply(head(p), 1, sum)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1 1 1 1 1 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# generate indvidual level category outcomes based on p

cat &amp;lt;- simstudy:::matMultinom(p)
catF &amp;lt;- ordered(cat)
dt[, cat := catF]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we fit the mixed effects model, it is not surprising that we recover the parameters used to generate the data, which were based on the model. The fixed effects were specified as “0.8 * grp + 0.3 * male - 0.2 * status”, the variance of the random group effect was 0.10, and the latent thresholds based on the category probabilities were {-0.62, 0.62, 2.20}:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fmm &amp;lt;- clmm(cat ~ grp + male + status + (1|idS), data=dt)
summary(fmm)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Cumulative Link Mixed Model fitted with the Laplace approximation
## 
## formula: cat ~ grp + male + status + (1 | idS)
## data:    dt
## 
##  link  threshold nobs  logLik    AIC      niter     max.grad cond.H 
##  logit flexible  24990 -33096.42 66206.85 705(2118) 2.37e-02 1.3e+02
## 
## Random effects:
##  Groups Name        Variance Std.Dev.
##  idS    (Intercept) 0.109    0.331   
## Number of groups:  idS 100 
## 
## Coefficients:
##        Estimate Std. Error z value Pr(&amp;gt;|z|)    
## grp      0.8117     0.0702    11.6   &amp;lt;2e-16 ***
## male     0.3163     0.0232    13.7   &amp;lt;2e-16 ***
## status  -0.1959     0.0116   -16.9   &amp;lt;2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Threshold coefficients:
##     Estimate Std. Error z value
## 1|2  -0.6478     0.0511   -12.7
## 2|3   0.6135     0.0511    12.0
## 3|4   2.1789     0.0529    41.2&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;addendum-2---vector-vs-loop&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Addendum 2 - vector vs loop&lt;/h2&gt;
&lt;p&gt;In case any one is obsessed with vectorization in &lt;code&gt;R&lt;/code&gt;, here is a comparison of two different functions that convert cumulative probabilities into probabilities. One method uses a loop, the other uses matrix operations. In this case, it actually appears that my non-loop approach is slower - maybe there is a faster way? Maybe not, since the loop is actually quite short - determined by the number of possible responses in the categorical measure…&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(microbenchmark)

loopdif &amp;lt;- function(mat) {
  
  ncols &amp;lt;- ncol(mat)
  p &amp;lt;- matrix(0, nrow = nrow(mat), ncol = ( ncols - 1 ))
  for (i in 1 : ( ncol(mat) - 1 )) {
    p[,i] &amp;lt;- mat[, i+1] - mat[, i]
  }
  return(p)
  
}

vecdif &amp;lt;- function(mat) {
  
  ncols &amp;lt;- ncol(mat)
  p &amp;lt;- t(t(mat)[-1,] - t(mat)[-ncols,])
  return(p)
  
}

head(loopdif(matcump))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4]
## [1,] 0.18 0.25 0.36 0.22
## [2,] 0.17 0.24 0.36 0.22
## [3,] 0.28 0.29 0.29 0.13
## [4,] 0.18 0.25 0.36 0.22
## [5,] 0.18 0.25 0.35 0.21
## [6,] 0.24 0.28 0.32 0.16&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(vecdif(matcump))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4]
## [1,] 0.18 0.25 0.36 0.22
## [2,] 0.17 0.24 0.36 0.22
## [3,] 0.28 0.29 0.29 0.13
## [4,] 0.18 0.25 0.36 0.22
## [5,] 0.18 0.25 0.35 0.21
## [6,] 0.24 0.28 0.32 0.16&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;microbenchmark(loopdif(matcump), vecdif(matcump), 
               times = 1000L, unit = &amp;quot;ms&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Unit: milliseconds
##              expr  min  lq mean median  uq max neval
##  loopdif(matcump) 0.96 1.4  1.9    1.7 1.9 112  1000
##   vecdif(matcump) 0.92 1.7  3.1    2.3 2.7 115  1000&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>A hidden process behind binary or other categorical outcomes?</title>
      <link>/post/ordinal-regression/</link>
      <pubDate>Mon, 28 Aug 2017 00:00:00 +0000</pubDate>
      <author>keith.goldfeld@nyumc.org (Keith Goldfeld)</author>
      <guid>/post/ordinal-regression/</guid>
      <description>&lt;p&gt;I was thinking a lot about proportional-odds cumulative logit models last fall while designing a study to evaluate an intervention’s effect on meat consumption. After a fairly extensive pilot study, we had determined that participants can have quite a difficult time recalling precise quantities of meat consumption, so we were forced to move to a categorical response. (This was somewhat unfortunate, because we would not have continuous or even count outcomes, and as a result, might not be able to pick up small changes in behavior.) We opted for a question that was based on 30-day meat consumption: none, 1-3 times per month, 1 time per week, etc. - six groups in total. The question was how best to evaluate effectiveness of the intervention?&lt;/p&gt;
&lt;p&gt;Since the outcome was categorical &lt;em&gt;and&lt;/em&gt; ordinal - that is category 1 implied less meat consumption that category 2, category 2 implied less consumption that category 3, and so on - a model that estimates the cumulative probability of ordinal outcomes seemed like a possible way to proceed. Cumulative logit models estimate a number of parameters that represent the cumulative log-odds of an outcome; the parameters are the log-odds of categories 2 through 6 versus category 1, categories 3 through 6 versus 1 &amp;amp; 2, etc. Maybe not the most intuitive way to interpret the data, but seems to plausibly fit the data generating process.&lt;/p&gt;
&lt;p&gt;I was concerned about the proportionality assumption of the cumulative logit model, particularly when we started to consider adjusting for baseline characteristics (more on that in the next post). I looked more closely at the data generating assumptions of the cumulative logit model, which are quite frequently framed in the context of a continuous latent measure that follows a logistic distribution. I thought I’d describe that data generating process here to give an alternative view of discrete data models.&lt;/p&gt;
&lt;p&gt;I know I have been describing a context that includes an outcome with multiple categories, but in this post I will focus on regular logistic regression with a binary outcome. This will hopefully allow me to establish the idea of a latent threshold. I think it will be useful to explain this simpler case first before moving on to the more involved case of an ordinal response variable, which I plan to tackle in the near future.&lt;/p&gt;
&lt;div id=&#34;a-latent-continuous-process-underlies-the-observed-binary-process&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;A latent continuous process underlies the observed binary process&lt;/h3&gt;
&lt;p&gt;For an event with a binary outcome (true or false, A or B, 0 or 1), the observed outcome may, at least in some cases, be conceived as the manifestation of an unseen, latent continuous outcome. In this conception, the observed (binary) outcome merely reflects whether or not the unseen continuous outcome has exceeded a specified threshold. Think of this threshold as a tipping point, above which the observable characteristic takes on one value (say false), below which it takes on a second value (say true).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-logistic-distribution&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;The logistic distribution&lt;/h3&gt;
&lt;p&gt;Logistic regression models are used to estimate relationships of individual characteristics with categorical outcomes. The name of this regression model arises from the logistic distribution, which is a symmetrical continuous distribution. In a latent (or hidden) variable framework, the underlying, unobserved continuous measure is drawn from this logistic distribution. More specifically, the standard logistic distribution is typically assumed, with a location parameter of 0, and a scale parameter of 1. (The mean of this distribution is 0 and variance is approximately 3.29.)&lt;/p&gt;
&lt;p&gt;Here is a plot of a logistic pdf, shown in relation to a standard normal pdf (with mean 0 and variance 1):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggplot2)
library(data.table)

my_theme &amp;lt;- function() {
  theme(panel.background = element_rect(fill = &amp;quot;grey90&amp;quot;), 
        panel.grid = element_blank(), 
        axis.ticks = element_line(colour = &amp;quot;black&amp;quot;), 
        panel.spacing = unit(0.25, &amp;quot;lines&amp;quot;), 
        plot.title = element_text(size = 12, vjust = 0.5, hjust = 0), 
        panel.border = element_rect(fill = NA, colour = &amp;quot;gray90&amp;quot;))
}

x &amp;lt;- seq(-6, 6, length = 1000)
yNorm &amp;lt;- dnorm(x, 0, 1) 
yLogis &amp;lt;- dlogis(x, location = 0, scale = 1)

dt &amp;lt;- data.table(x, yNorm, yLogis)
dtm &amp;lt;- melt(dt, id.vars = &amp;quot;x&amp;quot;, value.name = &amp;quot;Density&amp;quot;)

ggplot(data = dtm) +
  geom_line(aes(x = x, y = Density, color = variable)) +
  geom_hline(yintercept = 0, color = &amp;quot;grey50&amp;quot;) +
  my_theme() +
  scale_color_manual(values = c(&amp;quot;red&amp;quot;, &amp;quot;black&amp;quot;), 
                     labels=c(&amp;quot;Normal&amp;quot;, &amp;quot;Logistic&amp;quot;)) +
  theme(legend.position = c(0.8, 0.6),
        legend.title = element_blank())&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-08-23-ordinal-regression_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-threshold-defines-the-probability&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;The threshold defines the probability&lt;/h3&gt;
&lt;p&gt;Below, I have plotted the standardized logistic pdf with a threshold that defines a tipping point for a particular Group A. In this case the threshold is 1.5, so for everyone with a unseen value of &lt;span class=&#34;math inline&#34;&gt;\(X &amp;lt; 1.5\)&lt;/span&gt;, the observed binary outcome &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; will be 1. For those where &lt;span class=&#34;math inline&#34;&gt;\(X \geq 1.5\)&lt;/span&gt;, the observed binary outcome &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; will be 0:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;xGrpA &amp;lt;- 1.5

ggplot(data = dtm[variable == &amp;quot;yLogis&amp;quot;], aes(x = x, y = Density)) +
  geom_line() +
  geom_segment(x = xGrpA, y = 0, xend = xGrpA, yend = dlogis(xGrpA), lty = 2) +
  geom_area(mapping = aes(ifelse(x &amp;lt; xGrpA, x, xGrpA)), fill = &amp;quot;white&amp;quot;) +
  geom_hline(yintercept = 0, color = &amp;quot;grey50&amp;quot;) +
  ylim(0, 0.3) +
  my_theme() +
  scale_x_continuous(breaks = c(-6, -3, 0, xGrpA, 3, 6))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-08-23-ordinal-regression_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Since we have plot a probability density (pdf), the area under the entire curve is equal to 1. We are interested in the binary outcome &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; defined by the threshold, so we can say that the area below the curve to the left of threshold (filled in white) represents &lt;span class=&#34;math inline&#34;&gt;\(P(Y = 1|Group=A)\)&lt;/span&gt;. The remaining area represents &lt;span class=&#34;math inline&#34;&gt;\(P(Y = 0|Group=A)\)&lt;/span&gt;. The area to the left of the threshold can be calculated in &lt;code&gt;R&lt;/code&gt; using the &lt;code&gt;plogis&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(p_A &amp;lt;- plogis(xGrpA))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.8175745&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here is the plot for a second group that has a threshold of 2.2:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-08-23-ordinal-regression_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The area under the curve to the left of the threshold is &lt;span class=&#34;math inline&#34;&gt;\(P(X &amp;lt; 2.2)\)&lt;/span&gt;, which is also &lt;span class=&#34;math inline&#34;&gt;\(P(Y = 1 | Group=B)\)&lt;/span&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(p_B &amp;lt;- plogis(xGrpB))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.9002495&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;log-odds-and-probability&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Log-odds and probability&lt;/h3&gt;
&lt;p&gt;In logistic regression, we are actually estimating the log-odds of an outcome, which can be written as&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[log \left[ \frac{P(Y=1)}{P(Y=0)} \right]\]&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;In the case of Group A, log-odds of Y being equal to 1 is&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(logodds_A &amp;lt;- log(p_A / (1 - p_A) ))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And for Group B,&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;(logodds_B &amp;lt;- log(p_B / (1 - p_B) ))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2.2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you may have noticed, we’ve recovered the thresholds that we used to define the probabilities for the two groups. The threshold is actually the log-odds for a particular group.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;logistic-regression&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Logistic regression&lt;/h3&gt;
&lt;p&gt;The logistic regression model that estimates the log-odds for each group can be written as&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[log \left[ \frac{P(Y=1)}{P(Y=0)} \right] = B_0 + B_1 * I(Grp = B) \quad ,\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(B_0\)&lt;/span&gt; represents the threshold for Group A and &lt;span class=&#34;math inline&#34;&gt;\(B_1\)&lt;/span&gt; represents the shift in the threshold for Group B. In our example, the threshold for Group B is 0.7 units (2.2 - 1.5) to the right of the threshold for Group A. If we generate data for both groups, our estimates for &lt;span class=&#34;math inline&#34;&gt;\(B_0\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(B_1\)&lt;/span&gt; should be close to 1.5 and 0.7, respectively&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-process-in-action&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;The process in action&lt;/h3&gt;
&lt;p&gt;To put this all together in a simulated data generating process, we can see the direct link with the logistic distribution, the binary outcomes, and an interpretation of estimates from a logistic model. The only stochastic part of this simulation is the generation of continuous outcomes from a logistic distribution. Everything else follows from the pre-defined group assignments and the group-specific thresholds:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;n = 5000
set.seed(999)

# Stochastic step

xlatent &amp;lt;- rlogis(n, location = 0, scale = 1)

# Deterministic part

grp &amp;lt;- rep(c(&amp;quot;A&amp;quot;,&amp;quot;B&amp;quot;), each = n / 2)

dt &amp;lt;- data.table(id = 1:n, grp, xlatent, y = 0)
dt[grp == &amp;quot;A&amp;quot; &amp;amp; xlatent &amp;lt;= xGrpA, y := 1]
dt[grp == &amp;quot;B&amp;quot; &amp;amp; xlatent &amp;lt;= xGrpB, y := 1]

# Look at the data

dt&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         id grp    xlatent y
##    1:    1   A -0.4512173 1
##    2:    2   A  0.3353507 1
##    3:    3   A -2.2579527 1
##    4:    4   A  1.7553890 0
##    5:    5   A  1.3054260 1
##   ---                      
## 4996: 4996   B -0.2574943 1
## 4997: 4997   B -0.9928283 1
## 4998: 4998   B -0.7297179 1
## 4999: 4999   B -1.6430344 1
## 5000: 5000   B  3.1379593 0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The probability of a “successful” outcome (i.e &lt;span class=&#34;math inline&#34;&gt;\(P(Y = 1\)&lt;/span&gt;)) for each group based on this data generating process is pretty much equal to the areas under the respective densities to the left of threshold used to define success:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dt[, round(mean(y), 2), keyby = grp]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    grp   V1
## 1:   A 0.82
## 2:   B 0.90&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now let’s estimate a logistic regression model:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(broom)
glmfit &amp;lt;- glm(y ~ grp, data = dt, family = &amp;quot;binomial&amp;quot;)
tidy(glmfit, quick = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          term  estimate
## 1 (Intercept) 1.5217770
## 2        grpB 0.6888526&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The estimates from the model recover the logistic distribution thresholds for each group. The Group A threshold is estimated to be 1.52 (the intercept) and the Group B threshold is estimated to be 2.21 (intercept + grpB parameter). These estimates can be interpreted as the log-odds of success for each group, but also &lt;em&gt;as the threshold for the underlying continuous data generating process that determines the binary outcome &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt;&lt;/em&gt;. And we can interpret the parameter for &lt;code&gt;grpB&lt;/code&gt; in the traditional way as the log-odds ratio comparing the log-odds of success for Group B with the log-odds of success for Group A, or &lt;em&gt;as the shift in the logistic threshold for Group A to the logistic threshold for Group B&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In the next week or so, I will extend this to a discussion of an ordinal categorical outcome. I think the idea of shifting the thresholds underscores the proportionality assumption I alluded to earlier …&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Be careful not to control for a post-exposure covariate</title>
      <link>/post/be-careful/</link>
      <pubDate>Mon, 21 Aug 2017 00:00:00 +0000</pubDate>
      <author>keith.goldfeld@nyumc.org (Keith Goldfeld)</author>
      <guid>/post/be-careful/</guid>
      <description>&lt;p&gt;A researcher was presenting an analysis of the impact various types of childhood trauma might have on subsequent substance abuse in adulthood. Obviously, a very interesting and challenging research question. The statistical model included adjustments for several factors that are plausible confounders of the relationship between trauma and substance use, such as childhood poverty. However, the model also include a measurement for poverty in adulthood - believing it was somehow confounding the relationship of trauma and substance use. A confounder is a common cause of an exposure/treatment and an outcome; it is hard to conceive of adult poverty as a cause of childhood events, even though it might be related to adult substance use (or maybe not). At best, controlling for adult poverty has no impact on the conclusions of the research; less good, though, is the possibility that it will lead to the conclusion that the effect of trauma is less than it actually is.&lt;/p&gt;
&lt;p&gt;Using a highly contrived simulation of data and the abstract concept of &lt;em&gt;potential outcomes&lt;/em&gt;, I am hoping to illuminate some of the issues raised by this type of analysis.&lt;/p&gt;
&lt;div id=&#34;potential-outcomes-and-causal-effects&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Potential outcomes and causal effects&lt;/h2&gt;
&lt;p&gt;The field of causal inference is a rich one, and I won’t even scratch the surface here. My goal is to present the concepts of potential outcomes so that we can articulate at least one clear way to think about what a causal effect can be defined. Under this framework, we generate data where we can find out the “true” measure of causal effect. And then we can use simple regression models to see how well (or not) they recapture these “known” causal effects.&lt;/p&gt;
&lt;p&gt;If an individual &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; experiences a traumatic effect as a child, we say that the exposure &lt;span class=&#34;math inline&#34;&gt;\(X_i = 1\)&lt;/span&gt;. Otherwise &lt;span class=&#34;math inline&#34;&gt;\(X_i = 0\)&lt;/span&gt;, there was no traumatic event. (I am going to assume binary exposures just to keep things simple - exposed vs. not exposed.) In the potential outcomes world we say that every individual has possible outcomes &lt;span class=&#34;math inline&#34;&gt;\(Y_{1i}\)&lt;/span&gt; (the outcome we would observe &lt;em&gt;if&lt;/em&gt; the individual had experienced trauma) and &lt;span class=&#34;math inline&#34;&gt;\(Y_{0i}\)&lt;/span&gt; (the outcome we would observe &lt;em&gt;if&lt;/em&gt; the individual had not. Quite simply, we define the causal effect of &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; on &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; as the difference in potential outcomes, &lt;span class=&#34;math inline&#34;&gt;\(CE_i = Y_{1i} - Y_{0i}\)&lt;/span&gt;. If &lt;span class=&#34;math inline&#34;&gt;\(Y_{1i} = Y_{0i}\)&lt;/span&gt; (i.e. the potential outcomes are the same), we would say that &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; does not cause &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt;, at least for individual &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;In the real world, we only observe one potential outcome - the one associated with the actual exposure. The field of causal inference has lots to say about the assumptions and conditions that are required for us to use observed data to estimate average causal effects; many would say that unless we use a randomized controlled study, those assumptions will never be reasonable. But in the world of simulation, we can generate potential outcomes and observed outcomes, so we know the causal effect both at the individual level and the average population level. And we can see how well our models do.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;simple-confounding&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Simple confounding&lt;/h2&gt;
&lt;p&gt;Here’s a relatively straightforward example. Let’s say we are interested in understanding if some measure &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; causes an outcome &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt;, where there is a common cause &lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt; (the diagram is called a DAG - a directed acyclic graph - and is useful for many things, including laying out data generating process):&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/post-careful/SimpleCausal.png&#34; width=&#34;300px&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(broom)
library(data.table)
library(simstudy)

def &amp;lt;- defData(varname = &amp;quot;C&amp;quot;, formula = 0.4, dist = &amp;quot;binary&amp;quot;)
def &amp;lt;- defData(def, &amp;quot;X&amp;quot;, formula = &amp;quot;0.3 + 0.4 * C&amp;quot;, dist = &amp;quot;binary&amp;quot;)
def &amp;lt;- defData(def, &amp;quot;e&amp;quot;, formula = 0, variance = 2, dist = &amp;quot;normal&amp;quot;)
def &amp;lt;- defData(def, &amp;quot;Y0&amp;quot;, formula = &amp;quot;2 * C + e&amp;quot;, dist=&amp;quot;nonrandom&amp;quot;)
def &amp;lt;- defData(def, &amp;quot;Y1&amp;quot;, formula = &amp;quot;0.5 + 2 * C + e&amp;quot;, dist=&amp;quot;nonrandom&amp;quot;)
def &amp;lt;- defData(def, &amp;quot;Y_obs&amp;quot;, formula = &amp;quot;Y0 + (Y1 - Y0) * X&amp;quot;, dist = &amp;quot;nonrandom&amp;quot;)

def&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    varname            formula variance      dist     link
## 1:       C                0.4        0    binary identity
## 2:       X      0.3 + 0.4 * C        0    binary identity
## 3:       e                  0        2    normal identity
## 4:      Y0          2 * C + e        0 nonrandom identity
## 5:      Y1    0.5 + 2 * C + e        0 nonrandom identity
## 6:   Y_obs Y0 + (Y1 - Y0) * X        0 nonrandom identity&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; does have an effect on &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt;, but so does &lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt;. If we ignore &lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt; in assessing the size of the effect of &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; on &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt;, we will overestimate that effect, which is 0.5. We can generate data and see that this is the case:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(5)
dt &amp;lt;- genData(1000, def)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We see that the true causal effect is easily recovered if we have access to the potential outcomes &lt;span class=&#34;math inline&#34;&gt;\(Y_1\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(Y_0\)&lt;/span&gt;, but of course we don’t:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dt[, mean(Y1 - Y0)] # True causal effect&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we compare the average &lt;em&gt;observed&lt;/em&gt; outcomes for each exposure group ignoring the confounder, we overestimate the effect of the exposure:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dt[X == 1, mean(Y_obs)] - dt[X == 0, mean(Y_obs)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.285009&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can estimate the same effect using simple linear regression:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lm1 &amp;lt;- lm(Y_obs ~ X, data = dt)
tidy(lm1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          term  estimate  std.error statistic      p.value
## 1 (Intercept) 0.5515963 0.07325865  7.529436 1.137854e-13
## 2           X 1.2850091 0.10674523 12.038094 2.916261e-31&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And finally, if we adjust for the confounder &lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt;, we recover the true causal effect of &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; on &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt;, or at least get very close to it:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lm2 &amp;lt;- lm(Y_obs ~ X + C, data = dt)
tidy(lm2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          term   estimate  std.error statistic      p.value
## 1 (Intercept) 0.08491216 0.06502545  1.305830 1.919117e-01
## 2           X 0.48935880 0.09678110  5.056347 5.083959e-07
## 3           C 2.05729945 0.09825925 20.937464 5.767575e-81&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;adjusting-for-a-post-exposure-covariate&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Adjusting for a post-exposure covariate&lt;/h2&gt;
&lt;p&gt;Now, we are ready to see what happens in a slightly more complicated setting that is defined by this DAG:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/post-careful/ComplexCausal.png&#34; width=&#34;400px&#34; /&gt;&lt;/p&gt;
&lt;p&gt;In this example &lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt; is measured in two time periods, and exposure in period 1 relates to exposure in period 2. (For example, if a child is poor, he is more likely to be poor as an adult.) We are primarily interested in whether or not &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; (trauma) causes &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; (substance use). The difficulty is that &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(C_2\)&lt;/span&gt; are related, as are &lt;span class=&#34;math inline&#34;&gt;\(C_2\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;I suggest that in order to fully understand the effect of &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; on &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt;, we cannot control for &lt;span class=&#34;math inline&#34;&gt;\(C_2\)&lt;/span&gt;, as tempting as it might be. The intuition is that part of the effect of &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; on &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; is due to the fact that &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; has an effect on &lt;span class=&#34;math inline&#34;&gt;\(C_2\)&lt;/span&gt;, at least for some individuals. &lt;em&gt;If we control for &lt;span class=&#34;math inline&#34;&gt;\(C_2\)&lt;/span&gt;, we are actually removing a key component of the causal mechanism.&lt;/em&gt; Below in is the data generating process - a few things to note: (1) &lt;span class=&#34;math inline&#34;&gt;\(C_2\)&lt;/span&gt; has potential outcomes based on the exposure &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt;. (2) We have restricted the potential outcome &lt;span class=&#34;math inline&#34;&gt;\(C_{21}\)&lt;/span&gt; to be set to 1 if &lt;span class=&#34;math inline&#34;&gt;\(C_{20}\)&lt;/span&gt; is 1. For example, if someone would have been poor in adulthood &lt;em&gt;without&lt;/em&gt; exposure to trauma, we assume that they also would have been poor in adulthood had they been exposed to trauma. (3) The potential outcome for &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; is dependent on the relevant potential outcome for &lt;span class=&#34;math inline&#34;&gt;\(C_2\)&lt;/span&gt;. That is &lt;span class=&#34;math inline&#34;&gt;\(Y_0\)&lt;/span&gt; depends on &lt;span class=&#34;math inline&#34;&gt;\(C_{20}\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(Y_1\)&lt;/span&gt; depends on &lt;span class=&#34;math inline&#34;&gt;\(C_{21}\)&lt;/span&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;##     varname                  formula variance      dist     link
##  1:      C1                     0.25        0    binary identity
##  2:       X            -2 + 0.8 * C1        0    binary    logit
##  3:    C2.0            -2.0 + 1 * C1        0    binary    logit
##  4:   C2.1x            -1.5 + 1 * C1        0    binary    logit
##  5:    C2.1        pmax(C2.0, C2.1x)        0 nonrandom identity
##  6:       e                        0        4    normal identity
##  7:      Y0          -3 + 5*C2.0 + e        0 nonrandom identity
##  8:      Y1           0 + 5*C2.1 + e        0 nonrandom identity
##  9:  C2_obs C2.0 + (C2.1 - C2.0) * X        0 nonrandom identity
## 10:   Y_obs       Y0 + (Y1 - Y0) * X        0 nonrandom identity&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(25)
dt &amp;lt;- genData(5000, def2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here is the true average causal effect, based on information we will never know:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dt[, mean(Y1 - Y0)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 3.903&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we control for &lt;span class=&#34;math inline&#34;&gt;\(C_2\)&lt;/span&gt;, we are essentially estimating the effect of &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; at each level &lt;span class=&#34;math inline&#34;&gt;\(C_2\)&lt;/span&gt; (and &lt;span class=&#34;math inline&#34;&gt;\(C_1\)&lt;/span&gt;, since we are controlling for that as well), and then averaging across the sub-samples to arrive at an estimate for the entire sample. We can see that, based on the specification of the potential outcomes in the data generation process, the effect at each level of &lt;span class=&#34;math inline&#34;&gt;\(C_2\)&lt;/span&gt; will be centered around 3.0, which is different from the true causal effect of 3.9. The discrepancy is due to the fact each approach is effectively collecting different sub-samples (one defines groups based on set levels of &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(C_2\)&lt;/span&gt;, and the other defines groups based on set levels of &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; alone) and estimating average effects based on weights determined by the sizes of those two sets of sub-samples.&lt;/p&gt;
&lt;p&gt;Here is the inappropriate model that adjusts for &lt;span class=&#34;math inline&#34;&gt;\(C_2\)&lt;/span&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lm2a &amp;lt;- lm( Y_obs ~ C1 + C2_obs + X , data = dt)
tidy(lm2a)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          term    estimate  std.error   statistic       p.value
## 1 (Intercept) -3.01360235 0.03481082 -86.5708464  0.000000e+00
## 2          C1 -0.02078171 0.06765129  -0.3071887  7.587126e-01
## 3      C2_obs  4.92972384 0.07625838  64.6450138  0.000000e+00
## 4           X  3.04600204 0.08114223  37.5390478 6.677416e-272&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The estimate for the coefficient of &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; is 3.0, just as anticipated. Here now is the correct model, and you will see that we recover the true causal effect in the coefficient estimate of &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; (or at least, we get much, much closer):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lm2b &amp;lt;- lm( Y_obs ~ C1 + X , data = dt)
tidy(lm2b)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          term   estimate  std.error statistic       p.value
## 1 (Intercept) -2.4886726 0.04586832 -54.25689  0.000000e+00
## 2          C1  0.9665413 0.08930265  10.82321  5.315059e-27
## 3           X  3.9377832 0.10834926  36.34343 7.868650e-257&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, in the real world, we don’t know the underlying data generating process or the true DAG. And what I have described here is a gross oversimplification of the underlying relationships, and have indeed left out many other factors that likely affect the relationship between childhood trauma and adult substance use. Other measures, such as parental substance use, may be related to both childhood trauma and adult substance use, and may affect poverty in the two time periods in different, complicated ways.&lt;/p&gt;
&lt;p&gt;But the point is that one should give careful thought to what gets included in a model. We may not want to throw everything we measure into the model. Be careful.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Should we be concerned about incidence - prevalence bias?</title>
      <link>/post/simulating-incidence-prevalence-bias/</link>
      <pubDate>Wed, 09 Aug 2017 00:00:00 +0000</pubDate>
      <author>keith.goldfeld@nyumc.org (Keith Goldfeld)</author>
      <guid>/post/simulating-incidence-prevalence-bias/</guid>
      <description>&lt;p&gt;Recently, we were planning a study to evaluate the effect of an intervention on outcomes for very sick patients who show up in the emergency department. My collaborator had concerns about a phenomenon that she had observed in other studies that might affect the results - patients measured earlier in the study tend to be sicker than those measured later in the study. This might not be a problem, but in the context of a stepped-wedge study design (see &lt;a href=&#34;https://www.rdatagen.net/post/using-simulation-for-power-analysis-an-example/&#34;&gt;this&lt;/a&gt; for a discussion that touches this type of study design), this could definitely generate biased estimates: when the intervention occurs later in the study (as it does in a stepped-wedge design), the “exposed” and “unexposed” populations could differ, and in turn so could the outcomes. We might confuse an artificial effect as an intervention effect.&lt;/p&gt;
&lt;p&gt;What could explain this phenomenon? The title of this post provides a hint: cases earlier in a study are more likely to be prevalent ones (i.e. they have been sick for a while), whereas later in the study cases tend to be incident (i.e. they only recently become sick). Even though both prevalent and incident cases are sick, the former may be sicker on average than the latter, simply because their condition has had more time develop.&lt;/p&gt;
&lt;p&gt;We didn’t have any data to test out this hypothesis (if our grant proposal is funded, we will be able to do that), so I decided to see if I could simulate this phenomenon. In my continuing series exploring simulation using &lt;code&gt;Rcpp&lt;/code&gt;, &lt;code&gt;simstudy&lt;/code&gt;, and &lt;code&gt;data.table&lt;/code&gt;, I am presenting some code that I used to do this.&lt;/p&gt;
&lt;div id=&#34;generating-a-population-of-patients&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Generating a population of patients&lt;/h2&gt;
&lt;p&gt;The first task is to generate a population of individuals, each of whom starts out healthy and potentially becomes sicker over time. Time starts in month 1 and ends at some fixed point - in the first example, I end at 400 months. Each individual has a starting health status and a start month. In the examples that follow, health status is 1 through 4, with 1 being healthy, 3 is quite sick, and 4 is death. And, you can think of the start month as the point where the individual ages into the study. (For example, if the study includes only people 65 and over, the start month is the month the individual turns 65.) If an individual starts in month 300, she will have no measurements in periods 1 through 299 (i.e. health status will be 0).&lt;/p&gt;
&lt;p&gt;The first part of the simulation generates a start month and starting health status for each individual, and then generates a health status for each individual until the end of time. Some individuals may die, while others may go all the way to the end of the simulation in a healthy state.&lt;/p&gt;
&lt;div id=&#34;rcpp-function-to-generate-health-status-for-each-period&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Rcpp function to generate health status for each period&lt;/h4&gt;
&lt;p&gt;While it is generally preferable to avoid loops in R, sometimes it cannot be &lt;a href=&#34;https://www.rdatagen.net/post/first-blog-entry/&#34;&gt;avoided&lt;/a&gt;. I believe generating a health status that depends on the previous health status (a Markov process) is one of those situations. So, I have written an Rcpp function to do this - it is orders of magnitude faster than doing this in R:&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;RcppArmadilloExtensions/sample.h&amp;gt;
// [[Rcpp::depends(RcppArmadillo)]]

using namespace Rcpp; 

// [[Rcpp::export]]
IntegerVector MCsim( unsigned int nMonths, NumericMatrix P, 
                     int startStatus, unsigned int startMonth ) {
  
  IntegerVector sim( nMonths );
  IntegerVector healthStats( P.ncol() );
  NumericVector currentP;
  IntegerVector newstate;
  
  unsigned int q = P.ncol();
  healthStats = Rcpp::seq(1, q);
  
  sim[startMonth - 1] = startStatus;
  
  /* Loop through each month for each individual */
  
  for (unsigned int i = startMonth; i &amp;lt; nMonths; i++) {
    
    /* new state based on health status of last period and
       probability of transitioning to different state     */ 
    
    newstate = RcppArmadillo::sample( healthStats, 
                                      1, 
                                      TRUE, 
                                      P.row(sim(i-1) - 1) ); 
    sim(i) = newstate(0);
    
  }
  
  return sim;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;generating-the-data&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Generating the data&lt;/h4&gt;
&lt;p&gt;The data generation process is shown below. The general outline of the process is (1) define transition probabilities, (2) define starting health status distribution, (3) generate starting health statuses and start months, and (4) generate health statuses for each follow-up month.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Transition matrix for moving through health statuses

P &amp;lt;- matrix(c(0.985, 0.015, 0.000, 0.000, 
              0.000, 0.950, 0.050, 0.000,
              0.000, 0.000, 0.850, 0.150,
              0.000, 0.000, 0.000, 1.000), nrow = 4, byrow = TRUE)

maxFU = 400
nPerMonth = 350
N = maxFU * nPerMonth

ddef &amp;lt;- defData(varname = &amp;quot;sHealth&amp;quot;, 
                formula = &amp;quot;0.80; 0.15; 0.05&amp;quot;, 
                dist = &amp;quot;categorical&amp;quot;)

# generate starting health values (1, 2, or 3) for all individuals
set.seed(123)
did &amp;lt;- genData(n = N, dtDefs = ddef)

# each month, 350 age in to the sample
did[, sMonth := rep(1:maxFU, each = nPerMonth)]

# show table for 10 randomly selected individuals
did[id %in% sample(x = did$id, size = 10, replace = FALSE)] &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         id sHealth sMonth
##  1:  15343       2     44
##  2:  19422       2     56
##  3:  41426       1    119
##  4:  50050       1    143
##  5:  63042       1    181
##  6:  83584       1    239
##  7:  93295       1    267
##  8: 110034       1    315
##  9: 112164       3    321
## 10: 123223       1    353&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# generate the health status history based on the transition matrix
dhealth &amp;lt;- did[, .(sHealth, sMonth, health = MCsim(maxFU, P, sHealth, sMonth)), 
                 keyby = id]
dhealth[, month := c(1:.N), by = id]

dhealth&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##               id sHealth sMonth health month
##        1:      1       1      1      1     1
##        2:      1       1      1      1     2
##        3:      1       1      1      1     3
##        4:      1       1      1      1     4
##        5:      1       1      1      1     5
##       ---                                   
## 55999996: 140000       1    400      0   396
## 55999997: 140000       1    400      0   397
## 55999998: 140000       1    400      0   398
## 55999999: 140000       1    400      0   399
## 56000000: 140000       1    400      1   400&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;simulation-needs-burn-in-period&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Simulation needs burn-in period&lt;/h4&gt;
&lt;p&gt;The simulation process itself is biased in its early phases as there are too many individuals in the sample who have just aged in compared to those who are “older”. (This is sort of the the reverse of the incidence - prevalence bias.) Since individuals tend to have better health status when they are “younger”, the average health status of the simulation in its early phases is biased downwards by the preponderance of young individuals in the population. This suggests that any evaluation of simulated data needs to account for a “burn-in” period that ensures there is a mix of “younger” and “older” individuals. To show this, I have calculated an average health score for each period of the simulation and plotted the results. You can see that the sample stabilizes after about 200 months in this simulation.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# count number of individuals with a particular heath statust each month

cmonth &amp;lt;- dhealth[month &amp;gt; 0, .N, keyby = .(month, health)]
cmonth&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       month health      N
##    1:     1      0 139650
##    2:     1      1    286
##    3:     1      2     47
##    4:     1      3     17
##    5:     2      0 139300
##   ---                    
## 1994:   399      4 112203
## 1995:   400      1  18610
## 1996:   400      2   6515
## 1997:   400      3   2309
## 1998:   400      4 112566&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# transform data from &amp;quot;long&amp;quot; form to &amp;quot;wide&amp;quot; form and calculate average

mtotal &amp;lt;- dcast(data = cmonth, 
                formula = month ~ health, 
                fill = 0, 
                value.var = &amp;quot;N&amp;quot;)

mtotal[, total := `1` + `2` + `3`]
mtotal[, wavg := (`1` + 2*`2` + 3*`3`)/total]
mtotal&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      month      0     1    2    3      4 total     wavg
##   1:     1 139650   286   47   17      0   350 1.231429
##   2:     2 139300   558  106   32      4   696 1.244253
##   3:     3 138950   829  168   45      8  1042 1.247601
##   4:     4 138600  1104  215   66     15  1385 1.250542
##   5:     5 138250  1362  278   87     23  1727 1.261726
##  ---                                                   
## 396:   396   1400 18616 6499 2351 111134 27466 1.407813
## 397:   397   1050 18613 6537 2321 111479 27471 1.406938
## 398:   398    700 18587 6561 2323 111829 27471 1.407957
## 399:   399    350 18602 6541 2304 112203 27447 1.406201
## 400:   400      0 18610 6515 2309 112566 27434 1.405810&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(data = mtotal, aes(x=month, y=wavg)) +
  geom_line() +
  ylim(1.2, 1.5) +
  geom_hline(yintercept = 1.411, lty = 3) +
  geom_vline(xintercept = 200, lty = 3) +
  xlab(&amp;quot;Month&amp;quot;) +
  ylab(&amp;quot;Average health status&amp;quot;) +
  theme(panel.background = element_rect(fill = &amp;quot;grey90&amp;quot;),
        panel.grid = element_blank(), 
        plot.title = element_text(size = 12, vjust = 0.5, hjust = 0) ) + 
  ggtitle(&amp;quot;Average health status of simulated population&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-08-09-simulating-incidence-prevalence-bias_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;generating-monthly-study-cohorts&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Generating monthly study cohorts&lt;/h2&gt;
&lt;p&gt;Now we are ready to see if we can simulate the incidence - prevalence bias. The idea here is to find the first month during which an individual (1) is “active” (i.e. the period being considered is on or after the individual’s start period), (2) has an emergency department visit, and (3) whose health status has reached a specified threshold.&lt;/p&gt;
&lt;p&gt;We can set a final parameter that looks back some number of months (say 6 or 12) to see if there have been any previous qualifying emergency room visits before the study start period (which in our case will be month 290 to mitigate an burn-in bias identified above). This “look-back” will be used to mitigate some of the bias by creating a washout period that makes the prevalent cases look more like incident cases. This look-back parameter is calculated each month for each individual using an Rcpp function that loops through each period:&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;Rcpp.h&amp;gt;

using namespace Rcpp;

// [[Rcpp::export]]
IntegerVector cAddPrior(IntegerVector idx, 
                        IntegerVector event,
                        int lookback) {
  
  int nRow = idx.length();
  IntegerVector sumPrior(nRow, NA_INTEGER);

  for (unsigned int i = lookback; i &amp;lt; nRow; i++) {
    
    IntegerVector seqx = Rcpp::seq(i-lookback, i-1);
    IntegerVector x = event[seqx];
    sumPrior[i] = sum(x);
    
  }
  
  return(sumPrior);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;div id=&#34;generating-a-single-cohort&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Generating a single cohort&lt;/h4&gt;
&lt;p&gt;The following code (1) generates a population (as we did above), (2) generates emergency department visits that are dependent on the health status (the sicker an individual is, the more likely they are to go to the ED), (3) calculates the number of eligible ED visits during the look-back period, and (4) creates the monthly cohorts based on the selection criteria. At the end, we calculate average health status for the cohort by month of cohort - this will be used to illustrate the bias.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;maxFU = 325 
nPerMonth = 100
N = maxFU * nPerMonth

START = 289 # to allow for adequate burn-in 
HEALTH = 2
LOOKBACK = 6 # how far to lookback

set.seed(123)
did &amp;lt;- genData(n = N, dtDefs = ddef)
did[, sMonth := rep(1:maxFU, each = nPerMonth)]

healthStats &amp;lt;- did[, .(sHealth, 
                       sMonth, 
                       health = MCsim(maxFU, P, sHealth, sMonth)),
                   keyby = id]
    
healthStats[, month := c(1:.N), by = id]
      
# eliminate period without status measurement (0) &amp;amp; death (4)
healthStats &amp;lt;- healthStats[!(health %in% c(0,4))]
  
# ensure burn-in by starting with observations far
# into simulation
healthStats &amp;lt;- healthStats[month &amp;gt; (START - LOOKBACK)]
  
# set probability of emergency department visit  
healthStats[, pED := (health == 1) * 0.02 + 
                     (health == 2) * 0.10 + 
                     (health == 3) * 0.20]

# generate emergency department visit
healthStats[, ed := rbinom(.N, 1, pED)]

healthStats[, edAdj := ed * as.integer(health &amp;gt;= HEALTH)] # if you want to restrict
healthStats[, pSum := cAddPrior(month, edAdj, lookback = LOOKBACK), keyby=id]

# look at one individual
healthStats[id == 28069]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        id sHealth sMonth health month  pED ed edAdj pSum
##  1: 28069       1    281      1   284 0.02  0     0   NA
##  2: 28069       1    281      1   285 0.02  0     0   NA
##  3: 28069       1    281      1   286 0.02  0     0   NA
##  4: 28069       1    281      1   287 0.02  0     0   NA
##  5: 28069       1    281      2   288 0.10  0     0   NA
##  6: 28069       1    281      2   289 0.10  0     0   NA
##  7: 28069       1    281      2   290 0.10  1     1    0
##  8: 28069       1    281      2   291 0.10  0     0    1
##  9: 28069       1    281      2   292 0.10  0     0    1
## 10: 28069       1    281      2   293 0.10  0     0    1
## 11: 28069       1    281      2   294 0.10  0     0    1
## 12: 28069       1    281      3   295 0.20  1     1    1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# cohort includes individuals with 1 prior ed visit in
# previous 6 months

cohort &amp;lt;- healthStats[edAdj == 1 &amp;amp; pSum == 0]
cohort &amp;lt;- cohort[, .(month = min(month)), keyby = id]
cohort&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          id month
##    1:    53   306
##    2:    82   313
##    3:   140   324
##    4:   585   291
##    5:   790   299
##   ---            
## 3933: 31718   324
## 3934: 31744   325
## 3935: 31810   325
## 3936: 31860   325
## 3937: 31887   325&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# estimate average health status of monthly cohorts

cohortStats &amp;lt;- healthStats[cohort, on = c(&amp;quot;id&amp;quot;,&amp;quot;month&amp;quot;)]
sumStats &amp;lt;- cohortStats[ , .(avghealth = mean(health), n = .N), keyby = month]

head(sumStats)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    month avghealth   n
## 1:   290  2.248175 137
## 2:   291  2.311765 170
## 3:   292  2.367347 147
## 4:   293  2.291925 161
## 5:   294  2.366906 139
## 6:   295  2.283871 155&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;exploring-bias&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Exploring bias&lt;/h2&gt;
&lt;p&gt;Finally, we are at the point where we can see what, if any, bias results in selecting our cohorts under the scenario I’ve outlined above. We start by generating multiple iterations of populations and cohorts and estimating average health status by month under the assumption that we will have a look-back period of 0. That is, we will accept an individual into the first possible cohort regardless of her previous emergency department visit history. The plot below shows average across 1000 iterations. What we see is that the average health status of the cohorts in the first 20 months or so exceed the long run average. The incidence - prevalence bias is extremely strong if we ignore prior ED history!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/post-incidence/plot00.png&#34; /&gt; &lt;br&gt;&lt;/p&gt;
&lt;div id=&#34;taking-history-into-account&#34; class=&#34;section level4&#34;&gt;
&lt;h4&gt;Taking history into account&lt;/h4&gt;
&lt;p&gt;Once we start to incorporate ED history by using look-back periods greater than 0, we see that we can reduce bias considerably. The two plots below show the results of using look-back periods of 6 and 12 months. Both have reduced bias, but only at 12 months are we approaching something that actually looks desirable. In fact, under this scenario, we’d probably like to go back 24 months to eliminate the bias entirely. Of course, these particular results are dependent on the simulation assumptions, so determining an appropriate look-back period will certainly depend on the actual data. (When we do finally get the actual data, I will follow-up to let you know what kind of adjustment we needed to make in the real, non-simulated world.)&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/img/post-incidence/plot06.png&#34; /&gt;

&lt;/div&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/img/post-incidence/plot12.png&#34; /&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Using simulation for power analysis: an example based on a stepped wedge study design</title>
      <link>/post/using-simulation-for-power-analysis-an-example/</link>
      <pubDate>Mon, 10 Jul 2017 00:00:00 +0000</pubDate>
      <author>keith.goldfeld@nyumc.org (Keith Goldfeld)</author>
      <guid>/post/using-simulation-for-power-analysis-an-example/</guid>
      <description>&lt;p&gt;Simulation can be super helpful for estimating power or sample size requirements when the study design is complex. This approach has some advantages over an analytic one (i.e. one based on a formula), particularly the flexibility it affords in setting up the specific assumptions in the planned study, such as time trends, patterns of missingness, or effects of different levels of clustering. A downside is certainly the complexity of writing the code as well as the computation time, which &lt;em&gt;can&lt;/em&gt; be a bit painful. My goal here is to show that at least writing the code need not be overwhelming.&lt;/p&gt;
&lt;p&gt;Recently, I was helping an investigator plan a stepped wedge cluster randomized trial to study the effects of modifying a physician support system on patient-level diabetes management. While analytic approaches for power calculations do exist in the context of this complex study design, it seemed worth the effort to be explicit about all of the assumptions. So in this case I opted to use simulation. The basic approach is outlined below.&lt;/p&gt;
&lt;div id=&#34;the-stepped-wedge-design&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The stepped wedge design&lt;/h2&gt;
&lt;p&gt;In cluster randomized trials, the unit of randomization is the group rather than the individual. While outcomes might be collected at the individual (e.g. student or patient) level, the intervention effect is assessed at the group (e.g. school or clinic). In a stepped wedge cluster design, the randomization unit is still the group, but all groups are eventually exposed to the intervention at some point in the study. Randomization determines &lt;em&gt;when&lt;/em&gt; the intervention starts.&lt;/p&gt;
&lt;p&gt;Below is schematic view of how a stepped wedge study is implemented. In this example, a block of clusters receives the intervention starting in the second period, another block starts the intervention in the third period, and so on. The intervention effect is essentially assessed by making within group comparisons. By staggering the starting points, the study is able to distinguish between time effects and treatment effects. If all groups started intervention at the same point, we would need to make an assumption that any improvements were due only to the intervention rather than changes that were occurring over time. This is not an assumption any one can easily justify.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-07-10-using-simulation-for-power-analysis-an-example-based-on-a-stepped-wedge-study-design_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;power-and-simulation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Power and simulation&lt;/h2&gt;
&lt;p&gt;The statistical power of a study is the conditional probability (conditional on a given effect size), that a hypothesis test will correctly reject the null hypothesis (i.e. conclude there is an effect when there actually is one). Power is underscored by the notion that a particular study can be replicated exactly over and over again. So, if the power of a study is 80%, that means in 80% of the replications of that study we will (appropriately) reject the null hypothesis.&lt;/p&gt;
&lt;p&gt;So, to estimate power, we can simulate replications of the study many times and conduct repeated hypothesis tests. The proportion of tests where we reject the null hypothesis is the estimated power. Each of these replications is based on the same set of data generating assumptions: effect sizes, sample sizes, individual level variation, group level variation, etc.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;simulating-from-a-stepped-wedge-design&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Simulating from a stepped wedge design&lt;/h2&gt;
&lt;p&gt;In this example, we are assuming a 3-year study with four groups of clusters randomized to start an intervention at either 12 months, 18 months, 24 months, or 30 months (i.e. every 6 months following the 1st baseline year). The study would enroll patients at baseline in each of the clusters, and a measurement of a binary outcome (say diabetes under control, or not) would be collected at that time. Those patients would be followed over time and the same measurement would be collected every 6 months, concluding with the 7th measurement in the 36th month of the study. (It is totally possible to enroll new patients as the study progresses and have a different follow-up scheme, but this approximates the actual study I was working on.)&lt;/p&gt;
&lt;p&gt;The data are generated based on a mixed effects model where there are group level effects (&lt;span class=&#34;math inline&#34;&gt;\(b_j\)&lt;/span&gt; in the model) as well as individual level effects (&lt;span class=&#34;math inline&#34;&gt;\(b_i\)&lt;/span&gt;). The model also assumes a very slight time trend before the intervention (e.g. diabetes control is improving slightly over time for an individual), an intervention effect, and an almost non-existent change in the time trend after the intervention. The outcome in each period is generated based on this formula:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(logit(Y_{ijt}) = 0.8 + .01 * period + 0.8 * I_{jt} + 0.001 * I_{jt} * (period-s_j) + b_i + b_j,\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(period\)&lt;/span&gt; goes from 0 to 6 (period 0 is the baseline, period 1 is the 6 month follow, etc.), &lt;span class=&#34;math inline&#34;&gt;\(I_{jt}\)&lt;/span&gt; is 1 if cluster &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; is in the intervention in period &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(s_j\)&lt;/span&gt; is the period where the intervention starts for cluster &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt;, and &lt;span class=&#34;math inline&#34;&gt;\(logit(Y_{ijt})\)&lt;/span&gt; is the log odds of the outcome &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; for individual &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; in cluster &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; during period &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;We start by defining the data structure using &lt;code&gt;simstudy&lt;/code&gt; “data def”&amp;quot; commands. We are assuming that there will be 100 individuals followed at each site for the full study. (We are not assuming any dropout, though we could easily do that.) In this particular case, we are assuming an effect size of 0.8 (which is a log odds ratio):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(simstudy)

starts &amp;lt;- &amp;quot;rep(c(2 : 5), each = 10)&amp;quot;

siteDef &amp;lt;- defData(varname = &amp;quot;bj&amp;quot;, dist = &amp;quot;normal&amp;quot;, formula = 0, 
                   variance = .01, id=&amp;quot;site&amp;quot;)
siteDef &amp;lt;- defData(siteDef, varname = &amp;quot;sj&amp;quot;, dist = &amp;quot;nonrandom&amp;quot;, 
                   formula = starts)
siteDef &amp;lt;- defData(siteDef, varname = &amp;quot;ips&amp;quot;, dist = &amp;quot;nonrandom&amp;quot;, 
                   formula = 100)

indDef &amp;lt;- defDataAdd(varname = &amp;quot;bi&amp;quot;, dist = &amp;quot;normal&amp;quot;, formula = 0,
                     variance = 0.01)

trtDef &amp;lt;- defDataAdd(varname = &amp;quot;Ijt&amp;quot; , 
                     formula = &amp;quot;as.numeric(period &amp;gt;= sj)&amp;quot;, 
                     dist = &amp;quot;nonrandom&amp;quot;)

f = &amp;quot;0.8 + .01 * period + 0.8 * Ijt + 0.001 * Ijt * (period-sj) + bi + bj&amp;quot;
trtDef &amp;lt;- defDataAdd(trtDef, varname = &amp;quot;Yijt&amp;quot;, formula = f, 
                     dist = &amp;quot;binary&amp;quot;, link = &amp;quot;logit&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To generate 40 clusters of data, we use the following code:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(6789)

dtSite &amp;lt;- genData(40, siteDef)
dtSite &amp;lt;- genCluster(dtSite, cLevelVar = &amp;quot;site&amp;quot;, numIndsVar = &amp;quot;ips&amp;quot;,
                     level1ID = &amp;quot;id&amp;quot;)
dtSite &amp;lt;- addColumns(indDef, dtSite)

dtSiteTm &amp;lt;- addPeriods(dtSite, nPeriods = 7, idvars = &amp;quot;id&amp;quot;)
dtSiteTm &amp;lt;- addColumns(trtDef, dtSiteTm)

dtSiteTm&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          id period site         bj sj ips         bi timeID Ijt Yijt
##     1:    1      0    1 -0.1029785  2 100 0.08926153      1   0    1
##     2:    1      1    1 -0.1029785  2 100 0.08926153      2   0    1
##     3:    1      2    1 -0.1029785  2 100 0.08926153      3   1    1
##     4:    1      3    1 -0.1029785  2 100 0.08926153      4   1    1
##     5:    1      4    1 -0.1029785  2 100 0.08926153      5   1    1
##    ---                                                              
## 27996: 4000      2   40  0.1000898  5 100 0.18869371  27996   0    1
## 27997: 4000      3   40  0.1000898  5 100 0.18869371  27997   0    0
## 27998: 4000      4   40  0.1000898  5 100 0.18869371  27998   0    1
## 27999: 4000      5   40  0.1000898  5 100 0.18869371  27999   1    1
## 28000: 4000      6   40  0.1000898  5 100 0.18869371  28000   1    1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And to visualize what the study data might looks like under these assumptions:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# summary by site
dt &amp;lt;- dtSiteTm[, .(Y = mean(Yijt)), keyby = .(site, period, Ijt, sj)] 

ggplot(data = dt, aes(x=period, y=Y, group=site)) +
  geom_hline(yintercept = c(.7, .83),  color = &amp;quot;grey99&amp;quot;) +
  geom_line(aes(color=factor(site))) +
  geom_point(data = dt[sj == period], color=&amp;quot;grey50&amp;quot;) +
  theme(panel.background = element_rect(fill = &amp;quot;grey90&amp;quot;), 
        panel.grid = element_blank(), 
        plot.title = element_text(size = 10, hjust = 0), 
        panel.border = element_rect(fill = NA, colour = &amp;quot;gray90&amp;quot;),
        legend.position = &amp;quot;none&amp;quot;,
        axis.title.x = element_blank()
  ) +
  ylab(&amp;quot;Proportion controlled&amp;quot;) +
  scale_x_continuous(breaks = seq(0, 10, by = 2), 
                     labels = c(&amp;quot;Baseline&amp;quot;, paste(&amp;quot;Year&amp;quot;, c(1:5)))) +
  scale_y_continuous(limits = c(.5, 1), 
                     breaks = c(.5, .6, .7, .8, .9, 1)) +
  ggtitle(&amp;quot;Stepped-wedge design with immediate effect&amp;quot;) +
  facet_grid(sj~.)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-07-10-using-simulation-for-power-analysis-an-example-based-on-a-stepped-wedge-study-design_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;480&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;estimating-power&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Estimating power&lt;/h2&gt;
&lt;p&gt;We are going to estimate power using only 20 clusters and effect size of 0.25. (Assuming 40 clusters and a large effect size was useful for visualizing the data, but not so interesting for illustrating power, since under those assumptions we are virtually guaranteed to find an effect.)&lt;/p&gt;
&lt;p&gt;After generating the data (code not shown) for one iteration, we fit a generalized mixed effects model to show the effect estimate. In this case, the effect estimate is 1.46 (95% CI 1.21-1.77) on the odds ratio scale or 0.37 (95% CI 0.19-0.57) on the log odds ratio scale.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(lme4)
library(sjPlot)

glmfit &amp;lt;- glmer(data = dtSiteTm, 
      Yijt ~ period + Ijt + I(Ijt*(period - sj)) + (1|id) + (1|site), 
      family=&amp;quot;binomial&amp;quot; )

sjt.glmer(glmfit, show.icc = FALSE, show.dev = FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;table style=&#34;border-collapse:collapse; border:none;border-bottom:double;&#34;&gt;
&lt;tr&gt;
&lt;td style=&#34;padding:0.2cm; border-top:double;&#34;&gt;
 
&lt;/td&gt;
&lt;td style=&#34;border-bottom:1px solid; padding-left:0.5em; padding-right:0.5em; border-top:double;&#34;&gt;
 
&lt;/td&gt;
&lt;td style=&#34;padding:0.2cm; text-align:center; border-bottom:1px solid; border-top:double;&#34; colspan=&#34;3&#34;&gt;
Yijt
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;padding:0.2cm; font-style:italic;&#34;&gt;
 
&lt;/td&gt;
&lt;td style=&#34;padding-left:0.5em; padding-right:0.5em; font-style:italic;&#34;&gt;
 
&lt;/td&gt;
&lt;td style=&#34;padding:0.2cm; text-align:center; font-style:italic; &#34;&gt;
Odds Ratio
&lt;/td&gt;
&lt;td style=&#34;padding:0.2cm; text-align:center; font-style:italic; &#34;&gt;
CI
&lt;/td&gt;
&lt;td style=&#34;padding:0.2cm; text-align:center; font-style:italic; &#34;&gt;
p
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&#34;5&#34; style=&#34;padding:0.2cm; text-align:left; border-top:1px solid; font-weight:bold; text-align:left;&#34;&gt;
Fixed Parts
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;padding:0.2cm; text-align:left;&#34;&gt;
(Intercept)
&lt;/td&gt;
&lt;td style=&#34;padding-left:0.5em; padding-right:0.5em; &#34;&gt;
 
&lt;/td&gt;
&lt;td style=&#34;padding:0.2cm; text-align:center; &#34;&gt;
2.15
&lt;/td&gt;
&lt;td style=&#34;padding:0.2cm; text-align:center; &#34;&gt;
1.90 – 2.44
&lt;/td&gt;
&lt;td style=&#34;padding:0.2cm; text-align:center; &#34;&gt;
&amp;lt;.001
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;padding:0.2cm; text-align:left;&#34;&gt;
period
&lt;/td&gt;
&lt;td style=&#34;padding-left:0.5em; padding-right:0.5em;&#34;&gt;
 
&lt;/td&gt;
&lt;td style=&#34;padding:0.2cm; text-align:center; &#34;&gt;
1.00
&lt;/td&gt;
&lt;td style=&#34;padding:0.2cm; text-align:center; &#34;&gt;
0.95 – 1.06
&lt;/td&gt;
&lt;td style=&#34;padding:0.2cm; text-align:center; &#34;&gt;
.959
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;padding:0.2cm; text-align:left;&#34;&gt;
Ijt
&lt;/td&gt;
&lt;td style=&#34;padding-left:0.5em; padding-right:0.5em;&#34;&gt;
 
&lt;/td&gt;
&lt;td style=&#34;padding:0.2cm; text-align:center; &#34;&gt;
1.46
&lt;/td&gt;
&lt;td style=&#34;padding:0.2cm; text-align:center; &#34;&gt;
1.21 – 1.77
&lt;/td&gt;
&lt;td style=&#34;padding:0.2cm; text-align:center; &#34;&gt;
&amp;lt;.001
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;padding:0.2cm; text-align:left;&#34;&gt;
I(Ijt * (period - sj))
&lt;/td&gt;
&lt;td style=&#34;padding-left:0.5em; padding-right:0.5em;&#34;&gt;
 
&lt;/td&gt;
&lt;td style=&#34;padding:0.2cm; text-align:center; &#34;&gt;
0.99
&lt;/td&gt;
&lt;td style=&#34;padding:0.2cm; text-align:center; &#34;&gt;
0.91 – 1.07
&lt;/td&gt;
&lt;td style=&#34;padding:0.2cm; text-align:center; &#34;&gt;
.759
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&#34;5&#34; style=&#34;padding:0.2cm; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left; font-weight:bold; text-align:left; padding-top:0.5em;&#34;&gt;
Random Parts
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;padding:0.2cm; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;&#34;&gt;
τ&lt;sub&gt;00, id&lt;/sub&gt;
&lt;/td&gt;
&lt;td style=&#34;padding-left:0.5em; padding-right:0.5em;&#34;&gt;
 
&lt;/td&gt;
&lt;td style=&#34;padding:0.2cm; text-align:center; padding-top:0.1cm; padding-bottom:0.1cm;&#34; colspan=&#34;3&#34;&gt;
0.011
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;padding:0.2cm; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;&#34;&gt;
τ&lt;sub&gt;00, site&lt;/sub&gt;
&lt;/td&gt;
&lt;td style=&#34;padding-left:0.5em; padding-right:0.5em;&#34;&gt;
 
&lt;/td&gt;
&lt;td style=&#34;padding:0.2cm; text-align:center; padding-top:0.1cm; padding-bottom:0.1cm;&#34; colspan=&#34;3&#34;&gt;
0.029
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;padding:0.2cm; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;&#34;&gt;
N&lt;sub&gt;id&lt;/sub&gt;
&lt;/td&gt;
&lt;td style=&#34;padding-left:0.5em; padding-right:0.5em;&#34;&gt;
 
&lt;/td&gt;
&lt;td style=&#34;padding:0.2cm; text-align:center; padding-top:0.1cm; padding-bottom:0.1cm;&#34; colspan=&#34;3&#34;&gt;
1000
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;padding:0.2cm; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left;&#34;&gt;
N&lt;sub&gt;site&lt;/sub&gt;
&lt;/td&gt;
&lt;td style=&#34;padding-left:0.5em; padding-right:0.5em;&#34;&gt;
 
&lt;/td&gt;
&lt;td style=&#34;padding:0.2cm; text-align:center; padding-top:0.1cm; padding-bottom:0.1cm;&#34; colspan=&#34;3&#34;&gt;
20
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;padding:0.2cm; padding-top:0.1cm; padding-bottom:0.1cm; text-align:left; border-top:1px solid;&#34;&gt;
Observations
&lt;/td&gt;
&lt;td style=&#34;padding-left:0.5em; padding-right:0.5em; border-top:1px solid;&#34;&gt;
 
&lt;/td&gt;
&lt;td style=&#34;padding:0.2cm; padding-top:0.1cm; padding-bottom:0.1cm; text-align:center; border-top:1px solid;&#34; colspan=&#34;3&#34;&gt;
7000
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;In order to estimate power, we need to generate a large number of replications. I created a simple function that generates a new data set every iteration based on the definitions. If we want to vary the model assumptions across different replications, we can write code to modify the data definition part of the process. In this way we could look at power across different sample size, effect size, or variance assumptions. Here, I am only considering a single set of assumptions.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gData &amp;lt;- function() {
  
  dtSite &amp;lt;- genData(nsites, siteDef)
  dtSite &amp;lt;- genCluster(dtSite, cLevelVar = &amp;quot;site&amp;quot;, 
                       numIndsVar = &amp;quot;ips&amp;quot;, level1ID = &amp;quot;id&amp;quot;)
  dtSite &amp;lt;- addColumns(indDef, dtSite)
  
  dtSiteTm &amp;lt;- addPeriods(dtSite, nPeriods = 7, idvars = &amp;quot;id&amp;quot;)
  dtSiteTm &amp;lt;- addColumns(trtDef, dtSiteTm)
  
  return(dtSiteTm)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And finally, we iterate through a series of replications, keeping track of each hypothesis test in the variable &lt;em&gt;result&lt;/em&gt;. Typically, it would be nice to replicate a large number of times (say 1000), but this can sometimes take a long time. In this case, each call to &lt;code&gt;glmer&lt;/code&gt; is very resource intensive - unfortunately, I know of know way to speed this up (please get in touch if you have thoughts on this) - so for the purposes of illustration, I’ve only used 99 iterations. Note also that I check to see if the model converges in each iteration, and only include results from valid estimates. This can be an issue with mixed effects models, particularly when sample sizes are small. To estimate the power (which in this case is 78%), calculate the proportion of successful iterations with a p-value smaller than 0.05, the alpha-level threshold we have used in our hypothesis test:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;result &amp;lt;- NULL

i=1

while (i &amp;lt; 100) {
  
  dtSite &amp;lt;- gData()
  
  glmfit &amp;lt;- tryCatch(glmer(data = dtSite, 
      Yijt ~ period + Ijt + I(Ijt*(period - sj)) + (1|id) + (1|site), 
      family=&amp;quot;binomial&amp;quot; ),
    warning = function(w) { &amp;quot;warning&amp;quot; }
  )
  
  if (! is.character(glmfit)) {
    
    pvalue &amp;lt;- coef(summary(glmfit))[&amp;quot;Ijt&amp;quot;, &amp;quot;Pr(&amp;gt;|z|)&amp;quot;]
    result &amp;lt;- c(result, pvalue)
    i &amp;lt;- i + 1
  }
  
}

mean(result &amp;lt; .05)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.7812&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To explore the sensitivity of the power estimates to changing underlying assumptions of effect size, sample size, variation, and time trends, we could vary those parameters and run a sequence of iterations. The code gets a little more complicated (essentially we need to change the “data defs” for each set of iterations), but it is still quite manageable. Of course, you might want to plan for fairly long execution times, particularly if you use 500 or 1000 iterations for each scenario, rather than the 100 I used here.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>simstudy update: two new functions that generate correlated observations from non-normal distributions</title>
      <link>/post/simstudy-update-two-functions-for-correlation/</link>
      <pubDate>Wed, 05 Jul 2017 00:00:00 +0000</pubDate>
      <author>keith.goldfeld@nyumc.org (Keith Goldfeld)</author>
      <guid>/post/simstudy-update-two-functions-for-correlation/</guid>
      <description>&lt;p&gt;In an earlier &lt;a href=&#34;https://www.rdatagen.net/post/correlated-data-copula/&#34;&gt;post&lt;/a&gt;, I described in a fair amount of detail an algorithm to generate correlated binary or Poisson data. I mentioned that I would be updating &lt;code&gt;simstudy&lt;/code&gt; with functions that would make generating these kind of data relatively painless. Well, I have managed to do that, and the updated package (version 0.1.3) is available for download from &lt;a href=&#34;https://cran.r-project.org/web/packages/simstudy/index.html&#34;&gt;CRAN&lt;/a&gt;. There are now two additional functions to facilitate the generation of correlated data from &lt;em&gt;binomial&lt;/em&gt;, &lt;em&gt;poisson&lt;/em&gt;, &lt;em&gt;gamma&lt;/em&gt;, and &lt;em&gt;uniform&lt;/em&gt; distributions: &lt;code&gt;genCorGen&lt;/code&gt; and &lt;code&gt;addCorGen&lt;/code&gt;. Here’s a brief intro to these functions.&lt;/p&gt;
&lt;div id=&#34;generate-generally-correlated-data&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Generate generally correlated data&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;genCorGen&lt;/code&gt; is an extension of &lt;code&gt;genCorData&lt;/code&gt;, which was provided in earlier versions of &lt;code&gt;simstudy&lt;/code&gt; to generate multivariate normal data. In the first example below, we are generating data from a multivariate Poisson distribution. To do this, we need to specify the mean of the Poisson distribution for each new variable, and then we specify the correlation structure, just as we did with the normal distribution.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;l &amp;lt;- c(8, 10, 12) # lambda for each new variable

dp &amp;lt;- genCorGen(1000, nvars = 3, params1 = l, dist = &amp;quot;poisson&amp;quot;, 
                rho = 0.3, corstr = &amp;quot;cs&amp;quot;, wide = TRUE)
dp&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         id V1 V2 V3
##    1:    1  7 13 12
##    2:    2  7 11 13
##    3:    3  7  8 14
##    4:    4  7 12  9
##    5:    5  8 13 18
##   ---              
##  996:  996  8 14 15
##  997:  997 10  5 11
##  998:  998  4  9  9
##  999:  999  5 10  9
## 1000: 1000  6 12 17&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here is the the estimated correlation (we would expect an estimate close to 0.3):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;round(cor(as.matrix(dp[, .(V1, V2, V3)])), 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      V1   V2   V3
## V1 1.00 0.29 0.26
## V2 0.29 1.00 0.31
## V3 0.26 0.31 1.00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Similarly, we can generate correlated binary data by specifying the probabilities:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;db&amp;lt;- genCorGen(1000, nvars = 3, params1 = c(.3, .5, .7), dist = &amp;quot;binary&amp;quot;, 
          rho = 0.8, corstr = &amp;quot;cs&amp;quot;, wide = TRUE)
db&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         id V1 V2 V3
##    1:    1  1  1  1
##    2:    2  0  0  1
##    3:    3  1  1  1
##    4:    4  0  0  0
##    5:    5  1  1  1
##   ---              
##  996:  996  0  1  1
##  997:  997  0  0  0
##  998:  998  0  1  1
##  999:  999  1  1  1
## 1000: 1000  0  0  0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the case of the binary outcome, the observed correlation will be lower that what is specified, which in this case was 0.8. I tried to provide some intuition about this in the earlier &lt;a href=&#34;https://www.rdatagen.net/post/correlated-data-copula/&#34;&gt;post&lt;/a&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;round(cor(as.matrix(db[, .(V1, V2, V3)])), 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     V1   V2   V3
## V1 1.0 0.50 0.40
## V2 0.5 1.00 0.56
## V3 0.4 0.56 1.00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The gamma distribution requires two parameters - the mean and dispersion. (These are converted into shape and rate parameters more commonly used.)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dg &amp;lt;- genCorGen(1000, nvars = 3, params1 = c(3,5,7), params2 = c(1,1,1),
                dist = &amp;quot;gamma&amp;quot;, rho = .7, corstr = &amp;quot;cs&amp;quot;, 
                wide = TRUE, cnames=&amp;quot;a, b, c&amp;quot;)
dg&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         id         a          b         c
##    1:    1 0.1957971  0.9902398  2.299307
##    2:    2 0.2566630  2.4271728  1.217599
##    3:    3 1.9550985 13.9248696  5.178042
##    4:    4 3.5525418  2.5711661  7.848605
##    5:    5 6.6981281  8.7494117 12.478329
##   ---                                    
##  996:  996 2.2059693  6.3474811  3.054551
##  997:  997 2.3571427  7.7841085  7.887417
##  998:  998 5.5326638  7.3273337 15.965228
##  999:  999 5.6284681 13.3574118 17.215722
## 1000: 1000 0.3749373  1.1480452  0.696243&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;round(cor(as.matrix(dg[, .(a, b, c)])), 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      a    b    c
## a 1.00 0.65 0.67
## b 0.65 1.00 0.62
## c 0.67 0.62 1.00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These data sets can be generated in either &lt;em&gt;wide&lt;/em&gt; or &lt;em&gt;long&lt;/em&gt; form. So far, we have generated &lt;em&gt;wide&lt;/em&gt; form data, where there is one row per unique id. The &lt;em&gt;long&lt;/em&gt; form, where the correlated data are on different rows, is useful for plotting or fitting models, because there are repeated measurements for each id:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dgl &amp;lt;- genCorGen(1000, nvars = 3, params1 = l, params2 = c(1,1,1), 
                 dist = &amp;quot;gamma&amp;quot;, rho = .7, corstr = &amp;quot;cs&amp;quot;, wide = FALSE, 
                 cnames=&amp;quot;NewCol&amp;quot;)
dgl&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         id period    NewCol
##    1:    1      0  1.066558
##    2:    1      1  5.666802
##    3:    1      2  5.366408
##    4:    2      0  1.419593
##    5:    2      1  9.318227
##   ---                      
## 2996:  999      1 21.821011
## 2997:  999      2 21.800972
## 2998: 1000      0 12.082063
## 2999: 1000      1 18.541231
## 3000: 1000      2 12.063846&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here is a plot of a subset of the data:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ids &amp;lt;- sample(1000,50, replace = FALSE)
ggplot(data=dgl[id %in% ids,], aes(x=factor(period), y=NewCol, group=id)) +
  geom_line(aes(color=factor(id)))+
  theme(legend.position = &amp;quot;none&amp;quot;) +
  scale_x_discrete(expand = c(0,0.1))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-07-05-simstudy-update-two-functions-to-generate-correlated-observations-from-non-normal-distributions_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;generate-data-based-on-values-from-existing-data-set&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Generate data based on values from existing data set&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;addCorGen&lt;/code&gt; allows us to create correlated data from an existing data set, as one can already do using &lt;code&gt;addCorData&lt;/code&gt;, but with non-normal data. In the case of &lt;code&gt;addCorGen&lt;/code&gt;, the parameter(s) used to define the distribution is a field (or fields) in the data set. The correlated data are added to the existing data set. In the example below, we are going to generate three sets (Poisson, binary, and gamma) of correlated data with means that are a function of the variable &lt;code&gt;xbase&lt;/code&gt;, which varies by id.&lt;/p&gt;
&lt;p&gt;First we define the data and generate a data set:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;def &amp;lt;- defData(varname = &amp;quot;xbase&amp;quot;, formula = 5, variance = 0.2, 
               dist = &amp;quot;gamma&amp;quot;, id = &amp;quot;cid&amp;quot;)
def &amp;lt;- defData(def, varname = &amp;quot;lambda&amp;quot;, formula = &amp;quot;0.5 + 0.1 * xbase&amp;quot;, 
               dist=&amp;quot;nonrandom&amp;quot;, link = &amp;quot;log&amp;quot;)
def &amp;lt;- defData(def, varname = &amp;quot;p&amp;quot;, formula = &amp;quot;-2.0 + 0.3 * xbase&amp;quot;, 
               dist=&amp;quot;nonrandom&amp;quot;, link = &amp;quot;logit&amp;quot;)
def &amp;lt;- defData(def, varname = &amp;quot;gammaMu&amp;quot;, formula = &amp;quot;0.5 + 0.2 * xbase&amp;quot;, 
               dist=&amp;quot;nonrandom&amp;quot;, link = &amp;quot;log&amp;quot;)
def &amp;lt;- defData(def, varname = &amp;quot;gammaDis&amp;quot;, formula = 1, 
               dist=&amp;quot;nonrandom&amp;quot;)

dt &amp;lt;- genData(10000, def)
dt&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          cid      xbase   lambda         p   gammaMu gammaDis
##     1:     1 12.1128232 5.536056 0.8366960 18.588900        1
##     2:     2  4.9148342 2.695230 0.3715554  4.405998        1
##     3:     3 11.5550282 5.235712 0.8125261 16.626630        1
##     4:     4  3.0802596 2.243475 0.2542785  3.052778        1
##     5:     5  0.9767811 1.817893 0.1535577  2.004423        1
##    ---                                                       
##  9996:  9996  6.0564517 3.021173 0.4543613  5.536100        1
##  9997:  9997  3.1298866 2.254636 0.2571119  3.083229        1
##  9998:  9998 12.4642670 5.734076 0.8505956 19.942505        1
##  9999:  9999  4.6559318 2.626345 0.3536072  4.183660        1
## 10000: 10000  3.4314285 2.323658 0.2747666  3.274895        1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Poisson distribution has a single parameter, lambda:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dtX1 &amp;lt;- addCorGen(dtOld = dt, idvar = &amp;quot;cid&amp;quot;, nvars = 3, rho = 0.1, 
                  corstr = &amp;quot;cs&amp;quot;, dist = &amp;quot;poisson&amp;quot;, param1 = &amp;quot;lambda&amp;quot;, 
                  cnames = &amp;quot;a, b, c&amp;quot;)

dtX1[, .(cid, xbase, lambda, a, b, c)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          cid      xbase   lambda a b c
##     1:     1 12.1128232 5.536056 4 6 7
##     2:     2  4.9148342 2.695230 2 4 1
##     3:     3 11.5550282 5.235712 5 6 4
##     4:     4  3.0802596 2.243475 1 3 1
##     5:     5  0.9767811 1.817893 2 1 0
##    ---                                
##  9996:  9996  6.0564517 3.021173 1 3 3
##  9997:  9997  3.1298866 2.254636 2 3 1
##  9998:  9998 12.4642670 5.734076 4 6 8
##  9999:  9999  4.6559318 2.626345 2 3 5
## 10000: 10000  3.4314285 2.323658 0 0 3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Bernoulli (binary) distribution has a single parameter, p:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dtX2 &amp;lt;- addCorGen(dtOld = dt, idvar = &amp;quot;cid&amp;quot;, nvars = 4, rho = .4, 
                  corstr = &amp;quot;ar1&amp;quot;, dist = &amp;quot;binary&amp;quot;, param1 = &amp;quot;p&amp;quot;)

dtX2[, .(cid, xbase, p, V1, V2, V3, V4)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          cid      xbase         p V1 V2 V3 V4
##     1:     1 12.1128232 0.8366960  1  1  1  1
##     2:     2  4.9148342 0.3715554  0  0  0  0
##     3:     3 11.5550282 0.8125261  1  1  1  1
##     4:     4  3.0802596 0.2542785  0  1  0  0
##     5:     5  0.9767811 0.1535577  0  0  0  1
##    ---                                       
##  9996:  9996  6.0564517 0.4543613  0  0  0  0
##  9997:  9997  3.1298866 0.2571119  1  0  0  0
##  9998:  9998 12.4642670 0.8505956  0  1  1  1
##  9999:  9999  4.6559318 0.3536072  1  1  0  0
## 10000: 10000  3.4314285 0.2747666  1  0  1  1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And here is the the Gamma distribution, with its two parameters (mean and dispersion):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dtX3 &amp;lt;- addCorGen(dtOld = dt, idvar = &amp;quot;cid&amp;quot;, nvars = 3, rho = .4, 
                  corstr = &amp;quot;cs&amp;quot;, dist = &amp;quot;gamma&amp;quot;, 
                  param1 = &amp;quot;gammaMu&amp;quot;, param2 = &amp;quot;gammaDis&amp;quot;)

dtX3[, .(cid, xbase, gammaMu, gammaDis, 
         V1 = round(V1,2), V2 = round(V2,2), V3 = round(V3,2))]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          cid      xbase   gammaMu gammaDis    V1    V2   V3
##     1:     1 12.1128232 18.588900        1 11.24  3.44 9.11
##     2:     2  4.9148342  4.405998        1  0.91  3.77 0.76
##     3:     3 11.5550282 16.626630        1 68.47 12.91 1.72
##     4:     4  3.0802596  3.052778        1  2.54  3.63 2.98
##     5:     5  0.9767811  2.004423        1  0.39  0.14 0.42
##    ---                                                     
##  9996:  9996  6.0564517  5.536100        1  0.29  4.84 1.80
##  9997:  9997  3.1298866  3.083229        1  4.81  0.38 0.81
##  9998:  9998 12.4642670 19.942505        1 17.10  3.56 4.04
##  9999:  9999  4.6559318  4.183660        1  1.17  0.21 1.47
## 10000: 10000  3.4314285  3.274895        1  1.02  1.61 2.24&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;long-form-data&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Long form data&lt;/h3&gt;
&lt;p&gt;If we have data in &lt;em&gt;long&lt;/em&gt; form (e.g. longitudinal data), the function will recognize the structure:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;def &amp;lt;- defData(varname = &amp;quot;xbase&amp;quot;, formula = 5, variance = .4, 
               dist = &amp;quot;gamma&amp;quot;, id = &amp;quot;cid&amp;quot;)
def &amp;lt;- defData(def, &amp;quot;nperiods&amp;quot;, formula = 3, 
               dist = &amp;quot;noZeroPoisson&amp;quot;)

def2 &amp;lt;- defDataAdd(varname = &amp;quot;lambda&amp;quot;, 
                   formula = &amp;quot;0.5 + 0.5 * period + 0.1 * xbase&amp;quot;, 
                   dist=&amp;quot;nonrandom&amp;quot;, link = &amp;quot;log&amp;quot;)

dt &amp;lt;- genData(1000, def)

dtLong &amp;lt;- addPeriods(dt, idvars = &amp;quot;cid&amp;quot;, nPeriods = 3)
dtLong &amp;lt;- addColumns(def2, dtLong)

dtLong&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        cid period     xbase nperiods timeID   lambda
##    1:    1      0  6.693980        1      1 3.220053
##    2:    1      1  6.693980        1      2 5.308971
##    3:    1      2  6.693980        1      3 8.753013
##    4:    2      0 10.008645        2      4 4.485565
##    5:    2      1 10.008645        2      5 7.395447
##   ---                                               
## 2996:  999      1  6.753605        2   2996 5.340720
## 2997:  999      2  6.753605        2   2997 8.805359
## 2998: 1000      0  2.006781        4   2998 2.015119
## 2999: 1000      1  2.006781        4   2999 3.322369
## 3000: 1000      2  2.006781        4   3000 5.477661&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;### Generate the data 

dtX3 &amp;lt;- addCorGen(dtOld = dtLong, idvar = &amp;quot;cid&amp;quot;, nvars = 3, 
                  rho = .6, corstr = &amp;quot;cs&amp;quot;, dist = &amp;quot;poisson&amp;quot;, 
                  param1 = &amp;quot;lambda&amp;quot;, cnames = &amp;quot;NewPois&amp;quot;)
dtX3&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        cid period     xbase nperiods timeID   lambda NewPois
##    1:    1      0  6.693980        1      1 3.220053       3
##    2:    1      1  6.693980        1      2 5.308971       5
##    3:    1      2  6.693980        1      3 8.753013       9
##    4:    2      0 10.008645        2      4 4.485565       2
##    5:    2      1 10.008645        2      5 7.395447       4
##   ---                                                       
## 2996:  999      1  6.753605        2   2996 5.340720       6
## 2997:  999      2  6.753605        2   2997 8.805359      11
## 2998: 1000      0  2.006781        4   2998 2.015119       2
## 2999: 1000      1  2.006781        4   2999 3.322369       4
## 3000: 1000      2  2.006781        4   3000 5.477661       7&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can fit a generalized estimating equation (GEE) model and examine the coefficients and the working correlation matrix. As we would expect, they match closely to the data generating parameters:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;geefit &amp;lt;- gee(NewPois ~ period + xbase, data = dtX3, id = cid, 
              family = poisson, corstr = &amp;quot;exchangeable&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Beginning Cgee S-function, @(#) geeformula.q 4.13 98/01/27&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## running glm to get initial regression estimate&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## (Intercept)      period       xbase 
##  0.52045259  0.50354885  0.09746544&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;round(summary(geefit)$working.correlation, 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3]
## [1,] 1.00 0.58 0.58
## [2,] 0.58 1.00 0.58
## [3,] 0.58 0.58 1.00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the future, I plan on adding other distributions. Some folks have suggested the negative binomial distribution, which I will do. If you have other suggestions/requests, &lt;a href=&#34;mailto:keith.goldfeld@nyumc.org&#34;&gt;let me know&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Balancing on multiple factors when the sample is too small to stratify </title>
      <link>/post/balancing-when-sample-is-too-small-to-stratify/</link>
      <pubDate>Mon, 26 Jun 2017 00:00:00 +0000</pubDate>
      <author>keith.goldfeld@nyumc.org (Keith Goldfeld)</author>
      <guid>/post/balancing-when-sample-is-too-small-to-stratify/</guid>
      <description>&lt;p&gt;Ideally, a study that uses randomization provides a balance of characteristics that might be associated with the outcome being studied. This way, we can be more confident that any differences in outcomes between the groups are due to the group assignments and not to differences in characteristics. Unfortunately, randomization does not &lt;em&gt;guarantee&lt;/em&gt; balance, especially with smaller sample sizes. If we want to be certain that groups are balanced with respect to a particular characteristic, we need to do something like stratified randomization.&lt;/p&gt;
&lt;p&gt;When the sample size is small and we want to guarantee balance across &lt;em&gt;multiple&lt;/em&gt; characteristics, the task is a bit more challenging. Say we have 20 schools that we are randomizing to two groups, 10 in each, and want to make sure the groups are balanced with respect to 4 characteristics: language, poverty, location, and size. Simple stratification may not work so well. If we assume that these four characteristics are binary (e.g. either “yes” or “no”), there are 16 possible combinations. One or more of these combinations could easily be represented by a single school - so it would be impossible to randomize within each of the 16 combinations. What to do?&lt;/p&gt;
&lt;p&gt;One possible approach is to generate all possible randomization schemes of the 20 schools, and keep only those schemes that are balanced with respect to the four characteristics. Once we have a list of acceptable randomization schemes, we can just pick one of &lt;em&gt;those&lt;/em&gt; at random. (Of course, it is preferable if each school has close to a 50% chance of being assigned to either intervention group.)&lt;/p&gt;
&lt;div id=&#34;simulate-school-level-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Simulate school-level data&lt;/h2&gt;
&lt;p&gt;To start, we generate data for our 20 hypothetical schools using &lt;code&gt;simstudy&lt;/code&gt; functions:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(simstudy)
set.seed(125)

# define data characteristics for schools
ddef &amp;lt;- defData(varname = &amp;quot;language&amp;quot;, formula = .3, dist = &amp;quot;binary&amp;quot;)
ddef &amp;lt;- defData(ddef, &amp;quot;poverty&amp;quot;, formula = .2, dist = &amp;quot;binary&amp;quot;)
ddef &amp;lt;- defData(ddef, &amp;quot;location&amp;quot;, formula = .5, dist = &amp;quot;binary&amp;quot;)
ddef &amp;lt;- defData(ddef, &amp;quot;size&amp;quot;, formula = .5, dist = &amp;quot;binary&amp;quot;)
ddef&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     varname formula variance   dist     link
## 1: language     0.3        0 binary identity
## 2:  poverty     0.2        0 binary identity
## 3: location     0.5        0 binary identity
## 4:     size     0.5        0 binary identity&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# generate schools
dt &amp;lt;- genData(20, ddef)

# number of schools in each combination
dt[, .N, keyby = .(language,poverty,location,size)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    language poverty location size N
## 1:        0       0        0    1 5
## 2:        0       0        1    0 1
## 3:        0       0        1    1 5
## 4:        0       1        0    0 1
## 5:        0       1        1    0 2
## 6:        1       0        0    0 2
## 7:        1       0        0    1 1
## 8:        1       0        1    0 1
## 9:        1       0        1    1 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, we have nine different combinations of the four characteristics, four of which include only a single school (rows 2, 4, 7, and 8). Stratification wouldn’t work necessarily work here if our goal was balance across all four characteristics.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;create-randomization-scenarios-to-assess-for-balance&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Create randomization scenarios to assess for balance&lt;/h2&gt;
&lt;p&gt;Ideally, we would generate all possible randomization combinations and check them all for balance. If the number of total units (e.g. schools) is small, this does not pose a challenge (e.g. if N=4, then we only have six possible randomization schemes: TTCC, TCTC, TCCT, CTTC, CTCT, CCTT). However, with N=20, then there are 184,756 possible randomization schemes. Depending on the efficiency of the algorithm, it may be impractical to evaluate all the schemes. So, an alternative is to sample a subset of the schemes and evaluate those. For illustration purposes (so that you can understand what I am doing), I am using some very inefficient &lt;code&gt;R&lt;/code&gt; code (using a loops). As a result, I cannot evaluate all possible schemes in a reasonable period of time to get this post out; I decided to sample instead to evaluate 1000 possible randomizations. (At the end of this post, I show results using much more efficient code that uses data.table and Rcpp code much more effectively - so that we can quickly evaluate millions of randomization schemes.)&lt;/p&gt;
&lt;p&gt;To start, I create all combinations of randomization schemes:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;totalSchools = 20
rxSchools = 10

xRx &amp;lt;- t(combn(totalSchools, rxSchools)) 

# show 5 randomly sampled combinations

sampleRows &amp;lt;- sample(nrow(xRx), 5, replace = FALSE)
xRx[sampleRows,]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
## [1,]    2    3    5    6    7    8   10   12   14    19
## [2,]    5    6    7    8   13   14   15   16   17    18
## [3,]    1    3    4    5    7    9   12   15   17    20
## [4,]    2    3    4    5    9   11   14   15   19    20
## [5,]    3    5    6    7    8   10   11   12   15    16&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Below is a function (which I chose to do in Rcpp) that converts the &lt;code&gt;xRx&lt;/code&gt; matrix of school ids to a 20-column matrix of 1’s and 0’s indicating whether or not a school is randomized to the intervention in a particular scenario:&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;RcppArmadillo.h&amp;gt;

// [[Rcpp::depends(RcppArmadillo)]]

using namespace Rcpp;
using namespace arma;

// [[Rcpp::export]]

NumericMatrix convert01(NumericMatrix xmat, int tcols) {
  
  int xrows = xmat.nrow();
  int xcols = xmat.ncol();
  
  NumericMatrix pmat(xrows, tcols);
  
  for (int i=0; i &amp;lt; xrows; i++) {
    for (int j=0; j &amp;lt; xcols; j++)  {
      pmat(i, xmat(i,j) - 1) = 1; 
    }
  } 
  return(pmat);
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x01 &amp;lt;- convert01(xRx, totalSchools)

# show some rows

x01[sampleRows,]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
## [1,]    0    1    1    0    1    1    1    1    0     1     0     1
## [2,]    0    0    0    0    1    1    1    1    0     0     0     0
## [3,]    1    0    1    1    1    0    1    0    1     0     0     1
## [4,]    0    1    1    1    1    0    0    0    1     0     1     0
## [5,]    0    0    1    0    1    1    1    1    0     1     1     1
##      [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20]
## [1,]     0     1     0     0     0     0     1     0
## [2,]     1     1     1     1     1     1     0     0
## [3,]     0     0     1     0     1     0     0     1
## [4,]     0     1     1     0     0     0     1     1
## [5,]     0     0     1     1     0     0     0     0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Because the evaluation code is so inefficient, I draw 1,000 rows at random from this “intervention” matrix &lt;code&gt;x01&lt;/code&gt; (after converting it to a data.table).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# convert matrix to data.table
d01 &amp;lt;- data.table(x01)
d01[, id := .I]

ids &amp;lt;- sample(nrow(d01), 1000, replace = FALSE)
sampleD01 &amp;lt;- d01[id %in% ids]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we are ready to evaluate each of the 1,000 schemes. As I mentioned before, this approach is highly inefficient as the algorithm requires us to literally loop through each each combination to find the balanced ones. I have sacrificed efficiency and speed for clarity of code (I hope).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;for (i in 1:1000) {
  
  dt[, grp:= t(sampleD01[i,1:20])]
  
  dx &amp;lt;- dt[ , .N, keyby = .(language, grp)]
  dc &amp;lt;- dcast(dx, language ~ grp, fill = 0, value.var = &amp;quot;N&amp;quot; )
  dc[, diff := abs(`1` - `0`)]
  
  # we declare a scheme balanced if counts differ by
  # no more than 1 school
  
  sampleD01[i, language := (sum(dc[, diff &amp;gt; 1]) == 0)]
  
  dx &amp;lt;- dt[ , .N, keyby = .(poverty, grp)]
  dc &amp;lt;- dcast(dx, poverty ~ grp, fill = 0, value.var = &amp;quot;N&amp;quot; )
  dc[, diff := abs(`1` - `0`)]
  
  sampleD01[i, poverty := (sum(dc[, diff &amp;gt; 1]) == 0)]
  
  dx &amp;lt;- dt[ , .N, keyby = .(location, grp)]
  dc &amp;lt;- dcast(dx, location ~ grp, fill = 0, value.var = &amp;quot;N&amp;quot; )
  dc[, diff := abs(`1` - `0`)]
  
  sampleD01[i, location := (sum(dc[, diff &amp;gt; 1]) == 0)]
  
  dx &amp;lt;- dt[ , .N, keyby = .(size, grp)]
  dc &amp;lt;- dcast(dx, size ~ grp, fill = 0, value.var = &amp;quot;N&amp;quot; )
  dc[, diff := abs(`1` - `0`)]
  
  sampleD01[i, size := (sum(dc[, diff &amp;gt; 1]) == 0)]
  
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The final determination of balance is made if a scheme is balanced across all four characteristics. In this case, 136 of the 1,000 schemes were balanced based on this criterion:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sampleD01[, balanced := all(language, poverty, location, size), keyby = id]

# proportion of sampled combinations that are balanced ...

sampleD01[,mean(balanced)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.136&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And let’s inspect the actual balance of two randomly selected schemes - one which is balanced, and one which is not:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sTrue &amp;lt;- sampleD01[balanced == TRUE]
sFalse &amp;lt;- sampleD01[balanced == FALSE]&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;a-balanced-scheme&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;A balanced scheme&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dtAssigned &amp;lt;- copy(dt)
dtAssigned[, group := as.vector(t(sTrue[sample(.N, 1), 1:20]))]

dtAssigned[, .N, keyby=.(language, group)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    language group N
## 1:        0     0 7
## 2:        0     1 7
## 3:        1     0 3
## 4:        1     1 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dtAssigned[, .N, keyby=.(poverty, group)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    poverty group N
## 1:       0     0 9
## 2:       0     1 8
## 3:       1     0 1
## 4:       1     1 2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dtAssigned[, .N, keyby=.(location, group)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    location group N
## 1:        0     0 4
## 2:        0     1 5
## 3:        1     0 6
## 4:        1     1 5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dtAssigned[, .N, keyby=.(size, group)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    size group N
## 1:    0     0 3
## 2:    0     1 4
## 3:    1     0 7
## 4:    1     1 6&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;an-unbalanced-scheme&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;An unbalanced scheme&lt;/h3&gt;
&lt;p&gt;In this case, language and location are imbalanced, though size and poverty are fine.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dtAssigned &amp;lt;- copy(dt)
dtAssigned[, group := as.vector(t(sFalse[sample(.N, 1), 1:20]))]

dtAssigned[, .N, keyby=.(language, group)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    language group N
## 1:        0     0 8
## 2:        0     1 6
## 3:        1     0 2
## 4:        1     1 4&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dtAssigned[, .N, keyby=.(poverty, group)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    poverty group N
## 1:       0     0 8
## 2:       0     1 9
## 3:       1     0 2
## 4:       1     1 1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dtAssigned[, .N, keyby=.(location, group)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    location group N
## 1:        0     0 3
## 2:        0     1 6
## 3:        1     0 7
## 4:        1     1 4&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dtAssigned[, .N, keyby=.(size, group)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    size group N
## 1:    0     0 4
## 2:    0     1 3
## 3:    1     0 6
## 4:    1     1 7&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;fast-implementation-with-data.table-and-rcpp&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Fast implementation with data.table and Rcpp&lt;/h2&gt;
&lt;p&gt;As I alluded to before, if we want to implement this in the real world, it would be preferable to use code that does not bog down when we want to search 100,000+ possible randomization schemes. I have written a set of &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;Rcpp&lt;/code&gt; functions the facilitate this. (Code is available &lt;a href=&#34;https://github.com/kgoldfeld/RDataGenBlog/tree/master/static/img/post-balance&#34;&gt;here&lt;/a&gt;.)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# generate all possible schemes

xperm &amp;lt;- xPerms(totalSchools, rxSchools, N=NULL) 

nrow(xperm)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 184756&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;xperm[sample(nrow(xperm), 5, replace = FALSE)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    V1 V2 V3 V4 V5 V6 V7 V8 V9 V10 V11 V12 V13 V14 V15 V16 V17 V18 V19
## 1:  0  1  1  1  1  0  1  1  0   0   0   1   0   1   0   0   0   1   0
## 2:  1  1  0  1  1  1  1  1  0   1   0   0   0   0   1   0   1   0   0
## 3:  1  0  1  0  0  1  1  1  1   1   1   0   1   0   0   1   0   0   0
## 4:  1  1  1  0  0  1  0  1  0   1   1   1   1   0   0   1   0   0   0
## 5:  1  1  0  0  1  0  0  1  1   1   1   0   1   0   0   0   1   1   0
##    V20    id
## 1:   1 94784
## 2:   0 19535
## 3:   0 61644
## 4:   0 14633
## 5:   0 35651&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# prepare data for evaluation

dtMat &amp;lt;- as.matrix(dt[,-1])
cc &amp;lt;- parse(text=attr(xperm, &amp;quot;varlist&amp;quot;))
cc&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## expression(c(V1, V2, V3, V4, V5, V6, V7, V8, V9, V10, V11, V12, 
##     V13, V14, V15, V16, V17, V18, V19, V20))&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# evaluate each combination

sF &amp;lt;-  xperm[, cppChk(eval(cc), dtMat), keyby = id]
sF[sample(nrow(sF), 5, replace = FALSE)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        id    V1
## 1:  15924 FALSE
## 2:  68284 FALSE
## 3: 149360 FALSE
## 4:  62924 FALSE
## 5:  14009  TRUE&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# keep only the balanced schemes

sFinal &amp;lt;- xperm[sF$V1]
nrow(sFinal)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 7742&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# randomize from the balanced schemes

selectRow &amp;lt;- sample(nrow(sFinal), 1)

# check balance of randomized scheme

dtAssigned &amp;lt;- copy(dt)
dtAssigned[, group := as.vector(t(sFinal[selectRow, -&amp;quot;id&amp;quot;]))]

dtAssigned[, .N, keyby=.(language, group)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    language group N
## 1:        0     0 7
## 2:        0     1 7
## 3:        1     0 3
## 4:        1     1 3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dtAssigned[, .N, keyby=.(poverty, group)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    poverty group N
## 1:       0     0 9
## 2:       0     1 8
## 3:       1     0 1
## 4:       1     1 2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dtAssigned[, .N, keyby=.(location, group)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    location group N
## 1:        0     0 5
## 2:        0     1 4
## 3:        1     0 5
## 4:        1     1 6&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dtAssigned[, .N, keyby=.(size, group)]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    size group N
## 1:    0     0 3
## 2:    0     1 4
## 3:    1     0 7
## 4:    1     1 6&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Copulas and correlated data generation: getting beyond the normal distribution</title>
      <link>/post/correlated-data-copula/</link>
      <pubDate>Mon, 19 Jun 2017 00:00:00 +0000</pubDate>
      <author>keith.goldfeld@nyumc.org (Keith Goldfeld)</author>
      <guid>/post/correlated-data-copula/</guid>
      <description>&lt;p&gt;Using the &lt;code&gt;simstudy&lt;/code&gt; package, it’s possible to generate correlated data from a normal distribution using the function &lt;em&gt;genCorData&lt;/em&gt;. I’ve wanted to extend the functionality so that we can generate correlated data from other sorts of distributions; I thought it would be a good idea to begin with binary and Poisson distributed data, since those come up so frequently in my work. &lt;code&gt;simstudy&lt;/code&gt; can already accommodate more general correlated data, but only in the context of a random effects data generation process. This might not be what we want, particularly if we are interested in explicitly generating data to explore marginal models (such as a GEE model) rather than a conditional random effects model (a topic I explored in my &lt;a href=&#34;https://www.rdatagen.net/post/marginal-v-conditional/&#34;&gt;previous&lt;/a&gt; discussion). The extension can quite easily be done using &lt;em&gt;copulas&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Based on &lt;a href=&#34;https://en.wikipedia.org/wiki/Copula_%28probability_theory%29&#34;&gt;this&lt;/a&gt; definition, a copula is a “multivariate probability distribution for which the marginal probability distribution of each variable is uniform.” It can be shown that &lt;span class=&#34;math inline&#34;&gt;\(U\)&lt;/span&gt; is uniformly distributed if &lt;span class=&#34;math inline&#34;&gt;\(U=F(X)\)&lt;/span&gt;, where &lt;span class=&#34;math inline&#34;&gt;\(F\)&lt;/span&gt; is the CDF of a continuous random variable &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt;. Furthermore, if we can generate a multivariate &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{X}\)&lt;/span&gt;, say &lt;span class=&#34;math inline&#34;&gt;\((X_1, X_2, ..., X_k)\)&lt;/span&gt; with a known covariance or correlation structure (e.g. exchangeable, auto-regressive, unstructured), it turns that the corresponding multivariate &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{U}, (U_1, U_2, ..., U_k)\)&lt;/span&gt; will maintain that structure. And in a final step, we can transform &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{U}\)&lt;/span&gt; to another random variable &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{Y}\)&lt;/span&gt; that has a target distribution by applying the inverse CDF &lt;span class=&#34;math inline&#34;&gt;\(F_i^{-1}(U_i)\)&lt;/span&gt; of that target distribution to each &lt;span class=&#34;math inline&#34;&gt;\(U_i\)&lt;/span&gt;. Since we can generate a multivariate normal &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{X}\)&lt;/span&gt;, it is relatively short leap to implement this copula algorithm in order to generate correlated data from other distributions.&lt;/p&gt;
&lt;div id=&#34;implementing-the-copula-algorithm-in-r&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Implementing the copula algorithm in R&lt;/h2&gt;
&lt;p&gt;While this hasn’t been implemented just yet in &lt;code&gt;simstudy&lt;/code&gt;, this is along the lines of what I am thinking:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(simstudy)
library(data.table)

set.seed(555)

# Generate 1000 observations of 4 RVs from a multivariate normal 
# dist - each N(0,1) - with a correlation matrix where rho = 0.4 

dt &amp;lt;- genCorData(1000, mu = c(0, 0, 0, 0), sigma = 1, 
                 rho = 0.4, corstr = &amp;quot;cs&amp;quot; )
dt&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         id         V1          V2         V3         V4
##    1:    1 -1.1667574 -0.05296536  0.2995360 -0.5232691
##    2:    2  0.4505618  0.57499589 -0.9629426  1.5495697
##    3:    3 -0.1294505  1.68372035  1.1309223  0.4205397
##    4:    4  0.0858846  1.27479473  0.4247491  0.1054230
##    5:    5  0.4654873  3.05566796  0.5846449  1.0906072
##   ---                                                  
##  996:  996  0.3420099 -0.35783480 -0.8363306  0.2656964
##  997:  997 -1.0928169  0.50081091 -0.8915582 -0.7428976
##  998:  998  0.7490765 -0.09559294 -0.2351121  0.6632157
##  999:  999  0.8143565 -1.00978384  0.2266132 -1.2345192
## 1000: 1000 -1.9795559 -0.16668454 -0.5883966 -1.7424941&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;round(cor(dt[,-1]), 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      V1   V2   V3   V4
## V1 1.00 0.41 0.36 0.44
## V2 0.41 1.00 0.33 0.42
## V3 0.36 0.33 1.00 0.35
## V4 0.44 0.42 0.35 1.00&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;### create a long version of the data set

dtM &amp;lt;- melt(dt, id.vars = &amp;quot;id&amp;quot;, variable.factor = TRUE, 
            value.name = &amp;quot;X&amp;quot;, variable.name = &amp;quot;seq&amp;quot;)
setkey(dtM, &amp;quot;id&amp;quot;)   # sort data by id
dtM[, seqid := .I]  # add index for each record

### apply CDF to X to get uniform distribution

dtM[, U := pnorm(X)]

### Generate correlated Poisson data with mean and variance 8
### apply inverse CDF to U

dtM[, Y_pois := qpois(U, 8), keyby = seqid]
dtM&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         id seq           X seqid          U Y_pois
##    1:    1  V1 -1.16675744     1 0.12165417      5
##    2:    1  V2 -0.05296536     2 0.47887975      8
##    3:    1  V3  0.29953603     3 0.61773446      9
##    4:    1  V4 -0.52326909     4 0.30039350      6
##    5:    2  V1  0.45056179     5 0.67384729      9
##   ---                                             
## 3996:  999  V4 -1.23451924  3996 0.10850474      5
## 3997: 1000  V1 -1.97955591  3997 0.02387673      3
## 3998: 1000  V2 -0.16668454  3998 0.43380913      7
## 3999: 1000  V3 -0.58839655  3999 0.27813308      6
## 4000: 1000  V4 -1.74249414  4000 0.04071101      3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;### Check mean and variance of Y_pois

dtM[, .(mean = round(mean(Y_pois), 1), 
        var = round(var(Y_pois), 1)), keyby = seq]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    seq mean var
## 1:  V1  8.0 8.2
## 2:  V2  8.1 8.5
## 3:  V3  8.1 7.6
## 4:  V4  8.0 7.9&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;### Check correlation matrix of Y_pois&amp;#39;s - I know this code is a bit ugly
### but I just wanted to get the correlation matrix quickly.

round(cor(as.matrix(dcast(data = dtM, id~seq, 
                          value.var = &amp;quot;Y_pois&amp;quot;)[,-1])), 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      V1   V2   V3   V4
## V1 1.00 0.40 0.37 0.43
## V2 0.40 1.00 0.33 0.40
## V3 0.37 0.33 1.00 0.35
## V4 0.43 0.40 0.35 1.00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The correlation matrices for &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{X}\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{Y_{Pois}}\)&lt;/span&gt; aren’t too far off.&lt;/p&gt;
&lt;p&gt;Here are the results for an auto-regressive (AR-1) correlation structure. (I am omitting some of the code for brevity’s sake):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Generate 1000 observations of 4 RVs from a multivariate normal 
# dist - each N(0,1) - with a correlation matrix where rho = 0.4 

dt &amp;lt;- genCorData(1000, mu = c(0, 0, 0, 0), sigma = 1, 
                 rho = 0.4, corstr = &amp;quot;ar1&amp;quot; )

round(cor(dt[,-1]), 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      V1   V2   V3   V4
## V1 1.00 0.43 0.18 0.12
## V2 0.43 1.00 0.39 0.13
## V3 0.18 0.39 1.00 0.38
## V4 0.12 0.13 0.38 1.00&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;### Check mean and variance of Y_pois

dtM[, .(mean = round(mean(Y_pois), 1), 
        var = round(var(Y_pois), 1)), keyby = seq]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    seq mean var
## 1:  V1  8.1 8.3
## 2:  V2  7.9 7.8
## 3:  V3  8.0 8.4
## 4:  V4  8.0 7.5&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;### Check correlation matrix of Y_pois&amp;#39;s

round(cor(as.matrix(dcast(data = dtM, id~seq, 
                          value.var = &amp;quot;Y_pois&amp;quot;)[,-1])), 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      V1   V2   V3   V4
## V1 1.00 0.41 0.18 0.13
## V2 0.41 1.00 0.39 0.14
## V3 0.18 0.39 1.00 0.36
## V4 0.13 0.14 0.36 1.00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again - comparing the two correlation matrices - the original normal data, and the derivative Poisson data - suggests that this can work pretty well.&lt;/p&gt;
&lt;p&gt;Using the last data set, I fit a GEE model to see how well the data generating process is recovered:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(geepack)

geefit &amp;lt;- geepack::geeglm(Y_pois ~ 1, data = dtM, family = poisson,
                          id = id, corstr = &amp;quot;ar1&amp;quot;)

summary(geefit)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## geepack::geeglm(formula = Y_pois ~ 1, family = poisson, data = dtM, 
##     id = id, corstr = &amp;quot;ar1&amp;quot;)
## 
##  Coefficients:
##             Estimate  Std.err  Wald Pr(&amp;gt;|W|)    
## (Intercept) 2.080597 0.007447 78060   &amp;lt;2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Estimated Scale Parameters:
##             Estimate Std.err
## (Intercept)   0.9984 0.02679
## 
## Correlation: Structure = ar1  Link = identity 
## 
## Estimated Correlation Parameters:
##       Estimate Std.err
## alpha   0.3987 0.02008
## Number of clusters:   1000   Maximum cluster size: 4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the GEE output, alpha is an estimate of &lt;span class=&#34;math inline&#34;&gt;\(\rho\)&lt;/span&gt;. The estimated alpha is 0.399, quite close to 0.40, the original value used to generate the normally distributed data.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;binary-outcomes&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Binary outcomes&lt;/h2&gt;
&lt;p&gt;We can also generate binary data:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;### Generate binary data with p=0.5 (var = 0.25)

dtM[, Y_bin := qbinom(U, 1, .5), keyby = seqid]
dtM&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         id seq       X seqid        U Y_pois Y_bin
##    1:    1  V1  1.7425     1 0.959288     13     1
##    2:    1  V2  1.4915     2 0.932086     12     1
##    3:    1  V3  0.7379     3 0.769722     10     1
##    4:    1  V4 -1.6581     4 0.048644      4     0
##    5:    2  V1  2.3262     5 0.989997     15     1
##   ---                                             
## 3996:  999  V4 -0.3805  3996 0.351772      7     0
## 3997: 1000  V1 -0.8724  3997 0.191505      6     0
## 3998: 1000  V2 -1.0085  3998 0.156600      5     0
## 3999: 1000  V3 -2.0451  3999 0.020420      3     0
## 4000: 1000  V4 -2.7668  4000 0.002831      1     0&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;### Check mean and variance of Y_bin

dtM[, .(mean = round(mean(Y_bin), 2), 
        var = round(var(Y_bin), 2)), keyby = seq]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    seq mean  var
## 1:  V1 0.52 0.25
## 2:  V2 0.50 0.25
## 3:  V3 0.48 0.25
## 4:  V4 0.49 0.25&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;### Check correlation matrix of Y_bin&amp;#39;s

round(cor(as.matrix(dcast(data = dtM, id~seq, 
                          value.var = &amp;quot;Y_bin&amp;quot;)[,-1])), 2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      V1   V2   V3   V4
## V1 1.00 0.29 0.10 0.05
## V2 0.29 1.00 0.27 0.03
## V3 0.10 0.27 1.00 0.23
## V4 0.05 0.03 0.23 1.00&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The binary data are correlated, but the correlation coefficient doesn’t replicate as well as the Poisson distribution. While both the Poisson and binary CDF’s are discontinuous, the extreme jump in the binary CDF leads to this discrepancy. Values that are relatively close to each other on the normal scale, and in particular on the uniform scale, can be ‘sent’ to opposite ends of the binary scale (that is to 0 and to 1) if they straddle the cutoff point &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; (the probability of the outcome in the binary distribution); values similar in the original data are very different in the target data. This bias is partially attenuated by values far apart on the uniform scale yet falling on the same side of &lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt; (both driven to 0 or both to 1); in this case values different in the original data are similar (actually identical) in the target data.&lt;/p&gt;
&lt;p&gt;The series of plots below show bivariate data for the original multivariate normal data, and the corresponding uniform, Poisson, and binary data. We can see the effect of extreme discontinuity of the binary data. (R code available &lt;a href=&#34;https://github.com/kgoldfeld/RDataGenBlog/blob/master/static/img/post-copula/Check%20rho%20for%20dists.R&#34;&gt;here&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-06-19-generating-correlated-data-using-a-copula-approach_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;some-simulation-results&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Some simulation results&lt;/h2&gt;
&lt;p&gt;A series of simulations shows how well the estimates of &lt;span class=&#34;math inline&#34;&gt;\(\rho\)&lt;/span&gt; compare across a set of different assumptions. In each of the plots below, we see how &lt;span class=&#34;math inline&#34;&gt;\(\rho\)&lt;/span&gt; for the non-normal data changes as a function of &lt;span class=&#34;math inline&#34;&gt;\(\rho\)&lt;/span&gt; from the original normally distributed data. For each value of &lt;span class=&#34;math inline&#34;&gt;\(\rho\)&lt;/span&gt;, I varied the parameter of the non-normal distribution (in the case of the binary data, I varied the probability of the outcome; in the case of the Poisson data, I varied the parameter &lt;span class=&#34;math inline&#34;&gt;\(\lambda\)&lt;/span&gt; which defines the mean and variance). I also considered both covariance structures, exchangeable and ar-1. (R code available &lt;a href=&#34;https://github.com/kgoldfeld/RDataGenBlog/blob/master/static/img/post-copula/Copula%20data%20generation.R&#34;&gt;here&lt;/a&gt;.)&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/img/post-copula/dists.png&#34; /&gt;

&lt;/div&gt;
&lt;p&gt;These simulations confirm what we saw earlier. The Poisson data generating process recovers the original &lt;span class=&#34;math inline&#34;&gt;\(\rho\)&lt;/span&gt; under both covariance structures reasonably well. The binary data generating process is less successful, with the exchangeable structure doing slightly better than then auto-regressive structure.&lt;/p&gt;
&lt;p&gt;Hopefully soon, this will be implemented in &lt;code&gt;simstudy&lt;/code&gt; so that we can generate data from more general distributions with a single function call.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>When marginal and conditional logistic model estimates diverge</title>
      <link>/post/marginal-v-conditional/</link>
      <pubDate>Fri, 09 Jun 2017 00:00:00 +0000</pubDate>
      <author>keith.goldfeld@nyumc.org (Keith Goldfeld)</author>
      <guid>/post/marginal-v-conditional/</guid>
      <description>&lt;STYLE TYPE=&#34;text/css&#34;&gt;
&lt;!--
  td{
    font-family: Arial; 
    font-size: 9pt;
    height: 2px;
    padding:0px;
    cellpadding=&#34;0&#34;;
    cellspacing=&#34;0&#34;;
    text-align: center;
  }
  th {
    font-family: Arial; 
    font-size: 9pt;
    height: 20px;
    font-weight: bold;
    text-align: center;
  }
  table { 
    border-spacing: 0px;
    border-collapse: collapse;
  }
---&gt;
&lt;/STYLE&gt;
&lt;p&gt;Say we have an intervention that is assigned at a group or cluster level but the outcome is measured at an individual level (e.g. students in different schools, eyes on different individuals). And, say this outcome is binary; that is, something happens, or it doesn’t. (This is important, because none of this is true if the outcome is continuous and close to normally distributed.) If we want to measure the &lt;em&gt;effect&lt;/em&gt; of the intervention - perhaps the risk difference, risk ratio, or odds ratio - it can really matter if we are interested in the &lt;em&gt;marginal&lt;/em&gt; effect or the &lt;em&gt;conditional&lt;/em&gt; effect, because they likely won’t be the same.&lt;/p&gt;
&lt;p&gt;My aim is to show this through a couple of data simulations that allow us to see this visually.&lt;/p&gt;
&lt;div id=&#34;first-example&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;First example&lt;/h3&gt;
&lt;p&gt;In the first scenario, I am going to use a &lt;em&gt;causal inference&lt;/em&gt; framework that uses the idea that everyone has a potential outcome under one exposure (such as an intervention of some sort), and another potential outcome under a different exposure (such as treatment as usual or control). (I may discuss potential outcomes and causal inference in more detail in the future.) The potential outcome can be written with a superscript, lie &lt;span class=&#34;math inline&#34;&gt;\(Y^0\)&lt;/span&gt; or &lt;span class=&#34;math inline&#34;&gt;\(Y^1\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;To generate the data, I will use this simple model for each potential outcome: &lt;span class=&#34;math display&#34;&gt;\[ log\left[\frac{P(Y^0_{ij})}{1-P(Y^0_{ij})}\right] = \gamma + \alpha_i\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;and &lt;span class=&#34;math display&#34;&gt;\[ log\left[\frac{P(Y^1_{ij})}{1-P(Y^1_{ij})}\right] = \gamma + \alpha_i + \delta.\]&lt;/span&gt; &lt;span class=&#34;math inline&#34;&gt;\(\delta\)&lt;/span&gt; is the treatment effect and is constant across the clusters, on the log-odds scale. &lt;span class=&#34;math inline&#34;&gt;\(\alpha_i\)&lt;/span&gt; is the cluster specific effect for cluster &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt;. &lt;span class=&#34;math inline&#34;&gt;\(Y^a_{ij}\)&lt;/span&gt; is the potential outcome for individual &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; under exposure &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Now let’s generate some data and look at it:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Define data

def1 &amp;lt;- defData(varname = &amp;quot;clustEff&amp;quot;, formula = 0, variance = 2, 
                id = &amp;quot;cID&amp;quot;)
def1 &amp;lt;- defData(def1, varname = &amp;quot;nInd&amp;quot;, formula = 10000, 
                dist = &amp;quot;noZeroPoisson&amp;quot;)
  
def2 &amp;lt;- defDataAdd(varname = &amp;quot;Y0&amp;quot;, formula = &amp;quot;-1 + clustEff&amp;quot;, 
                     dist = &amp;quot;binary&amp;quot;, link = &amp;quot;logit&amp;quot;)
def2 &amp;lt;- defDataAdd(def2, varname = &amp;quot;Y1&amp;quot;, 
                     formula = &amp;quot;-1 + clustEff + 2&amp;quot;, 
                     dist = &amp;quot;binary&amp;quot;, link = &amp;quot;logit&amp;quot;)

options(width = 80)
def1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     varname formula variance          dist     link
## 1: clustEff       0        2        normal identity
## 2:     nInd   10000        0 noZeroPoisson identity&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;def2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    varname           formula variance   dist  link
## 1:      Y0     -1 + clustEff        0 binary logit
## 2:      Y1 -1 + clustEff + 2        0 binary logit&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Generate cluster level data

set.seed(123)
  
dtC &amp;lt;- genData(n = 100, def1)

# Generate individual level data
  
dt &amp;lt;- genCluster(dtClust = dtC, cLevelVar = &amp;quot;cID&amp;quot;, numIndsVar = &amp;quot;nInd&amp;quot;, 
                   level1ID = &amp;quot;id&amp;quot;)

dt &amp;lt;- addColumns(def2, dt)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since we have repeated measurements for each cluster (the two potential outcomes), we can transform this into a “longitudinal” data set, though the periods are not time but different exposures.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dtLong &amp;lt;- addPeriods(dtName = dt, idvars = c(&amp;quot;id&amp;quot;,&amp;quot;cID&amp;quot;), 
                     nPeriods = 2,timevars = c(&amp;quot;Y0&amp;quot;,&amp;quot;Y1&amp;quot;), 
                     timevarName = &amp;quot;Y&amp;quot;
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we look at the data visually, we get a hint that the marginal (or average) effect might not be the same as the conditional (cluster-specific) effects.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Calculate average potential outcomes by exposure (which is called period)

dtMean &amp;lt;- dtLong[, .(Y = mean(Y)), keyby = .(period, cID)] # conditional mean
dtMMean &amp;lt;- dtLong[, .(Y = mean(Y)), keyby = .(period)] # marginal mean
dtMMean[, cID := 999]

ggplot(data = dtMean, aes(x=factor(period), y = Y, group= cID)) +
  # geom_jitter(width= .25, color = &amp;quot;grey75&amp;quot;) +
  geom_line(color = &amp;quot;grey75&amp;quot;, position=position_jitter(w=0.02, h=0.02)) +
  geom_point(data=dtMMean) +
  geom_line(data=dtMMean, size = 1, color = &amp;quot;red&amp;quot;) +
  ylab(&amp;quot;Estimated cluster probability&amp;quot;) +
  scale_y_continuous(labels = scales::percent) +
  theme(axis.title.x = element_blank()) +
  my_theme()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-06-09-marginal-v-conditional_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Looking at the plot, we see that the slopes of the grey lines - each representing the change in probability as a result of the exposure for each cluster - vary quite a bit. When the probability without exposure (&lt;span class=&#34;math inline&#34;&gt;\(Y^0\)&lt;/span&gt;) is particularly low or high, the absolute effect of the intervention is small (the slope is minimal). The slope or absolute effect increases when the starting probability is closer to 50%. The red line represents the averages of &lt;span class=&#34;math inline&#34;&gt;\(Y^0\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(Y^1\)&lt;/span&gt; across all individuals in all clusters. There is no reason to believe that the average slope of the grey lines is the same as the slope of the red line, which is slope of the averages. We will see that more clearly with the next data generation scenario.&lt;/p&gt;
&lt;p&gt;Finally, if we look at cluster-specific effects of exposure, we see that on the risk difference scale (difference in probabilities), there is much variation, but on the log-odds ratio scale there is almost no variation. This is as it should be, because on the log-odds scale (which is how we generated the data), the difference between exposure and non-exposure is additive. On the probability scale, the difference is multiplicative. Here are some estimated differences for a sample of clusters:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dtChange &amp;lt;- dt[, .(Y0 = mean(Y0), Y1 = mean(Y1)), keyby = cID]
dtChange[, riskdiff := round(Y1 - Y0, 2)]
dtChange[, loratio := round( log( (Y1 / (1-Y1)) / (Y0 / (1-Y0) )), 2)]

dtChange[sample(1:100, 10, replace = F),
         .(Y0 = round(Y0,2), Y1 = round(Y1,2), riskdiff, loratio), 
         keyby=cID]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     cID   Y0   Y1 riskdiff loratio
##  1:  18 0.02 0.14     0.12    1.95
##  2:  19 0.50 0.89     0.39    2.06
##  3:  22 0.22 0.67     0.45    1.97
##  4:  24 0.12 0.49     0.37    1.94
##  5:  30 0.69 0.94     0.26    2.00
##  6:  31 0.40 0.83     0.42    1.95
##  7:  34 0.56 0.90     0.35    1.99
##  8:  38 0.26 0.72     0.46    2.01
##  9:  72 0.01 0.09     0.08    1.97
## 10:  99 0.22 0.66     0.44    1.93&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;second-example&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Second example&lt;/h2&gt;
&lt;p&gt;This time around, we will add an additional individual level covariate that will help us visualize the difference a bit more clearly. Let us say that &lt;em&gt;age&lt;/em&gt; is positively associated with increased probability in the outcome. (In this case, we measured age and then normalized it so that the mean age in the sample is 0.) And this time around, we are not going to use potential outcomes, but will randomly assign clusters to an intervention or treatment group.&lt;/p&gt;
&lt;p&gt;This is the data generating model and the code:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ log\left[\frac{P(Y_{ij})}{1-P(Y_{ij})}\right] = \gamma + \alpha_j + \beta_1*Trt_j + \beta_2*Age_i\]&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;def1 &amp;lt;- defData(varname = &amp;quot;clustEff&amp;quot;, formula = 0, variance = 2, id = &amp;quot;cID&amp;quot;)
def1 &amp;lt;- defData(def1, varname = &amp;quot;nInd&amp;quot;, formula = 100, dist = &amp;quot;noZeroPoisson&amp;quot;)
  
# Each individual now has a measured age

def2 &amp;lt;- defDataAdd(varname = &amp;quot;age&amp;quot;, formula = 0, variance = 2)
def2 &amp;lt;- defDataAdd(def2, varname = &amp;quot;Y&amp;quot;, 
                   formula = &amp;quot;-4 + clustEff + 2*trt + 2*age&amp;quot;, 
                   dist = &amp;quot;binary&amp;quot;, link = &amp;quot;logit&amp;quot;)
  
# Generate cluster level data
  
dtC &amp;lt;- genData(200, def1)
dtC &amp;lt;- trtAssign(dtC, grpName = &amp;quot;trt&amp;quot;) #
  
# Generate individual level data
  
dt &amp;lt;- genCluster(dtClust = dtC, cLevelVar = &amp;quot;cID&amp;quot;, numIndsVar = &amp;quot;nInd&amp;quot;, 
                 level1ID = &amp;quot;id&amp;quot;)
dt &amp;lt;- addColumns(def2, dt)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By fitting a conditional model (generalized linear mixed effects model) and a marginal model (we should fit a generalized estimating equation model to get the proper standard error estimates, but will estimate a generalized linear model, because the GEE model does not have a “predict” option in R; the point estimates for both marginal models should be quite close), we can see that indeed the conditional and marginal averages can be quite different.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;glmerFit1 &amp;lt;- glmer(Y ~ trt + age + (1 | cID), data = dt, family=&amp;quot;binomial&amp;quot;)
glmFit1 &amp;lt;- glm(Y ~ trt + age, family = binomial, data = dt)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                   Intercept  Trt  Age
## conditional model     -3.82 1.99 2.01
## marginal model        -2.97 1.60 1.54&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, we’d like to visualize how the conditional and marginal treatment effects diverge. We can use the model estimates from the conditional model to predict probabilities for each cluster, age, and treatment group. (These will appear as grey lines in the plots below). We can also predict marginal probabilities from the marginal model based on age and treatment group while ignoring cluster. (These marginal estimates appear as red lines.) Finally, we can predict probability of outcomes for the conditional model also based on age and treatment group alone, but fixed at a mythical cluster whose random effect is 0. (These “average” conditional estimates appear as black lines.)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;newCond &amp;lt;- expand.grid(cID = unique(dt$cID), age=seq(-4, 4, by =.1))
newCond0 &amp;lt;- data.table(trt = 0, newCond)
newCond1 &amp;lt;- data.table(trt = 1, newCond)

newMarg0 &amp;lt;- data.table(trt = 0, age = seq(-4, 4, by = .1))
newMarg1 &amp;lt;- data.table(trt = 1, age = seq(-4, 4, by = .1))

newCond0[, pCond0 := predict(glmerFit1, newCond0, type = &amp;quot;response&amp;quot;)]
newCond1[, pCond1 := predict(glmerFit1, newCond1, type = &amp;quot;response&amp;quot;)]

newMarg0[, pMarg0 := predict(glmFit1, newMarg0, type = &amp;quot;response&amp;quot;)]
newMarg0[, pCAvg0 := predict(glmerFit1, newMarg0[,c(1,2)], 
                             re.form = NA, type=&amp;quot;response&amp;quot;)]

newMarg1[, pMarg1 := predict(glmFit1, newMarg1, type = &amp;quot;response&amp;quot;)]
newMarg1[, pCAvg1 := predict(glmerFit1, newMarg1[,c(1,2)], 
                             re.form = NA, type=&amp;quot;response&amp;quot;)]

dtAvg &amp;lt;- data.table(age = newMarg1$age, 
           avgMarg = newMarg1$pMarg1 - newMarg0$pMarg0, 
           avgCond = newMarg1$pCAvg1 - newMarg0$pCAvg0
)

p1 &amp;lt;- ggplot(aes(x = age, y = pCond1), data=newCond1) + 
  geom_line(color=&amp;quot;grey&amp;quot;, aes(group = cID)) +
  geom_line(data=newMarg1, aes(x = age, y = pMarg1), color = &amp;quot;red&amp;quot;, size = 1) +
  geom_line(data=newMarg1, aes(x = age, y = pCAvg1), color = &amp;quot;black&amp;quot;, size = 1) +
  ggtitle(&amp;quot;Treatment group&amp;quot;) +
  xlab(&amp;quot;Age&amp;quot;) +
  ylab(&amp;quot;Probability&amp;quot;) +
  my_theme()

p0 &amp;lt;- ggplot(aes(x = age, y = pCond0), data=newCond0) + 
  geom_line(color=&amp;quot;grey&amp;quot;, aes(group = cID)) +
  geom_line(data=newMarg0, aes(x = age, y = pMarg0), color = &amp;quot;red&amp;quot;, size = 1) +
  geom_line(data=newMarg0, aes(x = age, y = pCAvg0), color = &amp;quot;black&amp;quot;, size = 1) +
  ggtitle(&amp;quot;Control group&amp;quot;) +
  xlab(&amp;quot;Age&amp;quot;) +
  ylab(&amp;quot;Probability&amp;quot;) +
  my_theme()

pdiff &amp;lt;- ggplot(data = dtAvg) + 
  geom_line(aes(x = age, y = avgMarg), color = &amp;quot;red&amp;quot;, size = 1) +
  geom_line(aes(x = age, y = avgCond), color = &amp;quot;black&amp;quot;, size = 1) +
  ggtitle(&amp;quot;Risk difference&amp;quot;) +
  xlab(&amp;quot;Age&amp;quot;) +
  ylab(&amp;quot;Probability&amp;quot;) +
  my_theme()

grid.arrange(p1, p0, pdiff)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-06-09-marginal-v-conditional_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;432&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We see pretty clearly across all ages that the marginal and conditional estimates of average treatment differences differ quite dramatically.&lt;/p&gt;
&lt;p&gt;Below are point estimates and plots for data generated with very little variance across clusters, that is &lt;span class=&#34;math inline&#34;&gt;\(var(\alpha_i)\)&lt;/span&gt; is close to 0. (We change this in the simulation by setting &lt;code&gt;def1 &amp;lt;- defData(varname = &amp;quot;clustEff&amp;quot;, formula = 0, variance = 0.05, id = &amp;quot;cID&amp;quot;)&lt;/code&gt;.)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;##                   Intercept  Trt  Age
## conditional model     -4.03 2.08 2.01
## marginal model        -4.00 2.07 1.99&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-06-09-marginal-v-conditional_files/figure-html/unnamed-chunk-8-1.png&#34; width=&#34;432&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The black lines obscure the red - the marginal model estimate is not much different from the conditional model estimate - because the variance across clusters is negligible.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>It can be easy to explore data generating mechanisms with the simstudy package</title>
      <link>/post/intro-to-simstudy/</link>
      <pubDate>Tue, 16 May 2017 00:00:00 +0000</pubDate>
      <author>keith.goldfeld@nyumc.org (Keith Goldfeld)</author>
      <guid>/post/intro-to-simstudy/</guid>
      <description>&lt;STYLE TYPE=&#34;text/css&#34;&gt;
&lt;!--
  td{
    font-family: Arial; 
    font-size: 9pt;
    height: 2px;
    padding:0px;
    cellpadding=&#34;0&#34;;
    cellspacing=&#34;0&#34;;
    text-align: center;
  }
  th {
    font-family: Arial; 
    font-size: 9pt;
    height: 20px;
    font-weight: bold;
    text-align: center;
  }
  table { 
    border-spacing: 0px;
    border-collapse: collapse;
  }
---&gt;
&lt;/STYLE&gt;
&lt;p&gt;I learned statistics and probability by simulating data. Sure, I did the occasional proof, but I never believed the results until I saw it in a simulation. I guess I have it backwards, but I that’s just the way I am. And now that I am a so-called professional, I continue to use simulation to understand models, to do sample size estimates and power calculations, and of course to teach. Sure - I’ll use the occasional formula when one exists, but I always feel the need to check it with simulation. It’s just the way I am.&lt;/p&gt;
&lt;p&gt;Since I found myself constantly setting up simulations, over time I developed ways to make the process a bit easier. Those processes turned into a package, which I called &lt;a href = https://cran.r-project.org/web/packages/simstudy/index.html&gt;simstudy&lt;/a&gt;, which obviously means &lt;em&gt;simulating study data&lt;/em&gt;. The purpose here in this blog entyr is to introduce the basic idea behind simstudy, and provide a relatively brief example that actually comes from a question a user posed about generating correlated longitudinal data.&lt;/p&gt;
&lt;div id=&#34;the-basic-idea&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The basic idea&lt;/h2&gt;
&lt;p&gt;Simulation using simstudy has two primary steps. First, the user defines the data elements of a data set either in an external csv file or internally through a set of repeated definition statements. Second, the user generates the data, using these definitions. Data generation can be as simple as a cross-sectional design or prospective cohort design, or it can be more involved, extending to allow simulators to generate observed or randomized &lt;em&gt;treatment assignment/exposures&lt;/em&gt;, &lt;em&gt;survival&lt;/em&gt; data, &lt;em&gt;longitudinal/panel&lt;/em&gt; data, &lt;em&gt;multi-level/hierarchical&lt;/em&gt; data, datasets with &lt;em&gt;correlated variables&lt;/em&gt; based on a specified covariance structure, and to data sets with &lt;em&gt;missing&lt;/em&gt; data based on a variety of missingness patterns.&lt;/p&gt;
&lt;p&gt;The key to simulating data in simstudy is the creation of series of data defintion tables that look like this:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th align=&#34;left&#34;&gt;varname&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;formula&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;variance&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;dist&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;link&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;nr&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;nonrandom&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;identity&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;x1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;10;20&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;uniform&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;identity&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;y1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;nr + x1 * 2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;normal&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;identity&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;y2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;nr - 0.2 * x1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;poisson&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;xCat&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0.3;0.2;0.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;categorical&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;identity&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td align=&#34;left&#34;&gt;g1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;5+xCat&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;gamma&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;log&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td align=&#34;left&#34;&gt;a1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;-3 + xCat&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;binary&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;logit&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Here’s the code that is used to generate this definition, which is stored as a &lt;a href = https://github.com/Rdatatable/data.table/wiki&gt;data.table &lt;/a&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;def &amp;lt;- defData(varname = &amp;quot;nr&amp;quot;, dist = &amp;quot;nonrandom&amp;quot;, formula = 7, id = &amp;quot;idnum&amp;quot;)
def &amp;lt;- defData(def, varname = &amp;quot;x1&amp;quot;, dist = &amp;quot;uniform&amp;quot;, formula = &amp;quot;10;20&amp;quot;)
def &amp;lt;- defData(def, varname = &amp;quot;y1&amp;quot;, formula = &amp;quot;nr + x1 * 2&amp;quot;, variance = 8)
def &amp;lt;- defData(def, varname = &amp;quot;y2&amp;quot;, dist = &amp;quot;poisson&amp;quot;, formula = &amp;quot;nr - 0.2 * x1&amp;quot;, 
    link = &amp;quot;log&amp;quot;)
def &amp;lt;- defData(def, varname = &amp;quot;xCat&amp;quot;, formula = &amp;quot;0.3;0.2;0.5&amp;quot;, dist = &amp;quot;categorical&amp;quot;)
def &amp;lt;- defData(def, varname = &amp;quot;g1&amp;quot;, dist = &amp;quot;gamma&amp;quot;, formula = &amp;quot;5+xCat&amp;quot;, variance = 1, 
    link = &amp;quot;log&amp;quot;)
def &amp;lt;- defData(def, varname = &amp;quot;a1&amp;quot;, dist = &amp;quot;binary&amp;quot;, formula = &amp;quot;-3 + xCat&amp;quot;, 
    link = &amp;quot;logit&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To create a simple data set based on these definitions, all one needs to do is execute a single &lt;code&gt;genData&lt;/code&gt; command. In this example, we generate 500 records that are based on the definition in the &lt;code&gt;def&lt;/code&gt;table:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dt &amp;lt;- genData(500, def)

dt&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      idnum nr       x1       y1  y2 xCat         g1 a1
##   1:     1  7 11.78709 30.24305 109    1  297.03396  0
##   2:     2  7 13.02129 30.58814  87    3  929.80474  0
##   3:     3  7 15.37784 37.31205  44    2 3738.52996  1
##   4:     4  7 18.66916 42.51506  24    2   78.17338  0
##   5:     5  7 10.55980 26.39898 131    2  147.42608  0
##  ---                                                  
## 496:   496  7 19.74327 46.62290  24    1   15.49462  0
## 497:   497  7 18.41837 43.35002  24    1  201.66739  0
## 498:   498  7 18.64485 47.62767  26    1  215.74763  0
## 499:   499  7 12.07687 28.65423 105    3  864.30964  1
## 500:   500  7 11.37337 29.71361 132    2  149.21883  0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There’s a lot more functionality in the package, and I’ll be writing about that in the future. But here, I just want give a little more introduction by way of an example that came in from around the world a couple of days ago. (I’d say the best thing about building a package is hearing from folks literally all over the world and getting to talk to them about statistics and R. It is really incredible to be able to do that.)&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;going-a-bit-further-simulating-a-prosepctive-cohort-study-with-repeated-measures&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Going a bit further: simulating a prosepctive cohort study with repeated measures&lt;/h2&gt;
&lt;p&gt;The question was, can we simulate a study with two arms, say a control and treatment, with repeated measures at three time points: baseline, after 1 month, and after 2 months? Of course.&lt;/p&gt;
&lt;p&gt;This was what I sent back to my correspondent:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Define the outcome

ydef &amp;lt;- defDataAdd(varname = &amp;quot;Y&amp;quot;, dist = &amp;quot;normal&amp;quot;, formula = &amp;quot;5 + 2.5*period + 1.5*T + 3.5*period*T&amp;quot;, 
    variance = 3)

# Generate a &amp;#39;blank&amp;#39; data.table with 24 observations and assign them to
# groups

set.seed(1234)

indData &amp;lt;- genData(24)
indData &amp;lt;- trtAssign(indData, nTrt = 2, balanced = TRUE, grpName = &amp;quot;T&amp;quot;)

# Create a longitudinal data set of 3 records for each id

longData &amp;lt;- addPeriods(indData, nPeriods = 3, idvars = &amp;quot;id&amp;quot;)
longData &amp;lt;- addColumns(dtDefs = ydef, longData)

longData[, `:=`(T, factor(T, labels = c(&amp;quot;No&amp;quot;, &amp;quot;Yes&amp;quot;)))]

# Let&amp;#39;s look at the data

ggplot(data = longData, aes(x = factor(period), y = Y)) + geom_line(aes(color = T, 
    group = id)) + scale_color_manual(values = c(&amp;quot;#e38e17&amp;quot;, &amp;quot;#8e17e3&amp;quot;)) + xlab(&amp;quot;Time&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-05-16-intro-to-simstudy_files/figure-html/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;If we generate a data set based on 1,000 indviduals and estimate a linear regression model we see that the parameter estimates are quite good. However, my correspondent wrote back saying she wanted correlated data, which makes sense. We can see from the alpha estimate of approximately 0.02 (at the bottom of the output), we don’t have much correlation:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Fit a GEE model to the data

fit &amp;lt;- geeglm(Y ~ factor(T) + period + factor(T) * period, family = gaussian(link = &amp;quot;identity&amp;quot;), 
    data = longData, id = id, corstr = &amp;quot;exchangeable&amp;quot;)
summary(fit)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## geeglm(formula = Y ~ factor(T) + period + factor(T) * period, 
##     family = gaussian(link = &amp;quot;identity&amp;quot;), data = longData, id = id, 
##     corstr = &amp;quot;exchangeable&amp;quot;)
## 
##  Coefficients:
##                     Estimate Std.err   Wald Pr(&amp;gt;|W|)    
## (Intercept)          4.98268 0.07227 4753.4   &amp;lt;2e-16 ***
## factor(T)Yes         1.48555 0.10059  218.1   &amp;lt;2e-16 ***
## period               2.53946 0.05257 2333.7   &amp;lt;2e-16 ***
## factor(T)Yes:period  3.51294 0.07673 2096.2   &amp;lt;2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Estimated Scale Parameters:
##             Estimate Std.err
## (Intercept)    2.952 0.07325
## 
## Correlation: Structure = exchangeable  Link = identity 
## 
## Estimated Correlation Parameters:
##       Estimate Std.err
## alpha  0.01737 0.01862
## Number of clusters:   1000   Maximum cluster size: 3&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;one-way-to-generate-correlated-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;One way to generate correlated data&lt;/h2&gt;
&lt;p&gt;The first way to approach this is to use the simstudy function &lt;code&gt;genCorData&lt;/code&gt; to generate correlated errors that are normally distributed with mean 0, variance of 3, and and common correlation coeffcient of 0.7. This approach is a bit mysterious, because we are acknowledging that we don’t know what is driving the relationship between the three outcomes, just that they have a common cause.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# define the outcome
ydef &amp;lt;- defDataAdd(varname = &amp;quot;Y&amp;quot;, dist = &amp;quot;normal&amp;quot;, formula = &amp;quot;5 + 2.5*period + 1.5*T + 3.5*period*T + e&amp;quot;)

# define the correlated errors

mu &amp;lt;- c(0, 0, 0)
sigma &amp;lt;- rep(sqrt(3), 3)

# generate correlated data for each id and assign treatment

dtCor &amp;lt;- genCorData(24, mu = mu, sigma = sigma, rho = 0.7, corstr = &amp;quot;cs&amp;quot;)
dtCor &amp;lt;- trtAssign(dtCor, nTrt = 2, balanced = TRUE, grpName = &amp;quot;T&amp;quot;)

# create longitudinal data set and generate outcome based on definition

longData &amp;lt;- addPeriods(dtCor, nPeriods = 3, idvars = &amp;quot;id&amp;quot;, timevars = c(&amp;quot;V1&amp;quot;, 
    &amp;quot;V2&amp;quot;, &amp;quot;V3&amp;quot;), timevarName = &amp;quot;e&amp;quot;)
longData &amp;lt;- addColumns(ydef, longData)

longData[, `:=`(T, factor(T, labels = c(&amp;quot;No&amp;quot;, &amp;quot;Yes&amp;quot;)))]

# look at the data, outcomes should appear more correlated, lines a bit
# straighter

ggplot(data = longData, aes(x = factor(period), y = Y)) + geom_line(aes(color = T, 
    group = id)) + scale_color_manual(values = c(&amp;quot;#e38e17&amp;quot;, &amp;quot;#8e17e3&amp;quot;)) + xlab(&amp;quot;Time&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-05-16-intro-to-simstudy_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Again, we recover the true parameters. And this time, if we look at the estimated correlation, we see that indeed the outcomes are correlated within each indivdual. The estimate is 0.77, close to the our specified value of 0.7.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fit &amp;lt;- geeglm(Y ~ factor(T) + period + factor(T) * period, family = gaussian(link = &amp;quot;identity&amp;quot;), 
    data = longData, id = id, corstr = &amp;quot;exchangeable&amp;quot;)

summary(fit)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## geeglm(formula = Y ~ factor(T) + period + factor(T) * period, 
##     family = gaussian(link = &amp;quot;identity&amp;quot;), data = longData, id = id, 
##     corstr = &amp;quot;exchangeable&amp;quot;)
## 
##  Coefficients:
##                     Estimate Std.err Wald Pr(&amp;gt;|W|)    
## (Intercept)           5.0636  0.0762 4411   &amp;lt;2e-16 ***
## factor(T)Yes          1.4945  0.1077  192   &amp;lt;2e-16 ***
## period                2.4972  0.0303 6798   &amp;lt;2e-16 ***
## factor(T)Yes:period   3.5204  0.0426 6831   &amp;lt;2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Estimated Scale Parameters:
##             Estimate Std.err
## (Intercept)     3.07   0.117
## 
## Correlation: Structure = exchangeable  Link = identity 
## 
## Estimated Correlation Parameters:
##       Estimate Std.err
## alpha    0.711  0.0134
## Number of clusters:   1000   Maximum cluster size: 3&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;another-way-to-generate-correlated-data&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Another way to generate correlated data&lt;/h2&gt;
&lt;p&gt;A second way to generate correlatd data is through an individual level random-effect or random intercept. This could be considered some unmeasured characteristic of the individuals (which happens to have a convenient normal distribution with mean zero). This random effect contributes equally to all instances of an individuals outcomes, but the outcomes for a particular individual deviate slightly from the hypothetical straight line as a result of unmeasured noise.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ydef1 &amp;lt;- defData(varname = &amp;quot;randomEffect&amp;quot;, dist = &amp;quot;normal&amp;quot;, formula = 0, variance = sqrt(3))
ydef2 &amp;lt;- defDataAdd(varname = &amp;quot;Y&amp;quot;, dist = &amp;quot;normal&amp;quot;, formula = &amp;quot;5 + 2.5*period + 1.5*T + 3.5*period*T + randomEffect&amp;quot;, 
    variance = 1)

indData &amp;lt;- genData(24, ydef1)
indData &amp;lt;- trtAssign(indData, nTrt = 2, balanced = TRUE, grpName = &amp;quot;T&amp;quot;)

indData[1:6]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    id T randomEffect
## 1:  1 0      -1.3101
## 2:  2 1       0.3423
## 3:  3 0       0.5716
## 4:  4 1       2.6723
## 5:  5 0      -0.9996
## 6:  6 1      -0.0722&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;longData &amp;lt;- addPeriods(indData, nPeriods = 3, idvars = &amp;quot;id&amp;quot;)
longData &amp;lt;- addColumns(dtDefs = ydef2, longData)

longData[, `:=`(T, factor(T, labels = c(&amp;quot;No&amp;quot;, &amp;quot;Yes&amp;quot;)))]

ggplot(data = longData, aes(x = factor(period), y = Y)) + geom_line(aes(color = T, 
    group = id)) + scale_color_manual(values = c(&amp;quot;#e38e17&amp;quot;, &amp;quot;#8e17e3&amp;quot;)) + xlab(&amp;quot;Time&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2017-05-16-intro-to-simstudy_files/figure-html/unnamed-chunk-10-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fit &amp;lt;- geeglm(Y ~ factor(T) + period + factor(T) * period, family = gaussian(link = &amp;quot;identity&amp;quot;), 
    data = longData, id = id, corstr = &amp;quot;exchangeable&amp;quot;)
summary(fit)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## geeglm(formula = Y ~ factor(T) + period + factor(T) * period, 
##     family = gaussian(link = &amp;quot;identity&amp;quot;), data = longData, id = id, 
##     corstr = &amp;quot;exchangeable&amp;quot;)
## 
##  Coefficients:
##                     Estimate Std.err Wald Pr(&amp;gt;|W|)    
## (Intercept)           4.9230  0.0694 5028   &amp;lt;2e-16 ***
## factor(T)Yes          1.4848  0.1003  219   &amp;lt;2e-16 ***
## period                2.5310  0.0307 6793   &amp;lt;2e-16 ***
## factor(T)Yes:period   3.5076  0.0449 6104   &amp;lt;2e-16 ***
## ---
## Signif. codes:  0 &amp;#39;***&amp;#39; 0.001 &amp;#39;**&amp;#39; 0.01 &amp;#39;*&amp;#39; 0.05 &amp;#39;.&amp;#39; 0.1 &amp;#39; &amp;#39; 1
## 
## Estimated Scale Parameters:
##             Estimate Std.err
## (Intercept)     2.63  0.0848
## 
## Correlation: Structure = exchangeable  Link = identity 
## 
## Estimated Correlation Parameters:
##       Estimate Std.err
## alpha    0.619  0.0146
## Number of clusters:   1000   Maximum cluster size: 3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I sent all this back to my correspondent, but I haven’t heard yet if it is what she wanted. I certainly hope so. If there are specific topics you’d like me to discuss related to simstudy, definitely get in touch, and I will try to write something up.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Everyone knows that loops in R are to be avoided, but vectorization is not always possible</title>
      <link>/post/first-blog-entry/</link>
      <pubDate>Wed, 10 May 2017 00:00:00 +0000</pubDate>
      <author>keith.goldfeld@nyumc.org (Keith Goldfeld)</author>
      <guid>/post/first-blog-entry/</guid>
      <description>&lt;p&gt;It goes without saying that there are always many ways to solve a problem in R, but clearly some ways are better (for example, faster) than others. Recently, I found myself in a situation where I could not find a way to avoid using a loop, and I was immediately concerned, knowing that I would want this code to be flexible enough to run with a very large number of observations, possibly over many observations. Two tools immediately came to mind: &lt;a href = https://github.com/Rdatatable/data.table/wiki&gt;data.table &lt;/a&gt; and &lt;a href = http://adv-r.had.co.nz/Rcpp.html&gt;Rcpp &lt;/a&gt;. This brief description explains the background of the simulation problem I was working on and walks through the evolution of ideas to address the problems I ran into when I tried to simulate a large number of inviduals. In particular, when I tried to simulate a very large number of individuals, say over 1 million, running the simulation over night wasn’t enough.&lt;/p&gt;
&lt;div id=&#34;setting-up-the-problem&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Setting up the problem&lt;/h2&gt;
&lt;p&gt;The task in question here is not the focus, but needs a little explanation to understand what is motivating the programming issue. I am conducting a series of simulations that involve generating an individual-level stochastic (Markov) process for any number of individuals. For the data generation, I am using the &lt;a href = https://cran.r-project.org/web/packages/simstudy/index.html&gt;simstudy&lt;/a&gt; package developed to help facilitate simulated data.&lt;/p&gt;
&lt;p&gt;The functions &lt;code&gt;defDataAdd&lt;/code&gt; and &lt;code&gt;genData&lt;/code&gt; are both from &lt;code&gt;simstudy&lt;/code&gt;. The first part of the simulation involves specifying the transition matrix &lt;code&gt;P&lt;/code&gt; that determine a state I am calling &lt;code&gt;status&lt;/code&gt;, and then defining the probability of an event that are based on a particular status level at a particular time point. For each individual, I generate 36 months of data and a status and event for each month.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(data.table)
library(simstudy)

set.seed(123)

P &amp;lt;- matrix(c(0.985, 0.015, 0.000, 0.000, 
              0.000, 0.950, 0.050, 0.000,
              0.000, 0.000, 0.850, 0.150,
              0.000, 0.000, 0.000, 1.000), 
            nrow = 4, byrow = TRUE)

form &amp;lt;- &amp;quot;(status == 1) * 0.02 + (status == 2) * 0.10 + (status == 3) * 0.20&amp;quot;

dtDef &amp;lt;- defDataAdd(varname = &amp;quot;event&amp;quot;, 
            formula = form, 
            dist = &amp;quot;binary&amp;quot;,
            link = &amp;quot;identity&amp;quot;)

N = 5000
did &amp;lt;- genData(N)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In order to simulate the Markov process, I decided immediately that &lt;code&gt;Rcpp&lt;/code&gt; would be most appropriate because I knew I could not avoid looping. Since each state of a Markov process depends on the state immediately preceding, states need to be generated sequentially, which means no obvious way to vectorize (if someone has figured that out, let me know.)&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;RcppArmadilloExtensions/sample.h&amp;gt;
// [[Rcpp::depends(RcppArmadillo)]]

using namespace Rcpp;

// [[Rcpp::export]]
IntegerVector MCsim( unsigned int nMonths, NumericMatrix P, 
                     int startStatus, unsigned int startMonth ) {
  
  IntegerVector sim( nMonths );
  IntegerVector m( P.ncol());
  NumericVector currentP;
  IntegerVector newstate;
  
  unsigned int q = P.ncol();
  
  m = Rcpp::seq(1, q);
  
  sim[startMonth - 1] = startStatus;
  
  for (unsigned int i = startMonth; i &amp;lt; nMonths; i++) {
    
    newstate = RcppArmadillo::sample(m, 1, TRUE, P.row(sim(i-1) - 1));
    sim(i) = newstate(0);
    
  }
  
  return sim;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The process is simulated for each individual using the &lt;strong&gt;Rcpp&lt;/strong&gt; function &lt;code&gt;MCsim&lt;/code&gt;, but is done in the context of a &lt;code&gt;data.table&lt;/code&gt; statement. The key here is that each individual is processed separately through the &lt;code&gt;keyby = id&lt;/code&gt; statement. This obviates the requirement to loop through individuals even though I still need to loop within individuals for the stochastic process. This algorithm is quite fast, even with very large numbers of individuals and large numbers of observations (in this case months) per individual.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dt &amp;lt;- did[, .(status = MCsim(36, P, 1, 1)), 
          keyby = id]
dt[, month := 1 : .N, keyby = id]
dt &amp;lt;- addColumns(dtDefs = dtDef, dtOld = dt)

dt&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##           id status month event
##      1:    1      1     1     0
##      2:    1      1     2     0
##      3:    1      1     3     0
##      4:    1      1     4     0
##      5:    1      1     5     0
##     ---                        
## 179996: 5000      4    32     0
## 179997: 5000      4    33     0
## 179998: 5000      4    34     0
## 179999: 5000      4    35     0
## 180000: 5000      4    36     0&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;this-is-where-things-begin-to-slow-down&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;This is where things begin to slow down&lt;/h2&gt;
&lt;p&gt;It is the next phase of the simulation that started to cause me problems. For the simulation, I need to assign individuals to a group or cohort which is defined by a month and is based on several factors: (1) whether an event occurred in that month, (2) whether the status of that individual in that month exceeded a value of &lt;code&gt;1&lt;/code&gt;, and (3) whether or not the individual experienced 2 or more events in the prior 12 months. An indivdual might be eligible for more than one cohort, but will be assigned to the first possible cohort (i.e. the earliest month where all three criteria are met.)&lt;/p&gt;
&lt;p&gt;Again, the specifics of the simulation are not important here. What is important, is the notion that the problem requires looking through individual data sequentially, something R is generally not so good at when the sequences get particularly long, and they must be repeated a large number of times.&lt;/p&gt;
&lt;p&gt;My first, naïve, approach was to create an &lt;strong&gt;R&lt;/strong&gt; function that loops through all the individuals and loops within each individual until a cohort is found:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rAssignCohortID &amp;lt;- function(id, month, status, 
                            event, nInds, 
                            startMonth, thresholdNum) {
  
  cohort &amp;lt;-   rep(0, length(id));

  for (j in (1 : nInds))  {
    
    idMonth = month[id == j];
    idEvent = event[id == j];
    idStatus = status[id == j];
    
    endMonth = length(idMonth);
    
    done = FALSE;
    i = max(startMonth - idMonth[1], 13);
    
    while (i &amp;lt;= endMonth &amp;amp;&amp;amp; !done) {
      
      if (idEvent[i] == 1 &amp;amp;&amp;amp; idStatus[i] &amp;gt; 1) {
        
        begin = i-12;
        end = i-1;
        
        sumED = sum(idEvent[begin:end]);
        
        if (sumED &amp;gt;= thresholdNum) {
          
          cohort[id == j] &amp;lt;- i - 1 + month[1];
          done = TRUE;
        }
      }    
      i = i + 1;
    }    
  }
  
  return(cohort);
} &lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;working-through-possible-solutions&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Working through possible solutions&lt;/h2&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;system.time(dt[, cohort1 := rAssignCohortID(id, month, status, event, 
                    nInds = N, startMonth = 13, thresholdNum = 2)])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    user  system elapsed 
##  12.555   0.180  13.256&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The naïve approach works, but can we do better? I thought &lt;strong&gt;Rcpp&lt;/strong&gt; might be a solution, because we know that loops in C++ are much more efficient. However, things did not turn out so well after I translated the function into C++; in fact, they got a little worse.&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;Rcpp.h&amp;gt;

using namespace Rcpp;

// [[Rcpp::export]]
IntegerVector cAssignCohortID( IntegerVector id, 
                    IntegerVector month, 
                    IntegerVector status, 
                    IntegerVector event,
                    int nInds, 
                    int startMonth, 
                    int thresholdNum) {
    
  IntegerVector cohort(id.length(), 0);
  
  IntegerVector idMonth;
  IntegerVector idEvent;
  IntegerVector idStatus;
  
  for (int j = 0; j &amp;lt; nInds; j++) {
    
    idMonth = month[id == j+1];
    idEvent = event[id == j+1];
    idStatus = status[id == j+1];

    int endMonth = idMonth.length();
    int sumED;
    bool done = FALSE;
    int i = std::max(startMonth - idMonth(0), 12);
    int begin;
    int end;

    while (i &amp;lt; endMonth &amp;amp;&amp;amp; !done) {
      
      if (idEvent(i) == 1 &amp;amp;&amp;amp; idStatus(i) &amp;gt; 1) {
        
        begin = i-12;
        end = i-1;
        
        sumED = sum(idEvent[Rcpp::seq(begin, end)]);
        
        if (sumED &amp;gt;= thresholdNum) {
          cohort[id == j + 1] = i + month(0);
          done = TRUE;
        }
      }    
      i += 1;
    }    
  }
   
  return(cohort);
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;system.time(dt[, cohort2 := cAssignCohortID(id, month, status, event, 
                    nInds = N, startMonth = 13, thresholdNum = 2)])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    user  system elapsed 
##  12.405   0.140  12.886&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I know that the function &lt;code&gt;cAssignCohortID&lt;/code&gt; bogs down not in the loop, but in each phase where I need to subset the data set to work on a single &lt;code&gt;id&lt;/code&gt;. For example, I need to execute the statement &lt;code&gt;idMonth = month[id == j+1]&lt;/code&gt; for each &lt;code&gt;id&lt;/code&gt;, and this apparently uses a lot of resources. I tried variations on this theme, alternatives to subset the data set within the Rcpp function, but could get no improvements.&lt;/p&gt;
&lt;p&gt;But a light bulb went off in my head (dim as it might be), telling me that this is one of the many things &lt;code&gt;data.table&lt;/code&gt; is particularly good at. In fact, I used this trick earlier in generating the stochastic process data. So, rather than subsetting the data within the function, I created a regular R function that handles only a single individual &lt;code&gt;id&lt;/code&gt; at a time, and let &lt;code&gt;data.table&lt;/code&gt; do the hard work of splitting up the data set to process by individual.&lt;/p&gt;
&lt;p&gt;As you can see, things got markedly faster.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rAssignCohort &amp;lt;- function(id, month, status, event, 
                   nInds, startMonth, thresholdNum) {
  
  cohort &amp;lt;- 0
  
  endMonth = length(month);
    
  done = FALSE;
  i = max(startMonth - month[1], 13);
  
  while (i &amp;lt;= endMonth &amp;amp;&amp;amp; !done) {
    
    if (event[i] == 1 &amp;amp;&amp;amp; status[i] &amp;gt; 1) {
        
      begin = i-12;
      end = i-1;
        
      sumED = sum(event[begin:end]);
        
      if (sumED &amp;gt;= thresholdNum) {
          
        cohort &amp;lt;- i - 1 + month[1];
        done = TRUE;
      }
    }    
    i = i + 1;
  }
  
  return(cohort)
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;system.time(dt[, cohort3 := rAssignCohort(id, month, status, event, 
                    nInds = N, startMonth = 13, thresholdNum = 2), 
               keyby=id])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    user  system elapsed 
##   0.150   0.009   0.171&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, it occurred to me that an &lt;code&gt;Rcpp&lt;/code&gt; function that is not required to subset the data might offer more yet improvements in speed. So, for the last iteration, I combined the strengths of looping in &lt;code&gt;Rcpp&lt;/code&gt; with the strengths of subsetting in &lt;code&gt;data.table&lt;/code&gt; to create a formidable combination. (Even when sample sizes exceed 1 million, the data are generated in a flash.)&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;#include &amp;lt;Rcpp.h&amp;gt;

using namespace Rcpp;

// [[Rcpp::export]]
int cAssignCohort( IntegerVector month, 
                  IntegerVector status,
                  IntegerVector event,
                  int startMonth, int thresholdNum) {
  
  int endMonth = month.length();
  int sumED;
  int cohort = 0;
  bool done = FALSE;
  int i = std::max(startMonth - month(0), 12);
  int begin;
  int end;
  
  while (i &amp;lt; endMonth &amp;amp;&amp;amp; !done) {
    
    if (event(i) == 1 &amp;amp;&amp;amp; status(i) &amp;gt; 1) {
      
      begin = i-12;
      end = i-1;
      
      sumED = sum(event[Rcpp::seq(begin, end)]);
      
      if (sumED &amp;gt;= thresholdNum) {
        cohort = i + month(0);
        done = TRUE;
      }
    }    
    i += 1;
  }
  
   
  return(cohort);
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;system.time(dt[, cohort4 := cAssignCohort(month, status, event, 
                               startMonth=13,  thresholdNum = 2), keyby=id])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    user  system elapsed 
##   0.029   0.004   0.035&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For a more robust comparison, let’s use the &lt;code&gt;benchmark&lt;/code&gt; function in package &lt;code&gt;rbenchmark&lt;/code&gt;, and you can see how well &lt;code&gt;data.table&lt;/code&gt; performs and how much &lt;code&gt;Rcpp&lt;/code&gt; can add when used efficiently.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(rbenchmark)

benchmark(
  dt[, cohort1 := rAssignCohortID(id, month, status, event,       # Naïve approach
                      nInds = N, startMonth = 13, thresholdNum = 2)],
  dt[, cohort2 := cAssignCohortID(id, month, status, event,        # Rcpp approach
                      nInds = N, startMonth = 13, thresholdNum = 2)],
  dt[, cohort3 := rAssignCohort(id, month, status, event,    # data.table approach
                      nInds = N, startMonth = 13, thresholdNum = 2), keyby=id],
  dt[, cohort4 := cAssignCohort(month, status, event,   # combined data.table/Rcpp
                      startMonth=13,  thresholdNum = 2), keyby=id],
    replications = 5,
    columns = c(&amp;quot;replications&amp;quot;, &amp;quot;elapsed&amp;quot;, &amp;quot;relative&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   replications elapsed relative
## 1            5  52.578  395.323
## 2            5  66.528  500.211
## 3            5   0.752    5.654
## 4            5   0.133    1.000&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;postscript&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Postscript&lt;/h2&gt;
&lt;p&gt;I shared all of this with the incredibly helpful folks who have created data.table, and they offered a data.table only solution that avoids all looping, which I will share here for completeness. While it is an improvement over the third approach presented above (R function with data.table statment &lt;code&gt;keyby&lt;/code&gt;), it is still no match for the fastest solution. (But, this all just goes to show you there will always be new approaches to consider, and I don’t claim to have come any where near to trying them all out.)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dtfunc &amp;lt;- function(dx) {
  
  dx[, prev12 := Reduce(`+`, shift(event, 1:12)), by=id]
  map &amp;lt;- CJ(id=1:N, start=13L, end=36L, event=1L, statusx=1L, prev12x=1L)
  ans &amp;lt;- dx[map, on=.(id, event, status &amp;gt; statusx, prev12 &amp;gt; prev12x, month &amp;gt;= start, month &amp;lt;= end), 
            .I, allow=TRUE, by=.EACHI, nomatch=0L][, .(id, I)]
  minans &amp;lt;- ans[, .(I=min(I)), by=id]
  
  dx &amp;lt;- dx[, cohort5 := 0L][minans, cohort5 := min(month) - 1L + dx$month[I], on=&amp;quot;id&amp;quot;, by=.EACHI]

  return(dx)
}

system.time(dtfunc(dt))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    user  system elapsed 
##   0.195   0.011   0.210&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And here is a more complete comparison of the fastest version with this additional approach:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;benchmark(
  dt[, cohort6 := cAssignCohort(month, status, event,   # combined data.table/Rcpp
                      startMonth=13,  thresholdNum = 2), keyby=id],
  dt2 &amp;lt;- dtfunc(dt),
  replications = 5,
  columns = c(&amp;quot;replications&amp;quot;, &amp;quot;elapsed&amp;quot;, &amp;quot;relative&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   replications elapsed relative
## 1            5   0.112    1.000
## 2            5   0.899    8.027&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
